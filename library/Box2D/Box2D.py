# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _Box2D.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Box2D')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Box2D')
    _Box2D = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Box2D', [dirname(__file__)])
        except ImportError:
            import _Box2D
            return _Box2D
        try:
            _mod = imp.load_module('_Box2D', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Box2D = swig_import_helper()
    del swig_import_helper
else:
    import _Box2D
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x



def _dir_filter(self):
    """
    Using introspection, mimic dir() by adding up all of the __dicts__
    for the current class and all base classes (type(self).__mro__ returns
    all of the classes that make it up)
    Basically filters by:
        __x__ OK
        __x bad
        _classname bad
    """

    def check(s):
        if s.startswith('__'):
            if s.endswith('__'):
                return True
            else:
                return False
        else:
            for typename in typenames:
                if typename in s:
                    return False
            return True

    keys = sum([list(c.__dict__.keys()) for c in type(self).__mro__],[])
    keys += list(self.__dict__.keys())
    typenames = ["_%s" % c.__name__ for c in type(self).__mro__]
    ret = [s for s in list(set(keys)) if check(s)]
    ret.sort()
    return ret



def _init_kwargs(self, **kwargs):
    cls = self.__class__
    for key, value in kwargs.items():
        try:
            getattr(cls, key)
        except AttributeError:
            raise AttributeError('Invalid keyword argument "%s" for %s' % (key, cls))

        try:
            setattr(self, key, value)
        except Exception as ex:
            raise ex.__class__('Failed on kwargs for %s.%s: %s' \
                        % (self.__class__.__name__, key, ex))

def _init_jointdef_kwargs(self, bodyA=None, bodyB=None, **kwargs):
    if bodyA is not None or bodyB is not None:
# Make sure that bodyA and bodyB are defined before the rest
        _init_kwargs(self, bodyA=bodyA, bodyB=bodyB)

    _init_kwargs(self, **kwargs)


_repr_attrs = {'b2AABB': ['center', 'extents', 'lowerBound', 'perimeter', 'upperBound', 
                          'valid', ],
               'b2Body': ['active', 'angle', 'angularDamping', 'angularVelocity', 'awake', 
                          'bullet', 'contacts', 'fixedRotation', 'fixtures', 
                          'inertia', 'joints', 'linearDamping', 'linearVelocity', 
                          'localCenter', 'mass', 'massData', 'position', 
                          'sleepingAllowed', 'transform', 'type', 'userData', 
                          'worldCenter', ],
               'b2BodyDef': ['active', 'allowSleep', 'angle', 'angularDamping', 'angularVelocity', 
                             'awake', 'bullet', 'fixedRotation', 'fixtures', 
                             'inertiaScale', 'linearDamping', 'linearVelocity', 'position', 
                             'shapeFixture', 'shapes', 'type', 'userData', 
                             ],
               'b2BroadPhase': ['proxyCount', ],
               'b2CircleShape': ['childCount', 'pos', 'radius', 'type', ],
               'b2ClipVertex': ['id', 'v', ],
               'b2Color': ['b', 'bytes', 'g', 'list', 'r', 
                           ],
               'b2Contact': ['childIndexA', 'childIndexB', 'enabled', 'fixtureA', 'fixtureB', 
                             'manifold', 'touching', 'worldManifold', ],
               'b2ContactEdge': ['contact', 'other', ],
               'b2ContactFeature': ['indexA', 'indexB', 'typeA', 'typeB', ],
               'b2ContactID': ['cf', 'key', ],
               'b2ContactImpulse': ['normalImpulses', 'tangentImpulses', ],
               'b2ContactManager': ['allocator', 'broadPhase', 'contactCount', 'contactFilter', 'contactList', 
                                    'contactListener', ],
               'b2ContactPoint': ['fixtureA', 'fixtureB', 'normal', 'position', 'state', 
                                  ],
               'b2DistanceInput': ['proxyA', 'proxyB', 'transformA', 'transformB', 'useRadii', 
                                   ],
               'b2DistanceJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                   'dampingRatio', 'frequency', 'length', 'type', 
                                   'userData', ],
               'b2DistanceJointDef': ['anchorA', 'anchorB', 'bodyA', 'bodyB', 'collideConnected', 
                                      'dampingRatio', 'frequencyHz', 'length', 'localAnchorA', 
                                      'localAnchorB', 'type', 'userData', ],
               'b2DistanceOutput': ['distance', 'iterations', 'pointA', 'pointB', ],
               'b2DistanceProxy': ['m_buffer', 'shape', 'vertices', ],
               'b2Draw': ['flags', ],
               'b2DrawExtended': ['center', 'convertVertices', 'flags', 'flipX', 'flipY', 
                                  'offset', 'screenSize', 'zoom', ],
               'b2EdgeShape': ['all_vertices', 'childCount', 'hasVertex0', 'hasVertex3', 'radius', 
                               'type', 'vertex0', 'vertex1', 'vertex2', 
                               'vertex3', 'vertexCount', 'vertices', ],
               'b2Filter': ['categoryBits', 'groupIndex', 'maskBits', ],
               'b2Fixture': ['body', 'density', 'filterData', 'friction', 'massData', 
                             'restitution', 'sensor', 'shape', 'type', 
                             'userData', ],
               'b2FixtureDef': ['categoryBits', 'density', 'filter', 'friction', 'groupIndex', 
                                'isSensor', 'maskBits', 'restitution', 'shape', 
                                'userData', ],
               'b2FixtureProxy': ['aabb', 'childIndex', 'fixture', 'proxyId', ],
               'b2FrictionJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                   'maxForce', 'maxTorque', 'type', 'userData', 
                                   ],
               'b2FrictionJointDef': ['anchor', 'bodyA', 'bodyB', 'collideConnected', 'localAnchorA', 
                                      'localAnchorB', 'maxForce', 'maxTorque', 'type', 
                                      'userData', ],
               'b2GearJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                               'ratio', 'type', 'userData', ],
               'b2GearJointDef': ['bodyA', 'bodyB', 'collideConnected', 'joint1', 'joint2', 
                                  'ratio', 'type', 'userData', ],
               'b2Jacobian': ['angularA', 'angularB', 'linearA', 'linearB', ],
               'b2Joint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                           'type', 'userData', ],
               'b2JointDef': ['bodyA', 'bodyB', 'collideConnected', 'type', 'userData', 
                              ],
               'b2JointEdge': ['joint', 'other', ],
               'b2WheelJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                'maxMotorTorque', 'motorEnabled', 'motorSpeed', 'speed', 
                                'springDampingRatio', 'springFrequencyHz', 'translation', 'type', 
                                'userData', ],
               'b2WheelJointDef': ['anchor', 'axis', 'bodyA', 'bodyB', 'collideConnected', 
                                   'dampingRatio', 'enableMotor', 'frequencyHz', 'localAnchorA', 
                                   'localAnchorB', 'localAxisA', 'maxMotorTorque', 'motorSpeed', 
                                   'type', 'userData', ],
               'b2ChainShape': ['childCount', 'edges', 'radius', 'type', 'vertexCount', 
                                'vertices', ],
               'b2Manifold': ['localNormal', 'localPoint', 'pointCount', 'points', 'type_', 
                              ],
               'b2ManifoldPoint': ['id', 'isNew', 'localPoint', 'normalImpulse', 'tangentImpulse', 
                                   ],
               'b2MassData': ['I', 'center', 'mass', ],
               'b2Mat22': ['angle', 'col1', 'col2', 'inverse', ],
               'b2Mat33': ['col1', 'col2', 'col3', ],
               'b2MouseJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                'dampingRatio', 'frequency', 'maxForce', 'target', 
                                'type', 'userData', ],
               'b2MouseJointDef': ['bodyA', 'bodyB', 'collideConnected', 'dampingRatio', 'frequencyHz', 
                                   'maxForce', 'target', 'type', 'userData', 
                                   ],
               'b2Pair': ['proxyIdA', 'proxyIdB', ],
               'b2PolygonShape': ['box', 'centroid', 'childCount', 'normals', 'radius', 
                                  'type', 'valid', 'vertexCount', 'vertices', 
                                  ],
               'b2PrismaticJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                    'limitEnabled', 'limits', 'lowerLimit', 'maxMotorForce', 
                                    'motorEnabled', 'motorSpeed', 'speed', 'translation', 
                                    'type', 'upperLimit', 'userData', ],
               'b2PrismaticJointDef': ['anchor', 'axis', 'bodyA', 'bodyB', 'collideConnected', 
                                       'enableLimit', 'enableMotor', 'localAnchorA', 'localAnchorB', 
                                       'localAxis1', 'lowerTranslation', 'maxMotorForce', 'motorSpeed', 
                                       'referenceAngle', 'type', 'upperTranslation', 'userData', 
                                       ],
               'b2PulleyJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                                 'groundAnchorA', 'groundAnchorB', 'length1', 'length2', 
                                 'ratio', 'type', 'userData', ],
               'b2PulleyJointDef': ['anchorA', 'anchorB', 'bodyA', 'bodyB', 'collideConnected', 
                                    'groundAnchorA', 'groundAnchorB', 'lengthA', 'lengthB', 
                                    'localAnchorA', 'localAnchorB', 'maxLengthA', 'maxLengthB', 
                                    'ratio', 'type', 'userData', ],
               'b2RayCastInput': ['maxFraction', 'p1', 'p2', ],
               'b2RayCastOutput': ['fraction', 'normal', ],
               'b2RevoluteJoint': ['active', 'anchorA', 'anchorB', 'angle', 'bodyA', 
                                   'bodyB', 'limitEnabled', 'limits', 'lowerLimit', 
                                   'maxMotorTorque', 'motorEnabled', 'motorSpeed', 'speed', 
                                   'type', 'upperLimit', 'userData', ],
               'b2RevoluteJointDef': ['anchor', 'bodyA', 'bodyB', 'collideConnected', 'enableLimit', 
                                      'enableMotor', 'localAnchorA', 'localAnchorB', 'lowerAngle', 
                                      'maxMotorTorque', 'motorSpeed', 'referenceAngle', 'type', 
                                      'upperAngle', 'userData', ],
               'b2RopeJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                               'limitState', 'maxLength', 'type', 'userData', 
                               ],
               'b2RopeJointDef': ['anchorA', 'anchorB', 'bodyA', 'bodyB', 'collideConnected', 
                                  'localAnchorA', 'localAnchorB', 'maxLength', 'type', 
                                  'userData', ],
               'b2Shape': ['childCount', 'radius', 'type', ],
               'b2Sweep': ['a', 'a0', 'alpha0', 'c', 'c0', 
                           'localCenter', ],
               'b2TOIInput': ['proxyA', 'proxyB', 'sweepA', 'sweepB', 'tMax', 
                              ],
               'b2TOIOutput': ['state', 't', ],
               'b2Transform': ['R', 'angle', 'position', ],
               'b2Vec2': ['length', 'lengthSquared', 'skew', 'tuple', 'valid', 
                          'x', 'y', ],
               'b2Vec3': ['length', 'lengthSquared', 'tuple', 'valid', 'x', 
                          'y', 'z', ],
               'b2Version': ['major', 'minor', 'revision', ],
               'b2WeldJoint': ['active', 'anchorA', 'anchorB', 'bodyA', 'bodyB', 
                               'type', 'userData', ],
               'b2WeldJointDef': ['anchor', 'bodyA', 'bodyB', 'collideConnected', 'localAnchorA', 
                                  'localAnchorB', 'referenceAngle', 'type', 'userData', 
                                  ],
               'b2World': ['autoClearForces', 'bodies', 'bodyCount', 'contactCount', 'contactFilter', 
                           'contactListener', 'contactManager', 'contacts', 'continuousPhysics', 
                           'destructionListener', 'gravity', 'jointCount', 'joints', 
                           'locked', 'proxyCount', 'renderer', 'subStepping', 
                           'warmStarting', ],
               'b2WorldManifold': ['normal', 'points', ],
               }

MAX_REPR_DEPTH = 4
MAX_REPR_STR_LEN = 250
MAX_REPR_SUB_LINES = 10
REPR_INDENT = 4

_repr_state = {}
def _format_repr(obj):
    """
    Dynamically creates the object representation string for `obj`.

    Attributes found in _repr_attrs[class_name] will be included.
    """

    global _repr_state
    if 'spaces' not in _repr_state:
        _repr_state['spaces'] = 0

    if 'depth' not in _repr_state:
        _repr_state['depth'] = 1
    else:
        _repr_state['depth'] += 1

    if _repr_state['depth'] > MAX_REPR_DEPTH:
        _repr_state['depth'] -= 1
        return '%s(max recursion depth hit)' % (' ' * _repr_state['spaces'])

    class_line = '%s(' % (obj.__class__.__name__, )

    orig_spaces = _repr_state['spaces']

    ret = []

    props = _repr_attrs.get(obj.__class__.__name__, [])

    try:
        prop_spacing = _repr_state['spaces'] + len(class_line.lstrip())
        separator = '\n' + ' ' * prop_spacing

        for prop in props:
            _repr_state['spaces'] = len(prop) + 1
            try:
                s = repr(getattr(obj, prop))
            except Exception as ex:
                s = '(repr: %s)' % ex

            lines = s.split('\n')
            if len(lines) > MAX_REPR_SUB_LINES:
                length_ = 0
                for i, line_ in enumerate(lines[:MAX_REPR_SUB_LINES]):
                    length_ += len(line_)
                    if length_ > MAX_REPR_STR_LEN:
                        ending_delim = []
                        for j in s[::-1]:
                            if j in ')]}':
                                ending_delim.insert(0, j)
                            else:
                                break

                        ret[-1] = '%s...  %s' % (ret[-1], ''.join(ending_delim))
                        break

                    if i == 0:
                        ret.append('%s=%s' % (prop, line_))
                    else:
                        ret.append(line_) 
            else:
                ret.append('%s=%s' % (prop, lines[0].lstrip()))
                if len(lines) > 1:
                    ret.extend(lines[1:])

            ret[-1] += ','

    finally:
        _repr_state['depth'] -= 1
        _repr_state['spaces'] = orig_spaces

    if 1<= len(ret) <= 3:
# Closing parenthesis on same line
        ret[-1] += ')'
        return ''.join(ret)

    else:
# Closing parenthesis on next line
        ret.append(')')
        return '%s%s' % (class_line, separator.join(ret))


def __jointeq(a, b):
    """__jointeq(b2Joint a, b2Joint b) -> bool"""
    return _Box2D.__jointeq(a, b)

def __bodyeq(a, b):
    """__bodyeq(b2Body a, b2Body b) -> bool"""
    return _Box2D.__bodyeq(a, b)

def __shapeeq(a, b):
    """__shapeeq(b2Shape a, b2Shape b) -> bool"""
    return _Box2D.__shapeeq(a, b)

def __fixtureeq(a, b):
    """__fixtureeq(b2Fixture a, b2Fixture b) -> bool"""
    return _Box2D.__fixtureeq(a, b)

def __b2ComputeCentroid(vs, count):
    """__b2ComputeCentroid(b2Vec2 vs, int32 count) -> b2Vec2"""
    return _Box2D.__b2ComputeCentroid(vs, count)

def b2CheckVertices(vertices, count, additional_checks=True):
    """b2CheckVertices(b2Vec2 vertices, int32 count, bool additional_checks=True) -> bool"""
    return _Box2D.b2CheckVertices(vertices, count, additional_checks)

def b2CheckPolygon(shape, additional_checks=True):
    """b2CheckPolygon(b2PolygonShape shape, bool additional_checks=True) -> bool"""
    return _Box2D.b2CheckPolygon(shape, additional_checks)
RAND_LIMIT = _Box2D.RAND_LIMIT

def b2Random(*args):
    """
    b2Random() -> float32
    b2Random(float32 lo, float32 hi) -> float32
    """
    return _Box2D.b2Random(*args)

b2_epsilon = 1.192092896e-07

class _indexable_generator(list):
    def __init__(self, iter):
        list.__init__(self)
        self.iter=iter
        self.__full=False
    def __len__(self):
        self.__fill_list__()
        return super(_indexable_generator, self).__len__()
    def __iter__(self):
        for item in self.iter:
            self.append(item)
            yield item
        self.__full=True
    def __fill_list__(self):
        for item in self.iter:
            self.append(item)
        self.__full=True
    def __getitem__(self, i):
        """Support indexing positive/negative elements of the generator,
        but no slices. If you want those, use list(generator)"""
        if not self.__full:
            if i < 0:
                self.__fill_list__()
            elif i >= list.__len__(self):
                diff=i-list.__len__(self)+1
                for j in range(diff):
                    value = next(self.iter)
                    self.append(value)

        return super(_indexable_generator, self).__getitem__(i)

def _generator_from_linked_list(first):
    if first:
        one = first
        while one:
            yield one
            one = one.next

def _list_from_linked_list(first):
    if not first:
        return []

    one = first
    lst = []
    while one:
        lst.append(one)
        one = one.next

# linked lists are stored in reverse order from creation order
    lst.reverse() 
    return lst

# Support using == on bodies, joints, and shapes
def b2ShapeCompare(a, b):
    if not isinstance(a, b2Shape) or not isinstance(b, b2Shape):
        return False
    return __shapeeq(a, b)
def b2BodyCompare(a, b):
    if not isinstance(a, b2Body) or not isinstance(b, b2Body):
        return False
    return __bodyeq(a, b)
def b2JointCompare(a, b):
    if not isinstance(a, b2Joint) or not isinstance(b, b2Joint):
        return False
    return __jointeq(a, b)
def b2FixtureCompare(a, b):
    if not isinstance(a, b2Fixture) or not isinstance(b, b2Fixture):
        return False
    return __fixtureeq(a, b)



def _b2Distance(*args):
    """
    _b2Distance(b2Shape shapeA, int idxA, b2Shape shapeB, int idxB, b2Transform transformA, b2Transform transformB, bool useRadii=True) -> b2DistanceOutput
    _b2Distance(b2DistanceInput input) -> b2DistanceOutput
    """
    return _Box2D._b2Distance(*args)

import collections

b2DistanceResult = collections.namedtuple('b2DistanceResult', 
                                          'pointA pointB distance iterations')

def b2Distance(shapeA=None, idxA=0, shapeB=None, idxB=0, transformA=None, transformB=None, useRadii=True):
    """
    Compute the closest points between two shapes.

    Can be called one of two ways:
    + b2Distance(b2DistanceInput)
    This uses the b2DistanceInput structure, where you define your own
    distance proxies

    Or more conveniently using kwargs:
    + b2Distance(shapeA=.., idxA=0, shapeB=.., idxB=0, transformA=..,
                 transformB=.., useRadii=True)

    Returns a namedtuple in the form:
        b2DistanceResult(pointA=(ax, ay), pointB=(bx, by), distance,
                         iterations)
    """
    if isinstance(shapeA, b2DistanceInput):
        out = _b2Distance(shapeA)
    else:
        out = _b2Distance(shapeA, idxA, shapeB, idxB, transformA, transformB, useRadii)

    return b2DistanceResult(pointA=tuple(out.pointA),
                            pointB=tuple(out.pointB),
                            distance=out.distance,
                            iterations=out.iterations)


def b2GetPointStates(manifold1, manifold2):
    """
    b2GetPointStates(b2Manifold manifold1, b2Manifold manifold2) -> PyObject *

    Compute the point states given two manifolds. The states pertain to the transition from manifold1 to manifold2. So state1 is either persist or remove while state2 is either add or persist.
    """
    return _Box2D.b2GetPointStates(manifold1, manifold2)
class b2ContactPoint(object):
    """Proxy of C++ b2ContactPoint class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2ContactPoint_swiginit(self,_Box2D.new_b2ContactPoint())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactPoint
    fixtureA = _swig_property(_Box2D.b2ContactPoint_fixtureA_get, _Box2D.b2ContactPoint_fixtureA_set)
    fixtureB = _swig_property(_Box2D.b2ContactPoint_fixtureB_get, _Box2D.b2ContactPoint_fixtureB_set)
    normal = _swig_property(_Box2D.b2ContactPoint_normal_get, _Box2D.b2ContactPoint_normal_set)
    position = _swig_property(_Box2D.b2ContactPoint_position_get, _Box2D.b2ContactPoint_position_set)
    state = _swig_property(_Box2D.b2ContactPoint_state_get, _Box2D.b2ContactPoint_state_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactPoint self) -> long"""
        return _Box2D.b2ContactPoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 

b2ContactPoint.__hash__ = new_instancemethod(_Box2D.b2ContactPoint___hash__, None, b2ContactPoint)
b2ContactPoint_swigregister = _Box2D.b2ContactPoint_swigregister
b2ContactPoint_swigregister(b2ContactPoint)
b2Globals = _Box2D.b2Globals


def _b2TimeOfImpact(*args):
    """
    _b2TimeOfImpact(b2Shape shapeA, int idxA, b2Shape shapeB, int idxB, b2Sweep sweepA, b2Sweep sweepB, float32 tMax) -> b2TOIOutput
    _b2TimeOfImpact(b2TOIInput input) -> b2TOIOutput
    """
    return _Box2D._b2TimeOfImpact(*args)

def b2TimeOfImpact(shapeA=None, idxA=0, shapeB=None, idxB=0, sweepA=None, sweepB=None, tMax=0.0):
    """
    Compute the upper bound on time before two shapes penetrate. Time is represented as
    a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
    non-tunneling collision. If you change the time interval, you should call this function
    again.
    Note: use b2Distance to compute the contact point and normal at the time of impact.

    Can be called one of several ways:
    + b2TimeOfImpact(b2TOIInput) # utilizes the b2TOIInput structure, where you define your own proxies

    Or utilizing kwargs:
    + b2TimeOfImpact(shapeA=a, shapeB=b, idxA=0, idxB=0, sweepA=sa, sweepB=sb, tMax=t)
    Where idxA and idxB are optional and used only if the shapes are loops (they indicate which section to use.)
    sweep[A,B] are of type b2Sweep.

    Returns a tuple in the form:
    (output state, time of impact)

    Where output state is in b2TOIOutput.[
            e_unknown, 
            e_failed,
            e_overlapped,
            e_touching,
            e_separated ]
    """

    if isinstance(shapeA, b2TOIInput):
        toi_input = shapeA
        out = _b2TimeOfImpact(toi_input)
    else:
        out = _b2TimeOfImpact(shapeA, idxA, shapeB, idxB, sweepA, sweepB, tMax)

    return (out.state, out.t)

class b2AssertException(object):
    """Proxy of C++ b2AssertException class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2AssertException self) -> long"""
        return _Box2D.b2AssertException___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        """__init__(b2AssertException self) -> b2AssertException"""
        _Box2D.b2AssertException_swiginit(self, _Box2D.new_b2AssertException())
    __swig_destroy__ = _Box2D.delete_b2AssertException
b2AssertException.__hash__ = new_instancemethod(_Box2D.b2AssertException___hash__, None, b2AssertException)
b2AssertException_swigregister = _Box2D.b2AssertException_swigregister
b2AssertException_swigregister(b2AssertException)

b2_pi = _Box2D.b2_pi
b2_maxManifoldPoints = _Box2D.b2_maxManifoldPoints
b2_maxPolygonVertices = _Box2D.b2_maxPolygonVertices
b2_aabbExtension = _Box2D.b2_aabbExtension
b2_aabbMultiplier = _Box2D.b2_aabbMultiplier
b2_linearSlop = _Box2D.b2_linearSlop
b2_angularSlop = _Box2D.b2_angularSlop
b2_polygonRadius = _Box2D.b2_polygonRadius
b2_maxSubSteps = _Box2D.b2_maxSubSteps
b2_maxTOIContacts = _Box2D.b2_maxTOIContacts
b2_velocityThreshold = _Box2D.b2_velocityThreshold
b2_maxLinearCorrection = _Box2D.b2_maxLinearCorrection
b2_maxAngularCorrection = _Box2D.b2_maxAngularCorrection
b2_maxTranslation = _Box2D.b2_maxTranslation
b2_maxTranslationSquared = _Box2D.b2_maxTranslationSquared
b2_maxRotation = _Box2D.b2_maxRotation
b2_maxRotationSquared = _Box2D.b2_maxRotationSquared
b2_baumgarte = _Box2D.b2_baumgarte
b2_toiBaugarte = _Box2D.b2_toiBaugarte
b2_timeToSleep = _Box2D.b2_timeToSleep
b2_linearSleepTolerance = _Box2D.b2_linearSleepTolerance
b2_angularSleepTolerance = _Box2D.b2_angularSleepTolerance

def b2Alloc(size):
    """
    b2Alloc(int32 size) -> void *

    Implement this function to use your own memory allocator.
    """
    return _Box2D.b2Alloc(size)

def b2Free(mem):
    """
    b2Free(void * mem)

    If you implement b2Alloc, you should also implement this function.
    """
    return _Box2D.b2Free(mem)

def b2Log(string):
    """b2Log(char const * string)"""
    return _Box2D.b2Log(string)
class b2Version(object):
    """Version numbering scheme. See http://en.wikipedia.org/wiki/Software_versioning"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    major = _swig_property(_Box2D.b2Version_major_get, _Box2D.b2Version_major_set)
    minor = _swig_property(_Box2D.b2Version_minor_get, _Box2D.b2Version_minor_set)
    revision = _swig_property(_Box2D.b2Version_revision_get, _Box2D.b2Version_revision_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Version self) -> long"""
        return _Box2D.b2Version___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __repr__(self):
        return "b2Version(%s.%s.%s)" % (self.major, self.minor, self.revision)


    def __init__(self, **kwargs):
        _Box2D.b2Version_swiginit(self,_Box2D.new_b2Version())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Version
b2Version.__hash__ = new_instancemethod(_Box2D.b2Version___hash__, None, b2Version)
b2Version_swigregister = _Box2D.b2Version_swigregister
b2Version_swigregister(b2Version)


def b2IsValid(x):
    """
    b2IsValid(float32 x) -> bool

    This function is used to ensure that a floating point number is not a NaN or infinity.
    """
    return _Box2D.b2IsValid(x)

def b2InvSqrt(x):
    """
    b2InvSqrt(float32 x) -> float32

    This is a approximate yet fast inverse square-root.
    """
    return _Box2D.b2InvSqrt(x)
class b2Vec2(object):
    """A 2D column vector."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetZero(self):
        """
        SetZero(b2Vec2 self)

        Set this vector to all zeros.
        """
        return _Box2D.b2Vec2_SetZero(self)


    def Set(self, x_, y_):
        """
        Set(b2Vec2 self, float32 x_, float32 y_)

        Set this vector to some specified coordinates.
        """
        return _Box2D.b2Vec2_Set(self, x_, y_)


    def __neg__(self):
        """__neg__(b2Vec2 self) -> b2Vec2"""
        return _Box2D.b2Vec2___neg__(self)


    def __call__(self, *args):
        """
        __call__(b2Vec2 self, int32 i) -> float32
        __call__(b2Vec2 self, int32 i) -> float32 &
        """
        return _Box2D.b2Vec2___call__(self, *args)


    def __add_vector(self, v):
        """__add_vector(b2Vec2 self, b2Vec2 v)"""
        return _Box2D.b2Vec2___add_vector(self, v)


    def __sub_vector(self, v):
        """__sub_vector(b2Vec2 self, b2Vec2 v)"""
        return _Box2D.b2Vec2___sub_vector(self, v)


    def __mul_float(self, a):
        """__mul_float(b2Vec2 self, float32 a)"""
        return _Box2D.b2Vec2___mul_float(self, a)


    def __Length(self):
        """
        __Length(b2Vec2 self) -> float32

        Get the length of this vector (the norm).
        """
        return _Box2D.b2Vec2___Length(self)


    def __LengthSquared(self):
        """
        __LengthSquared(b2Vec2 self) -> float32

        Get the length squared. For performance, use this instead of  b2Vec2::Length(if possible).
        """
        return _Box2D.b2Vec2___LengthSquared(self)


    def Normalize(self):
        """
        Normalize(b2Vec2 self) -> float32

        Convert this vector into a unit vector. Returns the length.
        """
        return _Box2D.b2Vec2_Normalize(self)


    def __IsValid(self):
        """
        __IsValid(b2Vec2 self) -> bool

        Does this vector contain finite coordinates?
        """
        return _Box2D.b2Vec2___IsValid(self)


    def __Skew(self):
        """
        __Skew(b2Vec2 self) -> b2Vec2

        Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        """
        return _Box2D.b2Vec2___Skew(self)

    x = _swig_property(_Box2D.b2Vec2_x_get, _Box2D.b2Vec2_x_set)
    y = _swig_property(_Box2D.b2Vec2_y_get, _Box2D.b2Vec2_y_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Vec2 self) -> long"""
        return _Box2D.b2Vec2___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        """
        __init__(b2Vec2 self, float32 x, float32 y) -> b2Vec2
        __init__(b2Vec2 self) -> b2Vec2
        __init__(b2Vec2 self, b2Vec2 other) -> b2Vec2

        Construct using coordinates.
        """
        _Box2D.b2Vec2_swiginit(self, _Box2D.new_b2Vec2(*args))

    __iter__ = lambda self: iter( (self.x, self.y) )
    __eq__ = lambda self, other: self.__equ(other)
    __ne__ = lambda self,other: not self.__equ(other)
    def __repr__(self):
        return "b2Vec2(%g,%g)" % (self.x, self.y)
    def __len__(self):
        return 2
    def __neg__(self):
        return b2Vec2(-self.x, -self.y)
    def copy(self):
        """
        Return a copy of the vector.
        Remember that the following:
            a = b2Vec2()
            b = a
        Does not copy the vector itself, but b now refers to a.
        """
        return b2Vec2(self.x, self.y)
    __copy__ = copy

    def __iadd__(self, other):
        self.__add_vector(other)
        return self
    def __isub__(self, other):
        self.__sub_vector(other)
        return self
    def __imul__(self, a):
        self.__mul_float(a)
        return self
    def __itruediv__(self, a):
        self.__div_float(a)
        return self
    def __idiv__(self, a):
        self.__div_float(a)
        return self
    def __set(self, x, y):
        self.x = x
        self.y = y
    def __nonzero__(self):
        return self.x!=0.0 or self.y!=0.0

    tuple = property(lambda self: (self.x, self.y), lambda self, value: self.__set(*value))
    length = property(__Length, None)
    lengthSquared = property(__LengthSquared, None)
    valid = property(__IsValid, None)
    skew = property(__Skew, None) 



    def cross(self, *args):
        """
        cross(b2Vec2 self, b2Vec2 other) -> float32
        cross(b2Vec2 self, float32 s) -> b2Vec2
        """
        return _Box2D.b2Vec2_cross(self, *args)


    def __getitem__(self, i):
        """__getitem__(b2Vec2 self, int i) -> float32"""
        return _Box2D.b2Vec2___getitem__(self, i)


    def __setitem__(self, i, value):
        """__setitem__(b2Vec2 self, int i, float32 value)"""
        return _Box2D.b2Vec2___setitem__(self, i, value)


    def __equ(self, other):
        """__equ(b2Vec2 self, b2Vec2 other) -> bool"""
        return _Box2D.b2Vec2___equ(self, other)


    def dot(self, other):
        """dot(b2Vec2 self, b2Vec2 other) -> float32"""
        return _Box2D.b2Vec2_dot(self, other)


    def __truediv__(self, a):
        """__truediv__(b2Vec2 self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___truediv__(self, a)


    def __div__(self, a):
        """__div__(b2Vec2 self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___div__(self, a)


    def __mul__(self, a):
        """__mul__(b2Vec2 self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___mul__(self, a)


    def __add__(self, other):
        """__add__(b2Vec2 self, b2Vec2 other) -> b2Vec2"""
        return _Box2D.b2Vec2___add__(self, other)


    def __sub__(self, other):
        """__sub__(b2Vec2 self, b2Vec2 other) -> b2Vec2"""
        return _Box2D.b2Vec2___sub__(self, other)


    def __rmul__(self, a):
        """__rmul__(b2Vec2 self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___rmul__(self, a)


    def __rdiv__(self, a):
        """__rdiv__(b2Vec2 self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___rdiv__(self, a)


    def __div_float(self, a):
        """__div_float(b2Vec2 self, float32 a)"""
        return _Box2D.b2Vec2___div_float(self, a)

    __swig_destroy__ = _Box2D.delete_b2Vec2
b2Vec2.SetZero = new_instancemethod(_Box2D.b2Vec2_SetZero, None, b2Vec2)
b2Vec2.Set = new_instancemethod(_Box2D.b2Vec2_Set, None, b2Vec2)
b2Vec2.__neg__ = new_instancemethod(_Box2D.b2Vec2___neg__, None, b2Vec2)
b2Vec2.__call__ = new_instancemethod(_Box2D.b2Vec2___call__, None, b2Vec2)
b2Vec2.__add_vector = new_instancemethod(_Box2D.b2Vec2___add_vector, None, b2Vec2)
b2Vec2.__sub_vector = new_instancemethod(_Box2D.b2Vec2___sub_vector, None, b2Vec2)
b2Vec2.__mul_float = new_instancemethod(_Box2D.b2Vec2___mul_float, None, b2Vec2)
b2Vec2.__Length = new_instancemethod(_Box2D.b2Vec2___Length, None, b2Vec2)
b2Vec2.__LengthSquared = new_instancemethod(_Box2D.b2Vec2___LengthSquared, None, b2Vec2)
b2Vec2.Normalize = new_instancemethod(_Box2D.b2Vec2_Normalize, None, b2Vec2)
b2Vec2.__IsValid = new_instancemethod(_Box2D.b2Vec2___IsValid, None, b2Vec2)
b2Vec2.__Skew = new_instancemethod(_Box2D.b2Vec2___Skew, None, b2Vec2)
b2Vec2.__hash__ = new_instancemethod(_Box2D.b2Vec2___hash__, None, b2Vec2)
b2Vec2.cross = new_instancemethod(_Box2D.b2Vec2_cross, None, b2Vec2)
b2Vec2.__getitem__ = new_instancemethod(_Box2D.b2Vec2___getitem__, None, b2Vec2)
b2Vec2.__setitem__ = new_instancemethod(_Box2D.b2Vec2___setitem__, None, b2Vec2)
b2Vec2.__equ = new_instancemethod(_Box2D.b2Vec2___equ, None, b2Vec2)
b2Vec2.dot = new_instancemethod(_Box2D.b2Vec2_dot, None, b2Vec2)
b2Vec2.__truediv__ = new_instancemethod(_Box2D.b2Vec2___truediv__, None, b2Vec2)
b2Vec2.__div__ = new_instancemethod(_Box2D.b2Vec2___div__, None, b2Vec2)
b2Vec2.__mul__ = new_instancemethod(_Box2D.b2Vec2___mul__, None, b2Vec2)
b2Vec2.__add__ = new_instancemethod(_Box2D.b2Vec2___add__, None, b2Vec2)
b2Vec2.__sub__ = new_instancemethod(_Box2D.b2Vec2___sub__, None, b2Vec2)
b2Vec2.__rmul__ = new_instancemethod(_Box2D.b2Vec2___rmul__, None, b2Vec2)
b2Vec2.__rdiv__ = new_instancemethod(_Box2D.b2Vec2___rdiv__, None, b2Vec2)
b2Vec2.__div_float = new_instancemethod(_Box2D.b2Vec2___div_float, None, b2Vec2)
b2Vec2_swigregister = _Box2D.b2Vec2_swigregister
b2Vec2_swigregister(b2Vec2)

class b2Vec3(object):
    """A 2D column vector with 3 elements."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetZero(self):
        """
        SetZero(b2Vec3 self)

        Set this vector to all zeros.
        """
        return _Box2D.b2Vec3_SetZero(self)


    def Set(self, x_, y_, z_):
        """
        Set(b2Vec3 self, float32 x_, float32 y_, float32 z_)

        Set this vector to some specified coordinates.
        """
        return _Box2D.b2Vec3_Set(self, x_, y_, z_)


    def __neg__(self):
        """__neg__(b2Vec3 self) -> b2Vec3"""
        return _Box2D.b2Vec3___neg__(self)


    def __add_vector(self, v):
        """__add_vector(b2Vec3 self, b2Vec3 v)"""
        return _Box2D.b2Vec3___add_vector(self, v)


    def __sub_vector(self, v):
        """__sub_vector(b2Vec3 self, b2Vec3 v)"""
        return _Box2D.b2Vec3___sub_vector(self, v)


    def __mul_float(self, s):
        """__mul_float(b2Vec3 self, float32 s)"""
        return _Box2D.b2Vec3___mul_float(self, s)

    x = _swig_property(_Box2D.b2Vec3_x_get, _Box2D.b2Vec3_x_set)
    y = _swig_property(_Box2D.b2Vec3_y_get, _Box2D.b2Vec3_y_set)
    z = _swig_property(_Box2D.b2Vec3_z_get, _Box2D.b2Vec3_z_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Vec3 self) -> long"""
        return _Box2D.b2Vec3___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        """
        __init__(b2Vec3 self, float32 x, float32 y, float32 z) -> b2Vec3
        __init__(b2Vec3 self) -> b2Vec3
        __init__(b2Vec3 self, b2Vec3 other) -> b2Vec3
        __init__(b2Vec3 self, b2Vec2 other) -> b2Vec3

        Construct using coordinates.
        """
        _Box2D.b2Vec3_swiginit(self, _Box2D.new_b2Vec3(*args))

    __iter__ = lambda self: iter( (self.x, self.y, self.z) )
    __eq__ = lambda self, other: (self.x == other.x and self.y == other.y and self.z == other.z)
    __ne__ = lambda self, other: (self.x != other.x or self.y != other.y or self.z != other.z)
    def __repr__(self):
        return "b2Vec3(%g,%g,%g)" % (self.x, self.y, self.z)
    def __len__(self):
        return 3
    def __neg__(self):
        return b2Vec3(-self.x, -self.y, -self.z)
    def copy(self):
        """
        Return a copy of the vector.
        Remember that the following:
            a = b2Vec3()
            b = a
        Does not copy the vector itself, but b now refers to a.
        """
        return b2Vec3(self.x, self.y, self.z)
    __copy__ = copy
    def __iadd__(self, other):
        self.__add_vector(other)
        return self
    def __isub__(self, other):
        self.__sub_vector(other)
        return self
    def __imul__(self, a):
        self.__mul_float(a)
        return self
    def __itruediv__(self, a):
        self.__div_float(a)
        return self
    def __idiv__(self, a):
        self.__div_float(a)
        return self
    def dot(self, v):
        """
        Dot product with v (list/tuple or b2Vec3)
        """
        if isinstance(v, (list, tuple)):
            return self.x*v[0] + self.y*v[1] + self.z*v[2]
        else:
            return self.x*v.x + self.y*v.y + self.z*v.z
    def __set(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    def __nonzero__(self):
        return self.x!=0.0 or self.y!=0.0 or self.z!=0.0

    tuple = property(lambda self: (self.x, self.y, self.z), lambda self, value: self.__set(*value))
    length = property(_Box2D.b2Vec3___Length, None)
    lengthSquared = property(_Box2D.b2Vec3___LengthSquared, None)
    valid = property(_Box2D.b2Vec3___IsValid, None)



    def cross(self, b):
        """cross(b2Vec3 self, b2Vec3 b) -> b2Vec3"""
        return _Box2D.b2Vec3_cross(self, b)


    def __getitem__(self, i):
        """__getitem__(b2Vec3 self, int i) -> float32"""
        return _Box2D.b2Vec3___getitem__(self, i)


    def __setitem__(self, i, value):
        """__setitem__(b2Vec3 self, int i, float32 value)"""
        return _Box2D.b2Vec3___setitem__(self, i, value)


    def __IsValid(self):
        """__IsValid(b2Vec3 self) -> bool"""
        return _Box2D.b2Vec3___IsValid(self)


    def __Length(self):
        """__Length(b2Vec3 self) -> float32"""
        return _Box2D.b2Vec3___Length(self)


    def __LengthSquared(self):
        """__LengthSquared(b2Vec3 self) -> float32"""
        return _Box2D.b2Vec3___LengthSquared(self)


    def __truediv__(self, a):
        """__truediv__(b2Vec3 self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___truediv__(self, a)


    def __div__(self, a):
        """__div__(b2Vec3 self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___div__(self, a)


    def __mul__(self, a):
        """__mul__(b2Vec3 self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___mul__(self, a)


    def __add__(self, other):
        """__add__(b2Vec3 self, b2Vec3 other) -> b2Vec3"""
        return _Box2D.b2Vec3___add__(self, other)


    def __sub__(self, other):
        """__sub__(b2Vec3 self, b2Vec3 other) -> b2Vec3"""
        return _Box2D.b2Vec3___sub__(self, other)


    def __rmul__(self, a):
        """__rmul__(b2Vec3 self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___rmul__(self, a)


    def __rdiv__(self, a):
        """__rdiv__(b2Vec3 self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___rdiv__(self, a)


    def __div_float(self, a):
        """__div_float(b2Vec3 self, float32 a)"""
        return _Box2D.b2Vec3___div_float(self, a)

    __swig_destroy__ = _Box2D.delete_b2Vec3
b2Vec3.SetZero = new_instancemethod(_Box2D.b2Vec3_SetZero, None, b2Vec3)
b2Vec3.Set = new_instancemethod(_Box2D.b2Vec3_Set, None, b2Vec3)
b2Vec3.__neg__ = new_instancemethod(_Box2D.b2Vec3___neg__, None, b2Vec3)
b2Vec3.__add_vector = new_instancemethod(_Box2D.b2Vec3___add_vector, None, b2Vec3)
b2Vec3.__sub_vector = new_instancemethod(_Box2D.b2Vec3___sub_vector, None, b2Vec3)
b2Vec3.__mul_float = new_instancemethod(_Box2D.b2Vec3___mul_float, None, b2Vec3)
b2Vec3.__hash__ = new_instancemethod(_Box2D.b2Vec3___hash__, None, b2Vec3)
b2Vec3.cross = new_instancemethod(_Box2D.b2Vec3_cross, None, b2Vec3)
b2Vec3.__getitem__ = new_instancemethod(_Box2D.b2Vec3___getitem__, None, b2Vec3)
b2Vec3.__setitem__ = new_instancemethod(_Box2D.b2Vec3___setitem__, None, b2Vec3)
b2Vec3.__IsValid = new_instancemethod(_Box2D.b2Vec3___IsValid, None, b2Vec3)
b2Vec3.__Length = new_instancemethod(_Box2D.b2Vec3___Length, None, b2Vec3)
b2Vec3.__LengthSquared = new_instancemethod(_Box2D.b2Vec3___LengthSquared, None, b2Vec3)
b2Vec3.__truediv__ = new_instancemethod(_Box2D.b2Vec3___truediv__, None, b2Vec3)
b2Vec3.__div__ = new_instancemethod(_Box2D.b2Vec3___div__, None, b2Vec3)
b2Vec3.__mul__ = new_instancemethod(_Box2D.b2Vec3___mul__, None, b2Vec3)
b2Vec3.__add__ = new_instancemethod(_Box2D.b2Vec3___add__, None, b2Vec3)
b2Vec3.__sub__ = new_instancemethod(_Box2D.b2Vec3___sub__, None, b2Vec3)
b2Vec3.__rmul__ = new_instancemethod(_Box2D.b2Vec3___rmul__, None, b2Vec3)
b2Vec3.__rdiv__ = new_instancemethod(_Box2D.b2Vec3___rdiv__, None, b2Vec3)
b2Vec3.__div_float = new_instancemethod(_Box2D.b2Vec3___div_float, None, b2Vec3)
b2Vec3_swigregister = _Box2D.b2Vec3_swigregister
b2Vec3_swigregister(b2Vec3)

class b2Mat22(object):
    """A 2-by-2 matrix. Stored in column-major order."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetIdentity(self):
        """
        SetIdentity(b2Mat22 self)

        Set this to the identity matrix.
        """
        return _Box2D.b2Mat22_SetIdentity(self)


    def SetZero(self):
        """
        SetZero(b2Mat22 self)

        Set this matrix to all zeros.
        """
        return _Box2D.b2Mat22_SetZero(self)


    def __GetInverse(self):
        """__GetInverse(b2Mat22 self) -> b2Mat22"""
        return _Box2D.b2Mat22___GetInverse(self)


    def Solve(self, b):
        """
        Solve(b2Mat22 self, b2Vec2 b) -> b2Vec2

        Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse in one-shot cases.
        """
        return _Box2D.b2Mat22_Solve(self, b)

    col1 = _swig_property(_Box2D.b2Mat22_col1_get, _Box2D.b2Mat22_col1_set)
    col2 = _swig_property(_Box2D.b2Mat22_col2_get, _Box2D.b2Mat22_col2_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Mat22 self) -> long"""
        return _Box2D.b2Mat22___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        """
        __init__(b2Mat22 self, b2Vec2 c1, b2Vec2 c2) -> b2Mat22
        __init__(b2Mat22 self, float32 a11, float32 a12, float32 a21, float32 a22) -> b2Mat22
        __init__(b2Mat22 self) -> b2Mat22

        Construct this matrix using an angle. This matrix becomes an orthonormal rotation matrix.
        """
        _Box2D.b2Mat22_swiginit(self, _Box2D.new_b2Mat22(*args))

    def __GetAngle(self):
        """__GetAngle(b2Mat22 self) -> float32"""
        return _Box2D.b2Mat22___GetAngle(self)


    def __SetAngle(self, *args):
        """
        __SetAngle(b2Mat22 self, b2Vec2 c1, b2Vec2 c2)
        __SetAngle(b2Mat22 self, float32 angle)
        """
        return _Box2D.b2Mat22___SetAngle(self, *args)


            # Read-only
    inverse = property(__GetInverse, None)
    angle = property(__GetAngle, __SetAngle)
    ex = property(lambda self: self.col1,
                  lambda self, v: setattr(self, 'col1', v))
    ey = property(lambda self: self.col2,
                  lambda self, v: setattr(self, 'col2', v))
    set = __SetAngle


    def __mul__(self, *args):
        """
        __mul__(b2Mat22 self, b2Vec2 v) -> b2Vec2
        __mul__(b2Mat22 self, b2Mat22 m) -> b2Mat22
        """
        return _Box2D.b2Mat22___mul__(self, *args)


    def __add__(self, m):
        """__add__(b2Mat22 self, b2Mat22 m) -> b2Mat22"""
        return _Box2D.b2Mat22___add__(self, m)


    def __sub__(self, m):
        """__sub__(b2Mat22 self, b2Mat22 m) -> b2Mat22"""
        return _Box2D.b2Mat22___sub__(self, m)


    def __iadd(self, m):
        """__iadd(b2Mat22 self, b2Mat22 m)"""
        return _Box2D.b2Mat22___iadd(self, m)


    def __isub(self, m):
        """__isub(b2Mat22 self, b2Mat22 m)"""
        return _Box2D.b2Mat22___isub(self, m)

    __swig_destroy__ = _Box2D.delete_b2Mat22
b2Mat22.SetIdentity = new_instancemethod(_Box2D.b2Mat22_SetIdentity, None, b2Mat22)
b2Mat22.SetZero = new_instancemethod(_Box2D.b2Mat22_SetZero, None, b2Mat22)
b2Mat22.__GetInverse = new_instancemethod(_Box2D.b2Mat22___GetInverse, None, b2Mat22)
b2Mat22.Solve = new_instancemethod(_Box2D.b2Mat22_Solve, None, b2Mat22)
b2Mat22.__hash__ = new_instancemethod(_Box2D.b2Mat22___hash__, None, b2Mat22)
b2Mat22.__GetAngle = new_instancemethod(_Box2D.b2Mat22___GetAngle, None, b2Mat22)
b2Mat22.__SetAngle = new_instancemethod(_Box2D.b2Mat22___SetAngle, None, b2Mat22)
b2Mat22.__mul__ = new_instancemethod(_Box2D.b2Mat22___mul__, None, b2Mat22)
b2Mat22.__add__ = new_instancemethod(_Box2D.b2Mat22___add__, None, b2Mat22)
b2Mat22.__sub__ = new_instancemethod(_Box2D.b2Mat22___sub__, None, b2Mat22)
b2Mat22.__iadd = new_instancemethod(_Box2D.b2Mat22___iadd, None, b2Mat22)
b2Mat22.__isub = new_instancemethod(_Box2D.b2Mat22___isub, None, b2Mat22)
b2Mat22_swigregister = _Box2D.b2Mat22_swigregister
b2Mat22_swigregister(b2Mat22)

class b2Mat33(object):
    """A 3-by-3 matrix. Stored in column-major order."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SetZero(self):
        """
        SetZero(b2Mat33 self)

        Set this matrix to all zeros.
        """
        return _Box2D.b2Mat33_SetZero(self)


    def Solve33(self, b):
        """
        Solve33(b2Mat33 self, b2Vec3 b) -> b2Vec3

        Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse in one-shot cases.
        """
        return _Box2D.b2Mat33_Solve33(self, b)


    def Solve22(self, b):
        """
        Solve22(b2Mat33 self, b2Vec2 b) -> b2Vec2

        Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix equation.
        """
        return _Box2D.b2Mat33_Solve22(self, b)


    def GetInverse22(self, M):
        """GetInverse22(b2Mat33 self, b2Mat33 M)"""
        return _Box2D.b2Mat33_GetInverse22(self, M)


    def GetSymInverse33(self, M):
        """GetSymInverse33(b2Mat33 self, b2Mat33 M)"""
        return _Box2D.b2Mat33_GetSymInverse33(self, M)

    col1 = _swig_property(_Box2D.b2Mat33_col1_get, _Box2D.b2Mat33_col1_set)
    col2 = _swig_property(_Box2D.b2Mat33_col2_get, _Box2D.b2Mat33_col2_set)
    col3 = _swig_property(_Box2D.b2Mat33_col3_get, _Box2D.b2Mat33_col3_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Mat33 self) -> long"""
        return _Box2D.b2Mat33___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        """
        __init__(b2Mat33 self, b2Vec3 c1, b2Vec3 c2, b2Vec3 c3) -> b2Mat33
        __init__(b2Mat33 self) -> b2Mat33

        Construct this matrix using columns.
        """
        _Box2D.b2Mat33_swiginit(self, _Box2D.new_b2Mat33(*args))

    ex = property(lambda self: self.col1, lambda self, v: setattr(self, 'col1', v))
    ey = property(lambda self: self.col2, lambda self, v: setattr(self, 'col2', v))
    ez = property(lambda self: self.col3, lambda self, v: setattr(self, 'col3', v))


    def __mul__(self, v):
        """__mul__(b2Mat33 self, b2Vec3 v) -> b2Vec3"""
        return _Box2D.b2Mat33___mul__(self, v)


    def __add__(self, other):
        """__add__(b2Mat33 self, b2Mat33 other) -> b2Mat33"""
        return _Box2D.b2Mat33___add__(self, other)


    def __sub__(self, other):
        """__sub__(b2Mat33 self, b2Mat33 other) -> b2Mat33"""
        return _Box2D.b2Mat33___sub__(self, other)


    def __iadd(self, other):
        """__iadd(b2Mat33 self, b2Mat33 other)"""
        return _Box2D.b2Mat33___iadd(self, other)


    def __isub(self, other):
        """__isub(b2Mat33 self, b2Mat33 other)"""
        return _Box2D.b2Mat33___isub(self, other)

    __swig_destroy__ = _Box2D.delete_b2Mat33
b2Mat33.SetZero = new_instancemethod(_Box2D.b2Mat33_SetZero, None, b2Mat33)
b2Mat33.Solve33 = new_instancemethod(_Box2D.b2Mat33_Solve33, None, b2Mat33)
b2Mat33.Solve22 = new_instancemethod(_Box2D.b2Mat33_Solve22, None, b2Mat33)
b2Mat33.GetInverse22 = new_instancemethod(_Box2D.b2Mat33_GetInverse22, None, b2Mat33)
b2Mat33.GetSymInverse33 = new_instancemethod(_Box2D.b2Mat33_GetSymInverse33, None, b2Mat33)
b2Mat33.__hash__ = new_instancemethod(_Box2D.b2Mat33___hash__, None, b2Mat33)
b2Mat33.__mul__ = new_instancemethod(_Box2D.b2Mat33___mul__, None, b2Mat33)
b2Mat33.__add__ = new_instancemethod(_Box2D.b2Mat33___add__, None, b2Mat33)
b2Mat33.__sub__ = new_instancemethod(_Box2D.b2Mat33___sub__, None, b2Mat33)
b2Mat33.__iadd = new_instancemethod(_Box2D.b2Mat33___iadd, None, b2Mat33)
b2Mat33.__isub = new_instancemethod(_Box2D.b2Mat33___isub, None, b2Mat33)
b2Mat33_swigregister = _Box2D.b2Mat33_swigregister
b2Mat33_swigregister(b2Mat33)

class b2Rot(object):
    """Proxy of C++ b2Rot class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(b2Rot self) -> b2Rot
        __init__(b2Rot self, float32 angle) -> b2Rot
        """
        _Box2D.b2Rot_swiginit(self, _Box2D.new_b2Rot(*args))

    def __SetAngle(self, angle):
        """__SetAngle(b2Rot self, float32 angle)"""
        return _Box2D.b2Rot___SetAngle(self, angle)


    def SetIdentity(self):
        """SetIdentity(b2Rot self)"""
        return _Box2D.b2Rot_SetIdentity(self)


    def __GetAngle(self):
        """__GetAngle(b2Rot self) -> float32"""
        return _Box2D.b2Rot___GetAngle(self)


    def GetXAxis(self):
        """GetXAxis(b2Rot self) -> b2Vec2"""
        return _Box2D.b2Rot_GetXAxis(self)


    def GetYAxis(self):
        """GetYAxis(b2Rot self) -> b2Vec2"""
        return _Box2D.b2Rot_GetYAxis(self)

    s = _swig_property(_Box2D.b2Rot_s_get, _Box2D.b2Rot_s_set)
    c = _swig_property(_Box2D.b2Rot_c_get, _Box2D.b2Rot_c_set)

    angle = property(__GetAngle, __SetAngle) 

    x_axis = property(GetXAxis, None)
    y_axis = property(GetYAxis, None)



    def __mul__(self, v):
        """__mul__(b2Rot self, b2Vec2 v) -> b2Vec2"""
        return _Box2D.b2Rot___mul__(self, v)

    __swig_destroy__ = _Box2D.delete_b2Rot
b2Rot.__SetAngle = new_instancemethod(_Box2D.b2Rot___SetAngle, None, b2Rot)
b2Rot.SetIdentity = new_instancemethod(_Box2D.b2Rot_SetIdentity, None, b2Rot)
b2Rot.__GetAngle = new_instancemethod(_Box2D.b2Rot___GetAngle, None, b2Rot)
b2Rot.GetXAxis = new_instancemethod(_Box2D.b2Rot_GetXAxis, None, b2Rot)
b2Rot.GetYAxis = new_instancemethod(_Box2D.b2Rot_GetYAxis, None, b2Rot)
b2Rot.__mul__ = new_instancemethod(_Box2D.b2Rot___mul__, None, b2Rot)
b2Rot_swigregister = _Box2D.b2Rot_swigregister
b2Rot_swigregister(b2Rot)

class b2Transform(object):
    """A transform contains translation and rotation. It is used to represent the position and orientation of rigid frames."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(b2Transform self) -> b2Transform
        __init__(b2Transform self, b2Vec2 position, b2Rot rotation) -> b2Transform

        Initialize using a position vector and a rotation matrix.
        """
        _Box2D.b2Transform_swiginit(self, _Box2D.new_b2Transform(*args))

    def SetIdentity(self):
        """
        SetIdentity(b2Transform self)

        Set this to the identity transform.
        """
        return _Box2D.b2Transform_SetIdentity(self)


    def Set(self, position, angle):
        """
        Set(b2Transform self, b2Vec2 position, float32 angle)

        Set this based on the position and angle.
        """
        return _Box2D.b2Transform_Set(self, position, angle)

    position = _swig_property(_Box2D.b2Transform_position_get, _Box2D.b2Transform_position_set)
    q = _swig_property(_Box2D.b2Transform_q_get, _Box2D.b2Transform_q_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Transform self) -> long"""
        return _Box2D.b2Transform___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __get_rotation_matrix(self):
        """__get_rotation_matrix(b2Transform self) -> b2Rot"""
        return _Box2D.b2Transform___get_rotation_matrix(self)


    def __get_angle(self):
        return self.q.angle
    def __set_angle(self, angle):
        self.q.angle = angle

    def __set_rotation_matrix(self, rot_matrix):
        self.q.angle = rot_matrix.angle

    angle = property(__get_angle, __set_angle) 
    R = property(__get_rotation_matrix, __set_rotation_matrix)


    def __mul__(self, v):
        """__mul__(b2Transform self, b2Vec2 v) -> b2Vec2"""
        return _Box2D.b2Transform___mul__(self, v)

    __swig_destroy__ = _Box2D.delete_b2Transform
b2Transform.SetIdentity = new_instancemethod(_Box2D.b2Transform_SetIdentity, None, b2Transform)
b2Transform.Set = new_instancemethod(_Box2D.b2Transform_Set, None, b2Transform)
b2Transform.__hash__ = new_instancemethod(_Box2D.b2Transform___hash__, None, b2Transform)
b2Transform.__get_rotation_matrix = new_instancemethod(_Box2D.b2Transform___get_rotation_matrix, None, b2Transform)
b2Transform.__mul__ = new_instancemethod(_Box2D.b2Transform___mul__, None, b2Transform)
b2Transform_swigregister = _Box2D.b2Transform_swigregister
b2Transform_swigregister(b2Transform)

class b2Sweep(object):
    """This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body origin, which may no coincide with the center of mass. However, to support dynamics we must interpolate the center of mass position."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Advance(self, alpha):
        """
        Advance(b2Sweep self, float32 alpha)

        Advance the sweep forward, yielding a new initial state.

        Parameters:
        -----------

        alpha: 
        the new initial time.
        """
        return _Box2D.b2Sweep_Advance(self, alpha)


    def Normalize(self):
        """
        Normalize(b2Sweep self)

        Normalize the angles.
        """
        return _Box2D.b2Sweep_Normalize(self)

    localCenter = _swig_property(_Box2D.b2Sweep_localCenter_get, _Box2D.b2Sweep_localCenter_set)
    c0 = _swig_property(_Box2D.b2Sweep_c0_get, _Box2D.b2Sweep_c0_set)
    c = _swig_property(_Box2D.b2Sweep_c_get, _Box2D.b2Sweep_c_set)
    a0 = _swig_property(_Box2D.b2Sweep_a0_get, _Box2D.b2Sweep_a0_set)
    a = _swig_property(_Box2D.b2Sweep_a_get, _Box2D.b2Sweep_a_set)
    alpha0 = _swig_property(_Box2D.b2Sweep_alpha0_get, _Box2D.b2Sweep_alpha0_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Sweep self) -> long"""
        return _Box2D.b2Sweep___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def GetTransform(self, *args):
        """
        GetTransform(b2Sweep self, b2Transform xfb, float32 beta)
        GetTransform(b2Sweep self, float32 alpha) -> b2Transform

        Get the interpolated transform at a specific time.

        Parameters:
        -----------

        beta: 
        is a factor in [0,1], where 0 indicates alpha0.
        """
        return _Box2D.b2Sweep_GetTransform(self, *args)


    def __init__(self, **kwargs):
        _Box2D.b2Sweep_swiginit(self,_Box2D.new_b2Sweep())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Sweep
b2Sweep.Advance = new_instancemethod(_Box2D.b2Sweep_Advance, None, b2Sweep)
b2Sweep.Normalize = new_instancemethod(_Box2D.b2Sweep_Normalize, None, b2Sweep)
b2Sweep.__hash__ = new_instancemethod(_Box2D.b2Sweep___hash__, None, b2Sweep)
b2Sweep.GetTransform = new_instancemethod(_Box2D.b2Sweep_GetTransform, None, b2Sweep)
b2Sweep_swigregister = _Box2D.b2Sweep_swigregister
b2Sweep_swigregister(b2Sweep)


def b2DistanceSquared(a, b):
    """b2DistanceSquared(b2Vec2 a, b2Vec2 b) -> float32"""
    return _Box2D.b2DistanceSquared(a, b)

def b2Dot(*args):
    """
    b2Dot(b2Vec2 a, b2Vec2 b) -> float32
    b2Dot(b2Vec3 a, b2Vec3 b) -> float32

    Perform the dot product on two vectors.
    """
    return _Box2D.b2Dot(*args)

def b2Cross(*args):
    """
    b2Cross(b2Vec2 a, b2Vec2 b) -> float32
    b2Cross(b2Vec2 a, float32 s) -> b2Vec2
    b2Cross(float32 s, b2Vec2 a) -> b2Vec2
    b2Cross(b2Vec3 a, b2Vec3 b) -> b2Vec3

    Perform the cross product on two vectors.
    """
    return _Box2D.b2Cross(*args)

def b2Mul22(A, v):
    """b2Mul22(b2Mat33 A, b2Vec2 v) -> b2Vec2"""
    return _Box2D.b2Mul22(A, v)

def b2Mul(*args):
    """
    b2Mul(b2Mat22 A, b2Vec2 v) -> b2Vec2
    b2Mul(b2Mat22 A, b2Mat22 B) -> b2Mat22
    b2Mul(b2Mat33 A, b2Vec3 v) -> b2Vec3
    b2Mul(b2Rot q, b2Rot r) -> b2Rot
    b2Mul(b2Rot q, b2Vec2 v) -> b2Vec2
    b2Mul(b2Transform T, b2Vec2 v) -> b2Vec2
    b2Mul(b2Transform A, b2Transform B) -> b2Transform

    Multiply a matrix times a vector.
    """
    return _Box2D.b2Mul(*args)

def b2MulT(*args):
    """
    b2MulT(b2Mat22 A, b2Vec2 v) -> b2Vec2
    b2MulT(b2Mat22 A, b2Mat22 B) -> b2Mat22
    b2MulT(b2Rot q, b2Rot r) -> b2Rot
    b2MulT(b2Rot q, b2Vec2 v) -> b2Vec2
    b2MulT(b2Transform T, b2Vec2 v) -> b2Vec2
    b2MulT(b2Transform A, b2Transform B) -> b2Transform

    Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform).
    """
    return _Box2D.b2MulT(*args)

def b2Abs(*args):
    """
    b2Abs(b2Vec2 a) -> b2Vec2
    b2Abs(b2Mat22 A) -> b2Mat22
    """
    return _Box2D.b2Abs(*args)

def b2Min(a, b):
    """b2Min(b2Vec2 a, b2Vec2 b) -> b2Vec2"""
    return _Box2D.b2Min(a, b)

def b2Max(a, b):
    """b2Max(b2Vec2 a, b2Vec2 b) -> b2Vec2"""
    return _Box2D.b2Max(a, b)

def b2Clamp(a, low, high):
    """b2Clamp(b2Vec2 a, b2Vec2 low, b2Vec2 high) -> b2Vec2"""
    return _Box2D.b2Clamp(a, low, high)

def b2NextPowerOfTwo(x):
    """
    b2NextPowerOfTwo(uint32 x) -> uint32

    "Next Largest Power of 2 Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next largest power of 2. For a 32-bit value:"
    """
    return _Box2D.b2NextPowerOfTwo(x)

def b2IsPowerOfTwo(x):
    """b2IsPowerOfTwo(uint32 x) -> bool"""
    return _Box2D.b2IsPowerOfTwo(x)
class b2ContactFeature(object):
    """The features that intersect to form the contact point This must be 4 bytes or less."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_vertex = _Box2D.b2ContactFeature_e_vertex
    e_face = _Box2D.b2ContactFeature_e_face
    indexA = _swig_property(_Box2D.b2ContactFeature_indexA_get, _Box2D.b2ContactFeature_indexA_set)
    indexB = _swig_property(_Box2D.b2ContactFeature_indexB_get, _Box2D.b2ContactFeature_indexB_set)
    typeA = _swig_property(_Box2D.b2ContactFeature_typeA_get, _Box2D.b2ContactFeature_typeA_set)
    typeB = _swig_property(_Box2D.b2ContactFeature_typeB_get, _Box2D.b2ContactFeature_typeB_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactFeature self) -> long"""
        return _Box2D.b2ContactFeature___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        """
        __init__(b2ContactFeature self) -> b2ContactFeature

        The features that intersect to form the contact point This must be 4 bytes or less.
        """
        _Box2D.b2ContactFeature_swiginit(self, _Box2D.new_b2ContactFeature())
    __swig_destroy__ = _Box2D.delete_b2ContactFeature
b2ContactFeature.__hash__ = new_instancemethod(_Box2D.b2ContactFeature___hash__, None, b2ContactFeature)
b2ContactFeature_swigregister = _Box2D.b2ContactFeature_swigregister
b2ContactFeature_swigregister(b2ContactFeature)
b2Vec2_zero = b2Globals.b2Vec2_zero
b2_nullFeature = b2Globals.b2_nullFeature

class b2ContactID(object):
    """Proxy of C++ b2ContactID class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cf = _swig_property(_Box2D.b2ContactID_cf_get, _Box2D.b2ContactID_cf_set)
    key = _swig_property(_Box2D.b2ContactID_key_get, _Box2D.b2ContactID_key_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactID self) -> long"""
        return _Box2D.b2ContactID___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ContactID_swiginit(self,_Box2D.new_b2ContactID())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactID
b2ContactID.__hash__ = new_instancemethod(_Box2D.b2ContactID___hash__, None, b2ContactID)
b2ContactID_swigregister = _Box2D.b2ContactID_swigregister
b2ContactID_swigregister(b2ContactID)

class b2ManifoldPoint(object):
    """A manifold point is a contact point belonging to a contact manifold. It holds details related to the geometry and dynamics of the contact points. The local point usage depends on the manifold type: -e_circles: the local center of circleB -e_faceA: the local center of cirlceB or the clip point of polygonB -e_faceB: the clip point of polygonA This structure is stored across time steps, so we keep it small. Note: the impulses are used for internal caching and may not provide reliable contact forces, especially for high speed collisions."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    localPoint = _swig_property(_Box2D.b2ManifoldPoint_localPoint_get, _Box2D.b2ManifoldPoint_localPoint_set)
    normalImpulse = _swig_property(_Box2D.b2ManifoldPoint_normalImpulse_get, _Box2D.b2ManifoldPoint_normalImpulse_set)
    tangentImpulse = _swig_property(_Box2D.b2ManifoldPoint_tangentImpulse_get, _Box2D.b2ManifoldPoint_tangentImpulse_set)
    id = _swig_property(_Box2D.b2ManifoldPoint_id_get, _Box2D.b2ManifoldPoint_id_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ManifoldPoint self) -> long"""
        return _Box2D.b2ManifoldPoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ManifoldPoint_swiginit(self,_Box2D.new_b2ManifoldPoint())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ManifoldPoint
b2ManifoldPoint.__hash__ = new_instancemethod(_Box2D.b2ManifoldPoint___hash__, None, b2ManifoldPoint)
b2ManifoldPoint_swigregister = _Box2D.b2ManifoldPoint_swigregister
b2ManifoldPoint_swigregister(b2ManifoldPoint)

class b2Manifold(object):
    """
    A manifold for two touching convex shapes. Box2D supports multiple types of contact:
    clip point versus plane with radius
    point versus point with radius (circles) The local point usage depends on the manifold type: -e_circles: the local center of circleA -e_faceA: the center of faceA -e_faceB: the center of faceB Similarly the local normal usage: -e_circles: not used -e_faceA: the normal on polygonA -e_faceB: the normal on polygonB We store contacts in this way so that position correction can account for movement, which is critical for continuous physics. All contact scenarios must be expressed in one of these types. This structure is stored across time steps, so we keep it small.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_circles = _Box2D.b2Manifold_e_circles
    e_faceA = _Box2D.b2Manifold_e_faceA
    e_faceB = _Box2D.b2Manifold_e_faceB
    localNormal = _swig_property(_Box2D.b2Manifold_localNormal_get, _Box2D.b2Manifold_localNormal_set)
    localPoint = _swig_property(_Box2D.b2Manifold_localPoint_get, _Box2D.b2Manifold_localPoint_set)
    type_ = _swig_property(_Box2D.b2Manifold_type__get, _Box2D.b2Manifold_type__set)
    pointCount = _swig_property(_Box2D.b2Manifold_pointCount_get, _Box2D.b2Manifold_pointCount_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Manifold self) -> long"""
        return _Box2D.b2Manifold___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __GetPoints(self):
        return [self.__GetPoint(i) for i in range(self.pointCount)]
    points = property(__GetPoints, None)


    def __GetPoint(self, i):
        """__GetPoint(b2Manifold self, int i) -> b2ManifoldPoint"""
        return _Box2D.b2Manifold___GetPoint(self, i)


    def __init__(self, **kwargs):
        _Box2D.b2Manifold_swiginit(self,_Box2D.new_b2Manifold())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Manifold
b2Manifold.__hash__ = new_instancemethod(_Box2D.b2Manifold___hash__, None, b2Manifold)
b2Manifold.__GetPoint = new_instancemethod(_Box2D.b2Manifold___GetPoint, None, b2Manifold)
b2Manifold_swigregister = _Box2D.b2Manifold_swigregister
b2Manifold_swigregister(b2Manifold)

class b2WorldManifold(object):
    """This is used to compute the current state of a contact manifold."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Initialize(self, manifold, xfA, radiusA, xfB, radiusB):
        """
        Initialize(b2WorldManifold self, b2Manifold manifold, b2Transform xfA, float32 radiusA, b2Transform xfB, float32 radiusB)

        Evaluate the manifold with supplied transforms. This assumes modest motion from the original state. This does not change the point count, impulses, etc. The radii must come from the shapes that generated the manifold.
        """
        return _Box2D.b2WorldManifold_Initialize(self, manifold, xfA, radiusA, xfB, radiusB)

    normal = _swig_property(_Box2D.b2WorldManifold_normal_get, _Box2D.b2WorldManifold_normal_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2WorldManifold self) -> long"""
        return _Box2D.b2WorldManifold___hash__(self)


    def __repr__(self):
        return _format_repr(self) 




    def __get_points(self):
        """__get_points(b2WorldManifold self) -> PyObject *"""
        return _Box2D.b2WorldManifold___get_points(self)


    points = property(__get_points, None)


    def __init__(self, **kwargs):
        _Box2D.b2WorldManifold_swiginit(self,_Box2D.new_b2WorldManifold())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2WorldManifold
b2WorldManifold.Initialize = new_instancemethod(_Box2D.b2WorldManifold_Initialize, None, b2WorldManifold)
b2WorldManifold.__hash__ = new_instancemethod(_Box2D.b2WorldManifold___hash__, None, b2WorldManifold)
b2WorldManifold.__get_points = new_instancemethod(_Box2D.b2WorldManifold___get_points, None, b2WorldManifold)
b2WorldManifold_swigregister = _Box2D.b2WorldManifold_swigregister
b2WorldManifold_swigregister(b2WorldManifold)

b2_nullState = _Box2D.b2_nullState
b2_addState = _Box2D.b2_addState
b2_persistState = _Box2D.b2_persistState
b2_removeState = _Box2D.b2_removeState
class b2ClipVertex(object):
    """Used for computing contact manifolds."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    v = _swig_property(_Box2D.b2ClipVertex_v_get, _Box2D.b2ClipVertex_v_set)
    id = _swig_property(_Box2D.b2ClipVertex_id_get, _Box2D.b2ClipVertex_id_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ClipVertex self) -> long"""
        return _Box2D.b2ClipVertex___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ClipVertex_swiginit(self,_Box2D.new_b2ClipVertex())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ClipVertex
b2ClipVertex.__hash__ = new_instancemethod(_Box2D.b2ClipVertex___hash__, None, b2ClipVertex)
b2ClipVertex_swigregister = _Box2D.b2ClipVertex_swigregister
b2ClipVertex_swigregister(b2ClipVertex)

class b2RayCastInput(object):
    """Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    p1 = _swig_property(_Box2D.b2RayCastInput_p1_get, _Box2D.b2RayCastInput_p1_set)
    p2 = _swig_property(_Box2D.b2RayCastInput_p2_get, _Box2D.b2RayCastInput_p2_set)
    maxFraction = _swig_property(_Box2D.b2RayCastInput_maxFraction_get, _Box2D.b2RayCastInput_maxFraction_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2RayCastInput self) -> long"""
        return _Box2D.b2RayCastInput___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2RayCastInput_swiginit(self,_Box2D.new_b2RayCastInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2RayCastInput
b2RayCastInput.__hash__ = new_instancemethod(_Box2D.b2RayCastInput___hash__, None, b2RayCastInput)
b2RayCastInput_swigregister = _Box2D.b2RayCastInput_swigregister
b2RayCastInput_swigregister(b2RayCastInput)

class b2RayCastOutput(object):
    """Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from  b2RayCastInput."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    normal = _swig_property(_Box2D.b2RayCastOutput_normal_get, _Box2D.b2RayCastOutput_normal_set)
    fraction = _swig_property(_Box2D.b2RayCastOutput_fraction_get, _Box2D.b2RayCastOutput_fraction_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2RayCastOutput self) -> long"""
        return _Box2D.b2RayCastOutput___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2RayCastOutput_swiginit(self,_Box2D.new_b2RayCastOutput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2RayCastOutput
b2RayCastOutput.__hash__ = new_instancemethod(_Box2D.b2RayCastOutput___hash__, None, b2RayCastOutput)
b2RayCastOutput_swigregister = _Box2D.b2RayCastOutput_swigregister
b2RayCastOutput_swigregister(b2RayCastOutput)

class b2AABB(object):
    """An axis aligned bounding box."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __IsValid(self):
        """
        __IsValid(b2AABB self) -> bool

        Verify that the bounds are sorted.
        """
        return _Box2D.b2AABB___IsValid(self)


    def __GetCenter(self):
        """
        __GetCenter(b2AABB self) -> b2Vec2

        Get the center of the AABB.
        """
        return _Box2D.b2AABB___GetCenter(self)


    def __GetExtents(self):
        """
        __GetExtents(b2AABB self) -> b2Vec2

        Get the extents of the AABB (half-widths).
        """
        return _Box2D.b2AABB___GetExtents(self)


    def __GetPerimeter(self):
        """
        __GetPerimeter(b2AABB self) -> float32

        Get the perimeter length.
        """
        return _Box2D.b2AABB___GetPerimeter(self)


    def Combine(self, *args):
        """
        Combine(b2AABB self, b2AABB aabb)
        Combine(b2AABB self, b2AABB aabb1, b2AABB aabb2)

        Combine two AABBs into this one.
        """
        return _Box2D.b2AABB_Combine(self, *args)


    def RayCast(self, output, input):
        """RayCast(b2AABB self, b2RayCastOutput output, b2RayCastInput input) -> bool"""
        return _Box2D.b2AABB_RayCast(self, output, input)

    lowerBound = _swig_property(_Box2D.b2AABB_lowerBound_get, _Box2D.b2AABB_lowerBound_set)
    upperBound = _swig_property(_Box2D.b2AABB_upperBound_get, _Box2D.b2AABB_upperBound_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2AABB self) -> long"""
        return _Box2D.b2AABB___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


            # Read-only
    valid = property(__IsValid, None)
    extents = property(__GetExtents, None)
    center = property(__GetCenter, None)
    perimeter = property(__GetPerimeter, None)



    def __contains__(self, *args):
        """
        __contains__(b2AABB self, b2AABB aabb) -> bool
        __contains__(b2AABB self, b2Vec2 point) -> bool
        """
        return _Box2D.b2AABB___contains__(self, *args)


    def overlaps(self, aabb2):
        """overlaps(b2AABB self, b2AABB aabb2) -> bool"""
        return _Box2D.b2AABB_overlaps(self, aabb2)


    def __init__(self, **kwargs):
        _Box2D.b2AABB_swiginit(self,_Box2D.new_b2AABB())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2AABB
b2AABB.__IsValid = new_instancemethod(_Box2D.b2AABB___IsValid, None, b2AABB)
b2AABB.__GetCenter = new_instancemethod(_Box2D.b2AABB___GetCenter, None, b2AABB)
b2AABB.__GetExtents = new_instancemethod(_Box2D.b2AABB___GetExtents, None, b2AABB)
b2AABB.__GetPerimeter = new_instancemethod(_Box2D.b2AABB___GetPerimeter, None, b2AABB)
b2AABB.Combine = new_instancemethod(_Box2D.b2AABB_Combine, None, b2AABB)
b2AABB.RayCast = new_instancemethod(_Box2D.b2AABB_RayCast, None, b2AABB)
b2AABB.__hash__ = new_instancemethod(_Box2D.b2AABB___hash__, None, b2AABB)
b2AABB.__contains__ = new_instancemethod(_Box2D.b2AABB___contains__, None, b2AABB)
b2AABB.overlaps = new_instancemethod(_Box2D.b2AABB_overlaps, None, b2AABB)
b2AABB_swigregister = _Box2D.b2AABB_swigregister
b2AABB_swigregister(b2AABB)


def b2CollideCircles(manifold, circleA, xfA, circleB, xfB):
    """
    b2CollideCircles(b2Manifold manifold, b2CircleShape circleA, b2Transform xfA, b2CircleShape circleB, b2Transform xfB)

    Compute the collision manifold between two circles.
    """
    return _Box2D.b2CollideCircles(manifold, circleA, xfA, circleB, xfB)

def b2CollidePolygonAndCircle(manifold, polygonA, xfA, circleB, xfB):
    """
    b2CollidePolygonAndCircle(b2Manifold manifold, b2PolygonShape polygonA, b2Transform xfA, b2CircleShape circleB, b2Transform xfB)

    Compute the collision manifold between a polygon and a circle.
    """
    return _Box2D.b2CollidePolygonAndCircle(manifold, polygonA, xfA, circleB, xfB)

def b2CollidePolygons(manifold, polygonA, xfA, polygonB, xfB):
    """
    b2CollidePolygons(b2Manifold manifold, b2PolygonShape polygonA, b2Transform xfA, b2PolygonShape polygonB, b2Transform xfB)

    Compute the collision manifold between two polygons.
    """
    return _Box2D.b2CollidePolygons(manifold, polygonA, xfA, polygonB, xfB)

def b2CollideEdgeAndCircle(manifold, polygonA, xfA, circleB, xfB):
    """
    b2CollideEdgeAndCircle(b2Manifold manifold, b2EdgeShape polygonA, b2Transform xfA, b2CircleShape circleB, b2Transform xfB)

    Compute the collision manifold between an edge and a circle.
    """
    return _Box2D.b2CollideEdgeAndCircle(manifold, polygonA, xfA, circleB, xfB)

def b2CollideEdgeAndPolygon(manifold, edgeA, xfA, circleB, xfB):
    """
    b2CollideEdgeAndPolygon(b2Manifold manifold, b2EdgeShape edgeA, b2Transform xfA, b2PolygonShape circleB, b2Transform xfB)

    Compute the collision manifold between an edge and a circle.
    """
    return _Box2D.b2CollideEdgeAndPolygon(manifold, edgeA, xfA, circleB, xfB)

def b2ClipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA):
    """
    b2ClipSegmentToLine(b2ClipVertex vOut, b2ClipVertex vIn, b2Vec2 normal, float32 offset, int32 vertexIndexA) -> int32

    Clipping for contact manifolds.
    """
    return _Box2D.b2ClipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA)

def b2TestOverlap(*args):
    """
    b2TestOverlap(b2Shape shapeA, int32 indexA, b2Shape shapeB, int32 indexB, b2Transform xfA, b2Transform xfB) -> bool
    b2TestOverlap(b2AABB a, b2AABB b) -> bool

    Determine if two generic shapes overlap.
    """
    return _Box2D.b2TestOverlap(*args)
class _b2Vec2Array(object):
    """Proxy of C++ _b2Vec2Array class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """__init__(_b2Vec2Array self, size_t nelements) -> _b2Vec2Array"""
        _Box2D._b2Vec2Array_swiginit(self, _Box2D.new__b2Vec2Array(nelements))
    __swig_destroy__ = _Box2D.delete__b2Vec2Array

    def __getitem__(self, index):
        """__getitem__(_b2Vec2Array self, size_t index) -> b2Vec2"""
        return _Box2D._b2Vec2Array___getitem__(self, index)


    def __setitem__(self, index, value):
        """__setitem__(_b2Vec2Array self, size_t index, b2Vec2 value)"""
        return _Box2D._b2Vec2Array___setitem__(self, index, value)


    def cast(self):
        """cast(_b2Vec2Array self) -> b2Vec2"""
        return _Box2D._b2Vec2Array_cast(self)


    def frompointer(t):
        """frompointer(b2Vec2 t) -> _b2Vec2Array"""
        return _Box2D._b2Vec2Array_frompointer(t)

    frompointer = staticmethod(frompointer)
_b2Vec2Array.__getitem__ = new_instancemethod(_Box2D._b2Vec2Array___getitem__, None, _b2Vec2Array)
_b2Vec2Array.__setitem__ = new_instancemethod(_Box2D._b2Vec2Array___setitem__, None, _b2Vec2Array)
_b2Vec2Array.cast = new_instancemethod(_Box2D._b2Vec2Array_cast, None, _b2Vec2Array)
_b2Vec2Array_swigregister = _Box2D._b2Vec2Array_swigregister
_b2Vec2Array_swigregister(_b2Vec2Array)

def _b2Vec2Array_frompointer(t):
    """_b2Vec2Array_frompointer(b2Vec2 t) -> _b2Vec2Array"""
    return _Box2D._b2Vec2Array_frompointer(t)

e_convertVertices = _Box2D.e_convertVertices
class b2Color(object):
    """Color for debug drawing. Each value has the range [0,1]."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Set(self, ri, gi, bi):
        """Set(b2Color self, float32 ri, float32 gi, float32 bi)"""
        return _Box2D.b2Color_Set(self, ri, gi, bi)

    r = _swig_property(_Box2D.b2Color_r_get, _Box2D.b2Color_r_set)
    g = _swig_property(_Box2D.b2Color_g_get, _Box2D.b2Color_g_set)
    b = _swig_property(_Box2D.b2Color_b_get, _Box2D.b2Color_b_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Color self) -> long"""
        return _Box2D.b2Color___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, *args):
        """
        __init__(b2Color self) -> b2Color
        __init__(b2Color self, float32 r, float32 g, float32 b) -> b2Color
        __init__(b2Color self, b2Color other) -> b2Color

        Color for debug drawing. Each value has the range [0,1].
        """
        _Box2D.b2Color_swiginit(self, _Box2D.new_b2Color(*args))

    def __get_bytes(self):
        """__get_bytes(b2Color self) -> PyObject *"""
        return _Box2D.b2Color___get_bytes(self)


    __iter__ = lambda self: iter((self.r, self.g, self.b)) 
    __eq__ = lambda self, other: self.__equ(other)
    __ne__ = lambda self,other: not self.__equ(other)
    def __repr__(self):
        return "b2Color(%g,%g,%g)" % (self.r, self.g, self.b)
    def __len__(self):
        return 3
    def __copy__(self):
        return b2Color(self.r, self.g, self.b)
    def copy(self):
        return b2Color(self.r, self.g, self.b)
    def __set_bytes(self, value):
        if len(value) != 3:
            raise ValueError('Expected length 3 list')
        self.r, self.g, self.b = value[0]/255, value[1]/255, value[2]/255
    def __set_tuple(self, value):
        if len(value) != 3:
            raise ValueError('Expected length 3 list')
        self.r, self.g, self.b = value[0], value[1], value[2]
    def __nonzero__(self):
        return self.r!=0.0 or self.g!=0.0 or self.b!=0.0

    list  = property(lambda self: list(self), __set_tuple)
    bytes = property(__get_bytes, __set_bytes)


    def __getitem__(self, i):
        """__getitem__(b2Color self, int i) -> float32"""
        return _Box2D.b2Color___getitem__(self, i)


    def __setitem__(self, i, value):
        """__setitem__(b2Color self, int i, float32 value)"""
        return _Box2D.b2Color___setitem__(self, i, value)


    def __truediv__(self, a):
        """__truediv__(b2Color self, float32 a) -> b2Color"""
        return _Box2D.b2Color___truediv__(self, a)


    def __add__(self, o):
        """__add__(b2Color self, b2Color o) -> b2Color"""
        return _Box2D.b2Color___add__(self, o)


    def __sub__(self, o):
        """__sub__(b2Color self, b2Color o) -> b2Color"""
        return _Box2D.b2Color___sub__(self, o)


    def __div__(self, a):
        """__div__(b2Color self, float32 a) -> b2Color"""
        return _Box2D.b2Color___div__(self, a)


    def __rmul__(self, a):
        """__rmul__(b2Color self, float32 a) -> b2Color"""
        return _Box2D.b2Color___rmul__(self, a)


    def __mul__(self, a):
        """__mul__(b2Color self, float32 a) -> b2Color"""
        return _Box2D.b2Color___mul__(self, a)


    def __isub(self, o):
        """__isub(b2Color self, b2Color o)"""
        return _Box2D.b2Color___isub(self, o)


    def __itruediv(self, o):
        """__itruediv(b2Color self, b2Color o)"""
        return _Box2D.b2Color___itruediv(self, o)


    def __idiv(self, o):
        """__idiv(b2Color self, b2Color o)"""
        return _Box2D.b2Color___idiv(self, o)


    def __imul(self, o):
        """__imul(b2Color self, b2Color o)"""
        return _Box2D.b2Color___imul(self, o)


    def __iadd(self, o):
        """__iadd(b2Color self, b2Color o)"""
        return _Box2D.b2Color___iadd(self, o)


    def __equ(self, b):
        """__equ(b2Color self, b2Color b) -> bool"""
        return _Box2D.b2Color___equ(self, b)

    __swig_destroy__ = _Box2D.delete_b2Color
b2Color.Set = new_instancemethod(_Box2D.b2Color_Set, None, b2Color)
b2Color.__hash__ = new_instancemethod(_Box2D.b2Color___hash__, None, b2Color)
b2Color.__get_bytes = new_instancemethod(_Box2D.b2Color___get_bytes, None, b2Color)
b2Color.__getitem__ = new_instancemethod(_Box2D.b2Color___getitem__, None, b2Color)
b2Color.__setitem__ = new_instancemethod(_Box2D.b2Color___setitem__, None, b2Color)
b2Color.__truediv__ = new_instancemethod(_Box2D.b2Color___truediv__, None, b2Color)
b2Color.__add__ = new_instancemethod(_Box2D.b2Color___add__, None, b2Color)
b2Color.__sub__ = new_instancemethod(_Box2D.b2Color___sub__, None, b2Color)
b2Color.__div__ = new_instancemethod(_Box2D.b2Color___div__, None, b2Color)
b2Color.__rmul__ = new_instancemethod(_Box2D.b2Color___rmul__, None, b2Color)
b2Color.__mul__ = new_instancemethod(_Box2D.b2Color___mul__, None, b2Color)
b2Color.__isub = new_instancemethod(_Box2D.b2Color___isub, None, b2Color)
b2Color.__itruediv = new_instancemethod(_Box2D.b2Color___itruediv, None, b2Color)
b2Color.__idiv = new_instancemethod(_Box2D.b2Color___idiv, None, b2Color)
b2Color.__imul = new_instancemethod(_Box2D.b2Color___imul, None, b2Color)
b2Color.__iadd = new_instancemethod(_Box2D.b2Color___iadd, None, b2Color)
b2Color.__equ = new_instancemethod(_Box2D.b2Color___equ, None, b2Color)
b2Color_swigregister = _Box2D.b2Color_swigregister
b2Color_swigregister(b2Color)

class b2Draw(object):
    """Implement and register this class with a  b2Worldto provide debug drawing of physics entities in your game."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        if self.__class__ == b2Draw:
            _self = None
        else:
            _self = self
        _Box2D.b2Draw_swiginit(self,_Box2D.new_b2Draw(_self, ))
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Draw
    e_shapeBit = _Box2D.b2Draw_e_shapeBit
    e_jointBit = _Box2D.b2Draw_e_jointBit
    e_aabbBit = _Box2D.b2Draw_e_aabbBit
    e_pairBit = _Box2D.b2Draw_e_pairBit
    e_centerOfMassBit = _Box2D.b2Draw_e_centerOfMassBit

    def __SetFlags(self, flags):
        """
        __SetFlags(b2Draw self, uint32 flags)

        Set the drawing flags.
        """
        return _Box2D.b2Draw___SetFlags(self, flags)


    def __GetFlags(self):
        """
        __GetFlags(b2Draw self) -> uint32

        Get the drawing flags.
        """
        return _Box2D.b2Draw___GetFlags(self)


    def AppendFlags(self, flags):
        """
        AppendFlags(b2Draw self, uint32 flags)

        Append flags to the current flags.
        """
        return _Box2D.b2Draw_AppendFlags(self, flags)


    def ClearFlags(self, flags):
        """
        ClearFlags(b2Draw self, uint32 flags)

        Clear flags from the current flags.
        """
        return _Box2D.b2Draw_ClearFlags(self, flags)


    def DrawPolygon(self, vertices, vertexCount, color):
        """
        DrawPolygon(b2Draw self, b2Vec2 vertices, int32 vertexCount, b2Color color)

        Draw a closed polygon provided in CCW order.
        """
        return _Box2D.b2Draw_DrawPolygon(self, vertices, vertexCount, color)


    def DrawSolidPolygon(self, vertices, vertexCount, color):
        """
        DrawSolidPolygon(b2Draw self, b2Vec2 vertices, int32 vertexCount, b2Color color)

        Draw a solid closed polygon provided in CCW order.
        """
        return _Box2D.b2Draw_DrawSolidPolygon(self, vertices, vertexCount, color)


    def DrawCircle(self, center, radius, color):
        """
        DrawCircle(b2Draw self, b2Vec2 center, float32 radius, b2Color color)

        Draw a circle.
        """
        return _Box2D.b2Draw_DrawCircle(self, center, radius, color)


    def DrawSolidCircle(self, center, radius, axis, color):
        """
        DrawSolidCircle(b2Draw self, b2Vec2 center, float32 radius, b2Vec2 axis, b2Color color)

        Draw a solid circle.
        """
        return _Box2D.b2Draw_DrawSolidCircle(self, center, radius, axis, color)


    def DrawSegment(self, p1, p2, color):
        """
        DrawSegment(b2Draw self, b2Vec2 p1, b2Vec2 p2, b2Color color)

        Draw a line segment.
        """
        return _Box2D.b2Draw_DrawSegment(self, p1, p2, color)


    def DrawTransform(self, xf):
        """
        DrawTransform(b2Draw self, b2Transform xf)

        Draw a transform. Choose your own length scale.

        Parameters:
        -----------

        xf: 
        a transform.
        """
        return _Box2D.b2Draw_DrawTransform(self, xf)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Draw self) -> long"""
        return _Box2D.b2Draw___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    _flag_entries = [
        ['drawShapes', e_shapeBit],
        ['drawJoints', e_jointBit ],
        ['drawAABBs', e_aabbBit ],
        ['drawPairs', e_pairBit ],
        ['drawCOMs', e_centerOfMassBit ],
        ['convertVertices', e_convertVertices ],
    ]
    def _SetFlags(self, value):
        flags = 0
        for name_, mask in self._flag_entries:
            if name_ in value and value[name_]:
                flags |= mask
        self.__SetFlags(flags)
    def _GetFlags(self):
        flags = self.__GetFlags()
        ret={}
        for name_, mask in self._flag_entries:
            ret[name_]=((flags & mask)==mask)
        return ret

    flags=property(_GetFlags, _SetFlags, doc='Sets whether or not shapes, joints, etc. will be drawn.')

    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2Draw(self)
        return weakref_proxy(self)
b2Draw.__SetFlags = new_instancemethod(_Box2D.b2Draw___SetFlags, None, b2Draw)
b2Draw.__GetFlags = new_instancemethod(_Box2D.b2Draw___GetFlags, None, b2Draw)
b2Draw.AppendFlags = new_instancemethod(_Box2D.b2Draw_AppendFlags, None, b2Draw)
b2Draw.ClearFlags = new_instancemethod(_Box2D.b2Draw_ClearFlags, None, b2Draw)
b2Draw.DrawPolygon = new_instancemethod(_Box2D.b2Draw_DrawPolygon, None, b2Draw)
b2Draw.DrawSolidPolygon = new_instancemethod(_Box2D.b2Draw_DrawSolidPolygon, None, b2Draw)
b2Draw.DrawCircle = new_instancemethod(_Box2D.b2Draw_DrawCircle, None, b2Draw)
b2Draw.DrawSolidCircle = new_instancemethod(_Box2D.b2Draw_DrawSolidCircle, None, b2Draw)
b2Draw.DrawSegment = new_instancemethod(_Box2D.b2Draw_DrawSegment, None, b2Draw)
b2Draw.DrawTransform = new_instancemethod(_Box2D.b2Draw_DrawTransform, None, b2Draw)
b2Draw.__hash__ = new_instancemethod(_Box2D.b2Draw___hash__, None, b2Draw)
b2Draw_swigregister = _Box2D.b2Draw_swigregister
b2Draw_swigregister(b2Draw)

class b2DrawExtended(b2Draw):
    """Proxy of C++ b2DrawExtended class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    convertVertices = _swig_property(_Box2D.b2DrawExtended_convertVertices_get, _Box2D.b2DrawExtended_convertVertices_set)
    center = _swig_property(_Box2D.b2DrawExtended_center_get, _Box2D.b2DrawExtended_center_set)
    offset = _swig_property(_Box2D.b2DrawExtended_offset_get, _Box2D.b2DrawExtended_offset_set)
    zoom = _swig_property(_Box2D.b2DrawExtended_zoom_get, _Box2D.b2DrawExtended_zoom_set)
    screenSize = _swig_property(_Box2D.b2DrawExtended_screenSize_get, _Box2D.b2DrawExtended_screenSize_set)
    flipY = _swig_property(_Box2D.b2DrawExtended_flipY_get, _Box2D.b2DrawExtended_flipY_set)
    flipX = _swig_property(_Box2D.b2DrawExtended_flipX_get, _Box2D.b2DrawExtended_flipX_set)

    def __Convert(self, verts, vertexCount):
        """__Convert(b2DrawExtended self, b2Vec2 verts, int32 vertexCount) -> PyObject *"""
        return _Box2D.b2DrawExtended___Convert(self, verts, vertexCount)


    def to_screen(self, point):
        """to_screen(b2DrawExtended self, b2Vec2 point) -> PyObject *"""
        return _Box2D.b2DrawExtended_to_screen(self, point)


    def DrawPolygon(self, conv_vertices, vertexCount, color):
        """
        DrawPolygon(b2DrawExtended self, b2Vec2 conv_vertices, int32 vertexCount, b2Color color)

        Draw a closed polygon provided in CCW order.
        """
        return _Box2D.b2DrawExtended_DrawPolygon(self, conv_vertices, vertexCount, color)


    def DrawSolidPolygon(self, conv_vertices, vertexCount, color):
        """
        DrawSolidPolygon(b2DrawExtended self, b2Vec2 conv_vertices, int32 vertexCount, b2Color color)

        Draw a solid closed polygon provided in CCW order.
        """
        return _Box2D.b2DrawExtended_DrawSolidPolygon(self, conv_vertices, vertexCount, color)


    def DrawCircle(self, conv_p1, radius, color):
        """
        DrawCircle(b2DrawExtended self, b2Vec2 conv_p1, float32 radius, b2Color color)

        Draw a circle.
        """
        return _Box2D.b2DrawExtended_DrawCircle(self, conv_p1, radius, color)


    def DrawSolidCircle(self, conv_p1, radius, axis, color):
        """
        DrawSolidCircle(b2DrawExtended self, b2Vec2 conv_p1, float32 radius, b2Vec2 axis, b2Color color)

        Draw a solid circle.
        """
        return _Box2D.b2DrawExtended_DrawSolidCircle(self, conv_p1, radius, axis, color)


    def DrawSegment(self, conv_p1, conv_p2, color):
        """
        DrawSegment(b2DrawExtended self, b2Vec2 conv_p1, b2Vec2 conv_p2, b2Color color)

        Draw a line segment.
        """
        return _Box2D.b2DrawExtended_DrawSegment(self, conv_p1, conv_p2, color)


    def DrawTransform(self, xf):
        """
        DrawTransform(b2DrawExtended self, b2Transform xf)

        Draw a transform. Choose your own length scale.

        Parameters:
        -----------

        xf: 
        a transform.
        """
        return _Box2D.b2DrawExtended_DrawTransform(self, xf)


    def __SetFlags(self, flags):
        """__SetFlags(b2DrawExtended self, uint32 flags)"""
        return _Box2D.b2DrawExtended___SetFlags(self, flags)

    __swig_destroy__ = _Box2D.delete_b2DrawExtended

    def __init__(self, **kwargs):
        if self.__class__ == b2DrawExtended:
            _self = None
        else:
            _self = self
        _Box2D.b2DrawExtended_swiginit(self,_Box2D.new_b2DrawExtended(_self, ))
        _init_kwargs(self, **kwargs)



    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2DrawExtended self) -> long"""
        return _Box2D.b2DrawExtended___hash__(self)


    def __repr__(self):
        return _format_repr(self) 

    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2DrawExtended(self)
        return weakref_proxy(self)
b2DrawExtended.__Convert = new_instancemethod(_Box2D.b2DrawExtended___Convert, None, b2DrawExtended)
b2DrawExtended.to_screen = new_instancemethod(_Box2D.b2DrawExtended_to_screen, None, b2DrawExtended)
b2DrawExtended.DrawPolygon = new_instancemethod(_Box2D.b2DrawExtended_DrawPolygon, None, b2DrawExtended)
b2DrawExtended.DrawSolidPolygon = new_instancemethod(_Box2D.b2DrawExtended_DrawSolidPolygon, None, b2DrawExtended)
b2DrawExtended.DrawCircle = new_instancemethod(_Box2D.b2DrawExtended_DrawCircle, None, b2DrawExtended)
b2DrawExtended.DrawSolidCircle = new_instancemethod(_Box2D.b2DrawExtended_DrawSolidCircle, None, b2DrawExtended)
b2DrawExtended.DrawSegment = new_instancemethod(_Box2D.b2DrawExtended_DrawSegment, None, b2DrawExtended)
b2DrawExtended.DrawTransform = new_instancemethod(_Box2D.b2DrawExtended_DrawTransform, None, b2DrawExtended)
b2DrawExtended.__SetFlags = new_instancemethod(_Box2D.b2DrawExtended___SetFlags, None, b2DrawExtended)
b2DrawExtended.__hash__ = new_instancemethod(_Box2D.b2DrawExtended___hash__, None, b2DrawExtended)
b2DrawExtended_swigregister = _Box2D.b2DrawExtended_swigregister
b2DrawExtended_swigregister(b2DrawExtended)

class b2MassData(object):
    """This holds the mass data computed for a shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mass = _swig_property(_Box2D.b2MassData_mass_get, _Box2D.b2MassData_mass_set)
    center = _swig_property(_Box2D.b2MassData_center_get, _Box2D.b2MassData_center_set)
    I = _swig_property(_Box2D.b2MassData_I_get, _Box2D.b2MassData_I_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2MassData self) -> long"""
        return _Box2D.b2MassData___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2MassData_swiginit(self,_Box2D.new_b2MassData())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2MassData
b2MassData.__hash__ = new_instancemethod(_Box2D.b2MassData___hash__, None, b2MassData)
b2MassData_swigregister = _Box2D.b2MassData_swigregister
b2MassData_swigregister(b2MassData)
b2_chunkSize = b2Globals.b2_chunkSize
b2_maxBlockSize = b2Globals.b2_maxBlockSize
b2_blockSizes = b2Globals.b2_blockSizes
b2_chunkArrayIncrement = b2Globals.b2_chunkArrayIncrement

class b2Shape(object):
    """A shape is used for collision detection. You can create a shape however you like. Shapes used for simulation in  b2Worldare created automatically when a  b2Fixtureis created. Shapes may encapsulate a one or more child shapes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    e_circle = _Box2D.b2Shape_e_circle
    e_edge = _Box2D.b2Shape_e_edge
    e_polygon = _Box2D.b2Shape_e_polygon
    e_chain = _Box2D.b2Shape_e_chain
    e_typeCount = _Box2D.b2Shape_e_typeCount
    __swig_destroy__ = _Box2D.delete_b2Shape

    def __GetType(self):
        """
        __GetType(b2Shape self) -> b2Shape::Type

        Get the type of this shape. You can use this to down cast to the concrete shape. 
        the shape type.
        """
        return _Box2D.b2Shape___GetType(self)


    def __GetChildCount(self):
        """
        __GetChildCount(b2Shape self) -> int32

        Get the number of child primitives.
        """
        return _Box2D.b2Shape___GetChildCount(self)


    def TestPoint(self, xf, p):
        """
        TestPoint(b2Shape self, b2Transform xf, b2Vec2 p) -> bool

        Test a point for containment in this shape. This only works for convex shapes.

        Parameters:
        -----------

        xf: 
        the shape world transform.

        p: 
        a point in world coordinates.
        """
        return _Box2D.b2Shape_TestPoint(self, xf, p)


    def RayCast(self, output, input, transform, childIndex):
        """
        RayCast(b2Shape self, b2RayCastOutput output, b2RayCastInput input, b2Transform transform, int32 childIndex) -> bool

        Cast a ray against a child shape.

        Parameters:
        -----------

        output: 
        the ray-cast results.

        input: 
        the ray-cast input parameters.

        transform: 
        the transform to be applied to the shape.

        childIndex: 
        the child shape index
        """
        return _Box2D.b2Shape_RayCast(self, output, input, transform, childIndex)


    def __ComputeAABB(self, aabb, xf, childIndex):
        """
        __ComputeAABB(b2Shape self, b2AABB aabb, b2Transform xf, int32 childIndex)

        Given a transform, compute the associated axis aligned bounding box for a child shape.

        Parameters:
        -----------

        aabb: 
        returns the axis aligned box.

        xf: 
        the world transform of the shape.

        childIndex: 
        the child shape
        """
        return _Box2D.b2Shape___ComputeAABB(self, aabb, xf, childIndex)


    def __ComputeMass(self, massData, density):
        """
        __ComputeMass(b2Shape self, b2MassData massData, float32 density)

        Compute the mass properties of this shape using its dimensions and density. The inertia tensor is computed about the local origin.

        Parameters:
        -----------

        massData: 
        returns the mass data for this shape.

        density: 
        the density in kilograms per meter squared.
        """
        return _Box2D.b2Shape___ComputeMass(self, massData, density)

    radius = _swig_property(_Box2D.b2Shape_radius_get, _Box2D.b2Shape_radius_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Shape self) -> long"""
        return _Box2D.b2Shape___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    __eq__ = b2ShapeCompare
    __ne__ = lambda self,other: not b2ShapeCompare(self,other)
    # Read-only
    type = property(__GetType, None)

    def getAsType(self):
        return self

    @property
    def childCount(self):
        """
        Get the number of child primitives.
        """
        return self.__GetChildCount()

    def getAABB(self, transform, childIndex):
        """
        Given a transform, compute the associated axis aligned bounding box for a child shape.
        """
        if childIndex >= self.childCount:
            raise ValueError('Child index should be at most childCount=%d' % self.childCount)
        aabb=b2AABB()
        self.__ComputeAABB(aabb, transform, childIndex)
        return aabb

    def getMass(self, density):
        """
        Compute the mass properties of this shape using its dimensions and density.
        The inertia tensor is computed about the local origin.
        """
        m=b2MassData()
        self.__ComputeMass(m, density)
        return m


b2Shape.__GetType = new_instancemethod(_Box2D.b2Shape___GetType, None, b2Shape)
b2Shape.__GetChildCount = new_instancemethod(_Box2D.b2Shape___GetChildCount, None, b2Shape)
b2Shape.TestPoint = new_instancemethod(_Box2D.b2Shape_TestPoint, None, b2Shape)
b2Shape.RayCast = new_instancemethod(_Box2D.b2Shape_RayCast, None, b2Shape)
b2Shape.__ComputeAABB = new_instancemethod(_Box2D.b2Shape___ComputeAABB, None, b2Shape)
b2Shape.__ComputeMass = new_instancemethod(_Box2D.b2Shape___ComputeMass, None, b2Shape)
b2Shape.__hash__ = new_instancemethod(_Box2D.b2Shape___hash__, None, b2Shape)
b2Shape_swigregister = _Box2D.b2Shape_swigregister
b2Shape_swigregister(b2Shape)

class b2CircleShape(b2Shape):
    """A circle shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2CircleShape_swiginit(self,_Box2D.new_b2CircleShape())
        _init_kwargs(self, **kwargs)


    pos = _swig_property(_Box2D.b2CircleShape_pos_get, _Box2D.b2CircleShape_pos_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2CircleShape self) -> long"""
        return _Box2D.b2CircleShape___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



    __swig_destroy__ = _Box2D.delete_b2CircleShape
b2CircleShape.__hash__ = new_instancemethod(_Box2D.b2CircleShape___hash__, None, b2CircleShape)
b2CircleShape_swigregister = _Box2D.b2CircleShape_swigregister
b2CircleShape_swigregister(b2CircleShape)

class b2EdgeShape(b2Shape):
    """A line segment (edge) shape. These can be connected in chains or loops to other edge shapes. The connectivity information is used to ensure correct contact normals."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2EdgeShape_swiginit(self,_Box2D.new_b2EdgeShape())
        _init_kwargs(self, **kwargs)



    def __Set(self, v1, v2):
        """
        __Set(b2EdgeShape self, b2Vec2 v1, b2Vec2 v2)

        Set this as an isolated edge.
        """
        return _Box2D.b2EdgeShape___Set(self, v1, v2)

    vertex1 = _swig_property(_Box2D.b2EdgeShape_vertex1_get, _Box2D.b2EdgeShape_vertex1_set)
    vertex2 = _swig_property(_Box2D.b2EdgeShape_vertex2_get, _Box2D.b2EdgeShape_vertex2_set)
    vertex0 = _swig_property(_Box2D.b2EdgeShape_vertex0_get, _Box2D.b2EdgeShape_vertex0_set)
    vertex3 = _swig_property(_Box2D.b2EdgeShape_vertex3_get, _Box2D.b2EdgeShape_vertex3_set)
    hasVertex0 = _swig_property(_Box2D.b2EdgeShape_hasVertex0_get, _Box2D.b2EdgeShape_hasVertex0_set)
    hasVertex3 = _swig_property(_Box2D.b2EdgeShape_hasVertex3_get, _Box2D.b2EdgeShape_hasVertex3_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2EdgeShape self) -> long"""
        return _Box2D.b2EdgeShape___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __repr__(self):
        return "b2EdgeShape(vertices: %s)" % (self.vertices)

    @property
    def all_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x0,y0), (x1,y1), (x2,y2) (x3,y3) ]
        Note that the validity of vertices 0 and 4 depend on whether or not
        hasVertex0 and hasVertex3 are set.
        """
        return [tuple(self.vertex0), tuple(self.vertex1), tuple(self.vertex2), tuple(self.vertex3)]

    def __get_vertices(self):
        """Returns the basic vertices as a list of tuples [ (x1,y1), (x2,y2) ]
        To include the supporting vertices, see 'all_vertices'

        If you want to set vertex3 but not vertex0, pass in None for vertex0.
        """
        return [tuple(self.vertex1), tuple(self.vertex2)]

    def __set_vertices(self, vertices):
        if len(vertices)==2:
            self.vertex1, self.vertex2=vertices
            self.hasVertex0=False
            self.hasVertex3=False
        elif len(vertices)==3:
            self.vertex0, self.vertex1, self.vertex2=vertices
            self.hasVertex0=(vertices[0] != None)
            self.hasVertex3=False
        elif len(vertices)==4:
            self.vertex0, self.vertex1, self.vertex2, self.vertex3=vertices
            self.hasVertex0=(vertices[0] != None)
            self.hasVertex3=True
        else:
            raise ValueError('Expected from 2 to 4 vertices.')

    @property
    def vertexCount(self):
        """
        Returns the number of valid vertices (as in, it counts whether or not 
        hasVertex0 or hasVertex3 are set)
        """
        if self.hasVertex0 and self.hasVertex3:
            return 4
        elif self.hasVertex0 or self.hasVertex3:
            return 3
        else:
            return 2

    def __iter__(self):
        """
        Iterates over the vertices in the Edge
        """
        for v in self.vertices:
            yield v

    vertices=property(__get_vertices, __set_vertices)

    __swig_destroy__ = _Box2D.delete_b2EdgeShape
b2EdgeShape.__Set = new_instancemethod(_Box2D.b2EdgeShape___Set, None, b2EdgeShape)
b2EdgeShape.__hash__ = new_instancemethod(_Box2D.b2EdgeShape___hash__, None, b2EdgeShape)
b2EdgeShape_swigregister = _Box2D.b2EdgeShape_swigregister
b2EdgeShape_swigregister(b2EdgeShape)

class b2ChainShape(b2Shape):
    """A loop shape is a free form sequence of line segments that form a circular list. The loop may cross upon itself, but this is not recommended for smooth collision. The loop has double sided collision, so you can use inside and outside collision. Therefore, you may use any winding order. Since there may be many vertices, they are allocated using b2Alloc."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2ChainShape_swiginit(self,_Box2D.new_b2ChainShape())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ChainShape

    def CreateLoop(self, vertices, count):
        """CreateLoop(b2ChainShape self, b2Vec2 vertices, int32 count)"""
        return _Box2D.b2ChainShape_CreateLoop(self, vertices, count)


    def CreateChain(self, vertices, count):
        """CreateChain(b2ChainShape self, b2Vec2 vertices, int32 count)"""
        return _Box2D.b2ChainShape_CreateChain(self, vertices, count)


    def SetPrevVertex(self, prevVertex):
        """SetPrevVertex(b2ChainShape self, b2Vec2 prevVertex)"""
        return _Box2D.b2ChainShape_SetPrevVertex(self, prevVertex)


    def SetNextVertex(self, nextVertex):
        """SetNextVertex(b2ChainShape self, b2Vec2 nextVertex)"""
        return _Box2D.b2ChainShape_SetNextVertex(self, nextVertex)


    def __GetChildEdge(self, edge, index):
        """
        __GetChildEdge(b2ChainShape self, b2EdgeShape edge, int32 index)

        Get a child edge.
        """
        return _Box2D.b2ChainShape___GetChildEdge(self, edge, index)

    m_prevVertex = _swig_property(_Box2D.b2ChainShape_m_prevVertex_get, _Box2D.b2ChainShape_m_prevVertex_set)
    m_nextVertex = _swig_property(_Box2D.b2ChainShape_m_nextVertex_get, _Box2D.b2ChainShape_m_nextVertex_set)
    m_hasPrevVertex = _swig_property(_Box2D.b2ChainShape_m_hasPrevVertex_get, _Box2D.b2ChainShape_m_hasPrevVertex_set)
    m_hasNextVertex = _swig_property(_Box2D.b2ChainShape_m_hasNextVertex_get, _Box2D.b2ChainShape_m_hasNextVertex_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ChainShape self) -> long"""
        return _Box2D.b2ChainShape___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __get_vertices(self):
        """__get_vertices(b2ChainShape self) -> PyObject *"""
        return _Box2D.b2ChainShape___get_vertices(self)


    def __repr__(self):
        return "b2ChainShape(vertices: %s)" % (self.vertices)

    def getChildEdge(self, index):
        if childIndex >= self.childCount:
            raise ValueError('Child index should be at most childCount=%d' % self.childCount)

        edge=b2EdgeShape()
        self.__GetChildEdge(edge, index)
        return edge

    @property
    def edges(self):
        return [self.getChildEdge(i) for i in range(self.childCount)]

    @property
    def vertexCount(self):
        return self.__get_count()

    def __get_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]"""
        return [ (self.__get_vertex(i).x, self.__get_vertex(i).y )
                         for i in range(0, self.vertexCount)]

    def __iter__(self):
        """
        Iterates over the vertices in the Chain
        """
        for v in self.vertices:
            yield v

    def __set_vertices(self, values, loop=True):
        if not values or not isinstance(values, (list, tuple)) or (len(values) < 2):
            raise ValueError('Expected tuple or list of length >= 2.')

        for i,value in enumerate(values):
            if isinstance(value, (tuple, list)):
                if len(value) != 2:
                    raise ValueError('Expected tuple or list of length 2, got length %d' % len(value))
                for j in value:
                     if not isinstance(j, (int, float)):
                        raise ValueError('Expected int or float values, got %s' % (type(j)))
            elif isinstance(value, b2Vec2):
                pass
            else:
                raise ValueError('Expected tuple, list, or b2Vec2, got %s' % type(value))

        vecs=_b2Vec2Array(len(values))
        for i, value in enumerate(values):
            if isinstance(value, b2Vec2):
                vecs[i]=value
            else:
                vecs[i]=b2Vec2(value)

        self.__create(vecs, len(values), loop)

    vertices = property(__get_vertices, __set_vertices)
    vertices_chain = property(__get_vertices, lambda self, v : self.__set_vertices(v, loop=False))
    vertices_loop = vertices


    def __create(self, v, c, loop):
        """__create(b2ChainShape self, _b2Vec2Array v, int c, bool loop)"""
        return _Box2D.b2ChainShape___create(self, v, c, loop)


    def __get_vertex(self, vnum):
        """__get_vertex(b2ChainShape self, uint16 vnum) -> b2Vec2"""
        return _Box2D.b2ChainShape___get_vertex(self, vnum)


    def __get_count(self):
        """__get_count(b2ChainShape self) -> int32"""
        return _Box2D.b2ChainShape___get_count(self)

b2ChainShape.CreateLoop = new_instancemethod(_Box2D.b2ChainShape_CreateLoop, None, b2ChainShape)
b2ChainShape.CreateChain = new_instancemethod(_Box2D.b2ChainShape_CreateChain, None, b2ChainShape)
b2ChainShape.SetPrevVertex = new_instancemethod(_Box2D.b2ChainShape_SetPrevVertex, None, b2ChainShape)
b2ChainShape.SetNextVertex = new_instancemethod(_Box2D.b2ChainShape_SetNextVertex, None, b2ChainShape)
b2ChainShape.__GetChildEdge = new_instancemethod(_Box2D.b2ChainShape___GetChildEdge, None, b2ChainShape)
b2ChainShape.__hash__ = new_instancemethod(_Box2D.b2ChainShape___hash__, None, b2ChainShape)
b2ChainShape.__get_vertices = new_instancemethod(_Box2D.b2ChainShape___get_vertices, None, b2ChainShape)
b2ChainShape.__create = new_instancemethod(_Box2D.b2ChainShape___create, None, b2ChainShape)
b2ChainShape.__get_vertex = new_instancemethod(_Box2D.b2ChainShape___get_vertex, None, b2ChainShape)
b2ChainShape.__get_count = new_instancemethod(_Box2D.b2ChainShape___get_count, None, b2ChainShape)
b2ChainShape_swigregister = _Box2D.b2ChainShape_swigregister
b2ChainShape_swigregister(b2ChainShape)

class b2PolygonShape(b2Shape):
    """A convex polygon. It is assumed that the interior of the polygon is to the left of each edge. Polygons have a maximum number of vertices equal to b2_maxPolygonVertices. In most cases you should not need many vertices for a convex polygon."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2PolygonShape_swiginit(self,_Box2D.new_b2PolygonShape())
        _init_kwargs(self, **kwargs)



    def SetAsBox(self, *args):
        """
        SetAsBox(b2PolygonShape self, float32 hx, float32 hy)
        SetAsBox(b2PolygonShape self, float32 hx, float32 hy, b2Vec2 center, float32 angle)

        Build vertices to represent an oriented box.

        Parameters:
        -----------

        hx: 
        the half-width.

        hy: 
        the half-height.

        center: 
        the center of the box in local coordinates.

        angle: 
        the rotation of the box in local coordinates.
        """
        return _Box2D.b2PolygonShape_SetAsBox(self, *args)


    def Validate(self):
        """Validate(b2PolygonShape self) -> bool"""
        return _Box2D.b2PolygonShape_Validate(self)

    centroid = _swig_property(_Box2D.b2PolygonShape_centroid_get, _Box2D.b2PolygonShape_centroid_set)
    vertexCount = _swig_property(_Box2D.b2PolygonShape_vertexCount_get, _Box2D.b2PolygonShape_vertexCount_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2PolygonShape self) -> long"""
        return _Box2D.b2PolygonShape___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __get_vertices(self):
        """__get_vertices(b2PolygonShape self) -> PyObject *"""
        return _Box2D.b2PolygonShape___get_vertices(self)


    def __get_normals(self):
        """__get_normals(b2PolygonShape self) -> PyObject *"""
        return _Box2D.b2PolygonShape___get_normals(self)


    def __repr__(self):
        return "b2PolygonShape(vertices: %s)" % (self.vertices)
    def __clear_vertices(self):
        self.vertexCount=0
        for i in range(0, b2_maxPolygonVertices):
            self.set_vertex(i, 0, 0)
    def __set_vertices(self, values):
        if not values:
            self.__clear_vertices()
        else:
            if len(values) < 2 or len(values) > b2_maxPolygonVertices:
                raise ValueError('Expected tuple or list of length >= 2 and less than b2_maxPolygonVertices=%d, got length %d.' %
                                     (b2_maxPolygonVertices, len(values)))
            for i,value in enumerate(values):
                if isinstance(value, (tuple, list, b2Vec2)):
                    if len(value) != 2:
                        raise ValueError('Expected tuple or list of length 2, got length %d' % len(value))
                    self.set_vertex(i, *value)
                else:
                    raise ValueError('Expected tuple, list, or b2Vec2, got %s' % type(value))
                self.vertexCount=i+1 # follow along in case of an exception to indicate valid number set

            self.__set_vertices_internal() # calculates normals, centroid, etc.

    def __iter__(self):
        """
        Iterates over the vertices in the polygon
        """
        for v in self.vertices:
            yield v

    def __IsValid(self):
        return b2CheckPolygon(self)

    valid = property(__IsValid, None, doc="Checks the polygon to see if it can be properly created. Raises ValueError for invalid shapes.")
    vertices = property(__get_vertices, __set_vertices, doc="All of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]")
    normals = property(__get_normals, None, doc="All of the normals as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]")
    box = property(None, lambda self, value: self.SetAsBox(*value), doc="Property replacement for running SetAsBox (Write-only)")


    def __get_vertex(self, vnum):
        """__get_vertex(b2PolygonShape self, uint16 vnum) -> b2Vec2"""
        return _Box2D.b2PolygonShape___get_vertex(self, vnum)


    def __get_normal(self, vnum):
        """__get_normal(b2PolygonShape self, uint16 vnum) -> b2Vec2"""
        return _Box2D.b2PolygonShape___get_normal(self, vnum)


    def set_vertex(self, *args):
        """
        set_vertex(b2PolygonShape self, uint16 vnum, b2Vec2 value)
        set_vertex(b2PolygonShape self, uint16 vnum, float32 x, float32 y)
        """
        return _Box2D.b2PolygonShape_set_vertex(self, *args)


    def __set_vertices_internal(self, *args):
        """
        __set_vertices_internal(b2PolygonShape self, b2Vec2 points, int32 count)
        __set_vertices_internal(b2PolygonShape self)
        """
        return _Box2D.b2PolygonShape___set_vertices_internal(self, *args)

    __swig_destroy__ = _Box2D.delete_b2PolygonShape
b2PolygonShape.SetAsBox = new_instancemethod(_Box2D.b2PolygonShape_SetAsBox, None, b2PolygonShape)
b2PolygonShape.Validate = new_instancemethod(_Box2D.b2PolygonShape_Validate, None, b2PolygonShape)
b2PolygonShape.__hash__ = new_instancemethod(_Box2D.b2PolygonShape___hash__, None, b2PolygonShape)
b2PolygonShape.__get_vertices = new_instancemethod(_Box2D.b2PolygonShape___get_vertices, None, b2PolygonShape)
b2PolygonShape.__get_normals = new_instancemethod(_Box2D.b2PolygonShape___get_normals, None, b2PolygonShape)
b2PolygonShape.__get_vertex = new_instancemethod(_Box2D.b2PolygonShape___get_vertex, None, b2PolygonShape)
b2PolygonShape.__get_normal = new_instancemethod(_Box2D.b2PolygonShape___get_normal, None, b2PolygonShape)
b2PolygonShape.set_vertex = new_instancemethod(_Box2D.b2PolygonShape_set_vertex, None, b2PolygonShape)
b2PolygonShape.__set_vertices_internal = new_instancemethod(_Box2D.b2PolygonShape___set_vertices_internal, None, b2PolygonShape)
b2PolygonShape_swigregister = _Box2D.b2PolygonShape_swigregister
b2PolygonShape_swigregister(b2PolygonShape)

b2_nullNode = _Box2D.b2_nullNode
class b2TreeNode(object):
    """Proxy of C++ b2TreeNode class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsLeaf(self):
        """IsLeaf(b2TreeNode self) -> bool"""
        return _Box2D.b2TreeNode_IsLeaf(self)

    aabb = _swig_property(_Box2D.b2TreeNode_aabb_get, _Box2D.b2TreeNode_aabb_set)
    child1 = _swig_property(_Box2D.b2TreeNode_child1_get, _Box2D.b2TreeNode_child1_set)
    child2 = _swig_property(_Box2D.b2TreeNode_child2_get, _Box2D.b2TreeNode_child2_set)
    height = _swig_property(_Box2D.b2TreeNode_height_get, _Box2D.b2TreeNode_height_set)

    def __init__(self):
        """__init__(b2TreeNode self) -> b2TreeNode"""
        _Box2D.b2TreeNode_swiginit(self, _Box2D.new_b2TreeNode())
    __swig_destroy__ = _Box2D.delete_b2TreeNode
b2TreeNode.IsLeaf = new_instancemethod(_Box2D.b2TreeNode_IsLeaf, None, b2TreeNode)
b2TreeNode_swigregister = _Box2D.b2TreeNode_swigregister
b2TreeNode_swigregister(b2TreeNode)

class b2Pair(object):
    """Proxy of C++ b2Pair class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    proxyIdA = _swig_property(_Box2D.b2Pair_proxyIdA_get, _Box2D.b2Pair_proxyIdA_set)
    proxyIdB = _swig_property(_Box2D.b2Pair_proxyIdB_get, _Box2D.b2Pair_proxyIdB_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Pair self) -> long"""
        return _Box2D.b2Pair___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2Pair_swiginit(self,_Box2D.new_b2Pair())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Pair
b2Pair.__hash__ = new_instancemethod(_Box2D.b2Pair___hash__, None, b2Pair)
b2Pair_swigregister = _Box2D.b2Pair_swigregister
b2Pair_swigregister(b2Pair)

class b2BroadPhase(object):
    """The broad-phase is used for computing pairs and performing volume queries and ray casts. This broad-phase does not persist pairs. Instead, this reports potentially new pairs. It is up to the client to consume the new pairs and to track subsequent overlap."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_nullProxy = _Box2D.b2BroadPhase_e_nullProxy

    def __init__(self):
        """
        __init__(b2BroadPhase self) -> b2BroadPhase

        The broad-phase is used for computing pairs and performing volume queries and ray casts. This broad-phase does not persist pairs. Instead, this reports potentially new pairs. It is up to the client to consume the new pairs and to track subsequent overlap.
        """
        _Box2D.b2BroadPhase_swiginit(self, _Box2D.new_b2BroadPhase())
    __swig_destroy__ = _Box2D.delete_b2BroadPhase

    def MoveProxy(self, proxyId, aabb, displacement):
        """
        MoveProxy(b2BroadPhase self, int32 proxyId, b2AABB aabb, b2Vec2 displacement)

        Call MoveProxy as many times as you like, then when you are done call UpdatePairs to finalized the proxy pairs (for your time step).
        """
        return _Box2D.b2BroadPhase_MoveProxy(self, proxyId, aabb, displacement)


    def TouchProxy(self, proxyId):
        """
        TouchProxy(b2BroadPhase self, int32 proxyId)

        Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.
        """
        return _Box2D.b2BroadPhase_TouchProxy(self, proxyId)


    def GetFatAABB(self, proxyId):
        """
        GetFatAABB(b2BroadPhase self, int32 proxyId) -> b2AABB

        Get the fat AABB for a proxy.
        """
        return _Box2D.b2BroadPhase_GetFatAABB(self, proxyId)


    def TestOverlap(self, proxyIdA, proxyIdB):
        """
        TestOverlap(b2BroadPhase self, int32 proxyIdA, int32 proxyIdB) -> bool

        Test overlap of fat AABBs.
        """
        return _Box2D.b2BroadPhase_TestOverlap(self, proxyIdA, proxyIdB)


    def __GetProxyCount(self):
        """
        __GetProxyCount(b2BroadPhase self) -> int32

        Get the number of proxies.
        """
        return _Box2D.b2BroadPhase___GetProxyCount(self)


    def __GetTreeHeight(self):
        """__GetTreeHeight(b2BroadPhase self) -> int32"""
        return _Box2D.b2BroadPhase___GetTreeHeight(self)


    def __GetTreeBalance(self):
        """__GetTreeBalance(b2BroadPhase self) -> int32"""
        return _Box2D.b2BroadPhase___GetTreeBalance(self)


    def __GetTreeQuality(self):
        """__GetTreeQuality(b2BroadPhase self) -> float32"""
        return _Box2D.b2BroadPhase___GetTreeQuality(self)


    def ShiftOrigin(self, newOrigin):
        """ShiftOrigin(b2BroadPhase self, b2Vec2 newOrigin)"""
        return _Box2D.b2BroadPhase_ShiftOrigin(self, newOrigin)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2BroadPhase self) -> long"""
        return _Box2D.b2BroadPhase___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    proxyCount=property(__GetProxyCount, None)
    treeHeight=property(__GetTreeHeight, None)
    treeBalance=property(__GetTreeBalance, None)
    treeQuality=property(__GetTreeQuality, None)

b2BroadPhase.MoveProxy = new_instancemethod(_Box2D.b2BroadPhase_MoveProxy, None, b2BroadPhase)
b2BroadPhase.TouchProxy = new_instancemethod(_Box2D.b2BroadPhase_TouchProxy, None, b2BroadPhase)
b2BroadPhase.GetFatAABB = new_instancemethod(_Box2D.b2BroadPhase_GetFatAABB, None, b2BroadPhase)
b2BroadPhase.TestOverlap = new_instancemethod(_Box2D.b2BroadPhase_TestOverlap, None, b2BroadPhase)
b2BroadPhase.__GetProxyCount = new_instancemethod(_Box2D.b2BroadPhase___GetProxyCount, None, b2BroadPhase)
b2BroadPhase.__GetTreeHeight = new_instancemethod(_Box2D.b2BroadPhase___GetTreeHeight, None, b2BroadPhase)
b2BroadPhase.__GetTreeBalance = new_instancemethod(_Box2D.b2BroadPhase___GetTreeBalance, None, b2BroadPhase)
b2BroadPhase.__GetTreeQuality = new_instancemethod(_Box2D.b2BroadPhase___GetTreeQuality, None, b2BroadPhase)
b2BroadPhase.ShiftOrigin = new_instancemethod(_Box2D.b2BroadPhase_ShiftOrigin, None, b2BroadPhase)
b2BroadPhase.__hash__ = new_instancemethod(_Box2D.b2BroadPhase___hash__, None, b2BroadPhase)
b2BroadPhase_swigregister = _Box2D.b2BroadPhase_swigregister
b2BroadPhase_swigregister(b2BroadPhase)


def b2PairLessThan(pair1, pair2):
    """
    b2PairLessThan(b2Pair pair1, b2Pair pair2) -> bool

    This is used to sort pairs.
    """
    return _Box2D.b2PairLessThan(pair1, pair2)
class b2DistanceProxy(object):
    """A distance proxy is used by the GJK algorithm. It encapsulates any shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, shape, index=0):
        _Box2D.b2DistanceProxy_swiginit(self,_Box2D.new_b2DistanceProxy())
        self.Set(shape, index)



    def Set(self, shape, index):
        """
        Set(b2DistanceProxy self, b2Shape shape, int32 index)

        Initialize the proxy using the given shape. The shape must remain in scope while the proxy is in use.
        """
        return _Box2D.b2DistanceProxy_Set(self, shape, index)


    def GetSupport(self, d):
        """
        GetSupport(b2DistanceProxy self, b2Vec2 d) -> int32

        Get the supporting vertex index in the given direction.
        """
        return _Box2D.b2DistanceProxy_GetSupport(self, d)


    def GetSupportVertex(self, d):
        """
        GetSupportVertex(b2DistanceProxy self, b2Vec2 d) -> b2Vec2

        Get the supporting vertex in the given direction.
        """
        return _Box2D.b2DistanceProxy_GetSupportVertex(self, d)


    def __get_vertex_count(self):
        """
        __get_vertex_count(b2DistanceProxy self) -> int32

        Get the vertex count.
        """
        return _Box2D.b2DistanceProxy___get_vertex_count(self)


    def __get_vertex(self, index):
        """
        __get_vertex(b2DistanceProxy self, int32 index) -> b2Vec2

        Get a vertex by index. Used by b2Distance.
        """
        return _Box2D.b2DistanceProxy___get_vertex(self, index)

    m_buffer = _swig_property(_Box2D.b2DistanceProxy_m_buffer_get, _Box2D.b2DistanceProxy_m_buffer_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2DistanceProxy self) -> long"""
        return _Box2D.b2DistanceProxy___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __get_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]"""
        return [ (self.__get_vertex(i).x, self.__get_vertex(i).y )
                         for i in range(0, self.__get_vertex_count())]
    vertices = property(__get_vertices, None)

    __swig_destroy__ = _Box2D.delete_b2DistanceProxy
b2DistanceProxy.Set = new_instancemethod(_Box2D.b2DistanceProxy_Set, None, b2DistanceProxy)
b2DistanceProxy.GetSupport = new_instancemethod(_Box2D.b2DistanceProxy_GetSupport, None, b2DistanceProxy)
b2DistanceProxy.GetSupportVertex = new_instancemethod(_Box2D.b2DistanceProxy_GetSupportVertex, None, b2DistanceProxy)
b2DistanceProxy.__get_vertex_count = new_instancemethod(_Box2D.b2DistanceProxy___get_vertex_count, None, b2DistanceProxy)
b2DistanceProxy.__get_vertex = new_instancemethod(_Box2D.b2DistanceProxy___get_vertex, None, b2DistanceProxy)
b2DistanceProxy.__hash__ = new_instancemethod(_Box2D.b2DistanceProxy___hash__, None, b2DistanceProxy)
b2DistanceProxy_swigregister = _Box2D.b2DistanceProxy_swigregister
b2DistanceProxy_swigregister(b2DistanceProxy)

class b2DistanceInput(object):
    """Input for b2Distance. You have to option to use the shape radii in the computation. Even"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    proxyA = _swig_property(_Box2D.b2DistanceInput_proxyA_get, _Box2D.b2DistanceInput_proxyA_set)
    proxyB = _swig_property(_Box2D.b2DistanceInput_proxyB_get, _Box2D.b2DistanceInput_proxyB_set)
    transformA = _swig_property(_Box2D.b2DistanceInput_transformA_get, _Box2D.b2DistanceInput_transformA_set)
    transformB = _swig_property(_Box2D.b2DistanceInput_transformB_get, _Box2D.b2DistanceInput_transformB_set)
    useRadii = _swig_property(_Box2D.b2DistanceInput_useRadii_get, _Box2D.b2DistanceInput_useRadii_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2DistanceInput self) -> long"""
        return _Box2D.b2DistanceInput___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2DistanceInput_swiginit(self,_Box2D.new_b2DistanceInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2DistanceInput
b2DistanceInput.__hash__ = new_instancemethod(_Box2D.b2DistanceInput___hash__, None, b2DistanceInput)
b2DistanceInput_swigregister = _Box2D.b2DistanceInput_swigregister
b2DistanceInput_swigregister(b2DistanceInput)

class b2DistanceOutput(object):
    """Output for b2Distance."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pointA = _swig_property(_Box2D.b2DistanceOutput_pointA_get, _Box2D.b2DistanceOutput_pointA_set)
    pointB = _swig_property(_Box2D.b2DistanceOutput_pointB_get, _Box2D.b2DistanceOutput_pointB_set)
    distance = _swig_property(_Box2D.b2DistanceOutput_distance_get, _Box2D.b2DistanceOutput_distance_set)
    iterations = _swig_property(_Box2D.b2DistanceOutput_iterations_get, _Box2D.b2DistanceOutput_iterations_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2DistanceOutput self) -> long"""
        return _Box2D.b2DistanceOutput___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2DistanceOutput_swiginit(self,_Box2D.new_b2DistanceOutput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2DistanceOutput
b2DistanceOutput.__hash__ = new_instancemethod(_Box2D.b2DistanceOutput___hash__, None, b2DistanceOutput)
b2DistanceOutput_swigregister = _Box2D.b2DistanceOutput_swigregister
b2DistanceOutput_swigregister(b2DistanceOutput)

class b2TOIInput(object):
    """Input parameters for b2TimeOfImpact."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    proxyA = _swig_property(_Box2D.b2TOIInput_proxyA_get, _Box2D.b2TOIInput_proxyA_set)
    proxyB = _swig_property(_Box2D.b2TOIInput_proxyB_get, _Box2D.b2TOIInput_proxyB_set)
    sweepA = _swig_property(_Box2D.b2TOIInput_sweepA_get, _Box2D.b2TOIInput_sweepA_set)
    sweepB = _swig_property(_Box2D.b2TOIInput_sweepB_get, _Box2D.b2TOIInput_sweepB_set)
    tMax = _swig_property(_Box2D.b2TOIInput_tMax_get, _Box2D.b2TOIInput_tMax_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2TOIInput self) -> long"""
        return _Box2D.b2TOIInput___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2TOIInput_swiginit(self,_Box2D.new_b2TOIInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2TOIInput
b2TOIInput.__hash__ = new_instancemethod(_Box2D.b2TOIInput___hash__, None, b2TOIInput)
b2TOIInput_swigregister = _Box2D.b2TOIInput_swigregister
b2TOIInput_swigregister(b2TOIInput)

class b2TOIOutput(object):
    """Proxy of C++ b2TOIOutput class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_unknown = _Box2D.b2TOIOutput_e_unknown
    e_failed = _Box2D.b2TOIOutput_e_failed
    e_overlapped = _Box2D.b2TOIOutput_e_overlapped
    e_touching = _Box2D.b2TOIOutput_e_touching
    e_separated = _Box2D.b2TOIOutput_e_separated
    state = _swig_property(_Box2D.b2TOIOutput_state_get, _Box2D.b2TOIOutput_state_set)
    t = _swig_property(_Box2D.b2TOIOutput_t_get, _Box2D.b2TOIOutput_t_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2TOIOutput self) -> long"""
        return _Box2D.b2TOIOutput___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        """__init__(b2TOIOutput self) -> b2TOIOutput"""
        _Box2D.b2TOIOutput_swiginit(self, _Box2D.new_b2TOIOutput())
    __swig_destroy__ = _Box2D.delete_b2TOIOutput
b2TOIOutput.__hash__ = new_instancemethod(_Box2D.b2TOIOutput___hash__, None, b2TOIOutput)
b2TOIOutput_swigregister = _Box2D.b2TOIOutput_swigregister
b2TOIOutput_swigregister(b2TOIOutput)

b2_staticBody = _Box2D.b2_staticBody
b2_kinematicBody = _Box2D.b2_kinematicBody
b2_dynamicBody = _Box2D.b2_dynamicBody
class b2BodyDef(object):
    """A body definition holds all the data needed to construct a rigid body. You can safely re-use body definitions. Shapes are added to a body after construction."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2BodyDef_swiginit(self,_Box2D.new_b2BodyDef())
        _init_kwargs(self, **kwargs)


    type = _swig_property(_Box2D.b2BodyDef_type_get, _Box2D.b2BodyDef_type_set)
    position = _swig_property(_Box2D.b2BodyDef_position_get, _Box2D.b2BodyDef_position_set)
    angle = _swig_property(_Box2D.b2BodyDef_angle_get, _Box2D.b2BodyDef_angle_set)
    linearVelocity = _swig_property(_Box2D.b2BodyDef_linearVelocity_get, _Box2D.b2BodyDef_linearVelocity_set)
    angularVelocity = _swig_property(_Box2D.b2BodyDef_angularVelocity_get, _Box2D.b2BodyDef_angularVelocity_set)
    linearDamping = _swig_property(_Box2D.b2BodyDef_linearDamping_get, _Box2D.b2BodyDef_linearDamping_set)
    angularDamping = _swig_property(_Box2D.b2BodyDef_angularDamping_get, _Box2D.b2BodyDef_angularDamping_set)
    allowSleep = _swig_property(_Box2D.b2BodyDef_allowSleep_get, _Box2D.b2BodyDef_allowSleep_set)
    awake = _swig_property(_Box2D.b2BodyDef_awake_get, _Box2D.b2BodyDef_awake_set)
    fixedRotation = _swig_property(_Box2D.b2BodyDef_fixedRotation_get, _Box2D.b2BodyDef_fixedRotation_set)
    bullet = _swig_property(_Box2D.b2BodyDef_bullet_get, _Box2D.b2BodyDef_bullet_set)
    active = _swig_property(_Box2D.b2BodyDef_active_get, _Box2D.b2BodyDef_active_set)
    gravityScale = _swig_property(_Box2D.b2BodyDef_gravityScale_get, _Box2D.b2BodyDef_gravityScale_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2BodyDef self) -> long"""
        return _Box2D.b2BodyDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __GetUserData(self):
        """__GetUserData(b2BodyDef self) -> PyObject *"""
        return _Box2D.b2BodyDef___GetUserData(self)


    def __SetUserData(self, data):
        """__SetUserData(b2BodyDef self, PyObject * data)"""
        return _Box2D.b2BodyDef___SetUserData(self, data)


    def ClearUserData(self):
        """ClearUserData(b2BodyDef self)"""
        return _Box2D.b2BodyDef_ClearUserData(self)


    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()


    _fixtures = None
    _shapes = None
    _shapeFixture = None

    @property
    def fixtures(self):
        return self._fixtures

    @fixtures.setter
    def fixtures(self, fixtures):
        if isinstance(fixtures, b2FixtureDef):
            self._fixtures = [fixtures]
        else:
            self._fixtures = list(fixtures)

    @property
    def shapes(self):
        return self._shapes

    @shapes.setter
    def shapes(self, shapes):
        if isinstance(shapes, b2Shape):
            self._shapes = [shapes]
        else:
            self._shapes = list(shapes)

    @property
    def shapeFixture(self):
        return self._shapeFixture

    @shapeFixture.setter
    def shapeFixture(self, fixture):
        self._shapeFixture = fixture


    __swig_destroy__ = _Box2D.delete_b2BodyDef
b2BodyDef.__hash__ = new_instancemethod(_Box2D.b2BodyDef___hash__, None, b2BodyDef)
b2BodyDef.__GetUserData = new_instancemethod(_Box2D.b2BodyDef___GetUserData, None, b2BodyDef)
b2BodyDef.__SetUserData = new_instancemethod(_Box2D.b2BodyDef___SetUserData, None, b2BodyDef)
b2BodyDef.ClearUserData = new_instancemethod(_Box2D.b2BodyDef_ClearUserData, None, b2BodyDef)
b2BodyDef_swigregister = _Box2D.b2BodyDef_swigregister
b2BodyDef_swigregister(b2BodyDef)

class b2Body(object):
    """A rigid body. These are created via  b2World::CreateBody."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __SetTransform(self, position, angle):
        """
        __SetTransform(b2Body self, b2Vec2 position, float32 angle)

        Set the position of the body's origin and rotation. This breaks any contacts and wakes the other bodies. Manipulating a body's transform may cause non-physical behavior.

        Parameters:
        -----------

        position: 
        the world position of the body's local origin.

        angle: 
        the world rotation in radians.
        """
        return _Box2D.b2Body___SetTransform(self, position, angle)


    def __GetTransform(self):
        """
        __GetTransform(b2Body self) -> b2Transform

        Get the body transform for the body's origin. 
        the world transform of the body's origin.
        """
        return _Box2D.b2Body___GetTransform(self)


    def __GetPosition(self):
        """
        __GetPosition(b2Body self) -> b2Vec2

        Get the world body origin position. 
        the world position of the body's origin.
        """
        return _Box2D.b2Body___GetPosition(self)


    def __GetAngle(self):
        """
        __GetAngle(b2Body self) -> float32

        Get the angle in radians. 
        the current world rotation angle in radians.
        """
        return _Box2D.b2Body___GetAngle(self)


    def __GetWorldCenter(self):
        """
        __GetWorldCenter(b2Body self) -> b2Vec2

        Get the world position of the center of mass.
        """
        return _Box2D.b2Body___GetWorldCenter(self)


    def __GetLocalCenter(self):
        """
        __GetLocalCenter(b2Body self) -> b2Vec2

        Get the local position of the center of mass.
        """
        return _Box2D.b2Body___GetLocalCenter(self)


    def __SetLinearVelocity(self, v):
        """
        __SetLinearVelocity(b2Body self, b2Vec2 v)

        Set the linear velocity of the center of mass.

        Parameters:
        -----------

        v: 
        the new linear velocity of the center of mass.
        """
        return _Box2D.b2Body___SetLinearVelocity(self, v)


    def __GetLinearVelocity(self):
        """
        __GetLinearVelocity(b2Body self) -> b2Vec2

        Get the linear velocity of the center of mass. 
        the linear velocity of the center of mass.
        """
        return _Box2D.b2Body___GetLinearVelocity(self)


    def __SetAngularVelocity(self, omega):
        """
        __SetAngularVelocity(b2Body self, float32 omega)

        Set the angular velocity.

        Parameters:
        -----------

        omega: 
        the new angular velocity in radians/second.
        """
        return _Box2D.b2Body___SetAngularVelocity(self, omega)


    def __GetAngularVelocity(self):
        """
        __GetAngularVelocity(b2Body self) -> float32

        Get the angular velocity. 
        the angular velocity in radians/second.
        """
        return _Box2D.b2Body___GetAngularVelocity(self)


    def ApplyForce(self, force, point, wake):
        """
        ApplyForce(b2Body self, b2Vec2 force, b2Vec2 point, bool wake)

        Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque and affect the angular velocity. This wakes up the body.

        Parameters:
        -----------

        force: 
        the world force vector, usually in Newtons (N).

        point: 
        the world position of the point of application.
        """
        return _Box2D.b2Body_ApplyForce(self, force, point, wake)


    def ApplyForceToCenter(self, force, wake):
        """ApplyForceToCenter(b2Body self, b2Vec2 force, bool wake)"""
        return _Box2D.b2Body_ApplyForceToCenter(self, force, wake)


    def ApplyTorque(self, torque, wake):
        """
        ApplyTorque(b2Body self, float32 torque, bool wake)

        Apply a torque. This affects the angular velocity without affecting the linear velocity of the center of mass. This wakes up the body.

        Parameters:
        -----------

        torque: 
        about the z-axis (out of the screen), usually in N-m.
        """
        return _Box2D.b2Body_ApplyTorque(self, torque, wake)


    def ApplyLinearImpulse(self, impulse, point, wake):
        """
        ApplyLinearImpulse(b2Body self, b2Vec2 impulse, b2Vec2 point, bool wake)

        Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if the point of application is not at the center of mass. This wakes up the body.

        Parameters:
        -----------

        impulse: 
        the world impulse vector, usually in N-seconds or kg-m/s.

        point: 
        the world position of the point of application.
        """
        return _Box2D.b2Body_ApplyLinearImpulse(self, impulse, point, wake)


    def ApplyAngularImpulse(self, impulse, wake):
        """
        ApplyAngularImpulse(b2Body self, float32 impulse, bool wake)

        Apply an angular impulse.

        Parameters:
        -----------

        impulse: 
        the angular impulse in units of kg*m*m/s
        """
        return _Box2D.b2Body_ApplyAngularImpulse(self, impulse, wake)


    def __GetMass(self):
        """
        __GetMass(b2Body self) -> float32

        Get the total mass of the body. 
        the mass, usually in kilograms (kg).
        """
        return _Box2D.b2Body___GetMass(self)


    def __GetInertia(self):
        """
        __GetInertia(b2Body self) -> float32

        Get the rotational inertia of the body about the local origin. 
        the rotational inertia, usually in kg-m^2.
        """
        return _Box2D.b2Body___GetInertia(self)


    def GetMassData(self, data):
        """
        GetMassData(b2Body self, b2MassData data)

        Get the mass data of the body. 
        a struct containing the mass, inertia and center of the body.
        """
        return _Box2D.b2Body_GetMassData(self, data)


    def __SetMassData(self, data):
        """
        __SetMassData(b2Body self, b2MassData data)

        Set the mass properties to override the mass properties of the fixtures. Note that this changes the center of mass position. Note that creating or destroying fixtures can also alter the mass. This function has no effect if the body isn't dynamic.

        Parameters:
        -----------

        massData: 
        the mass properties.
        """
        return _Box2D.b2Body___SetMassData(self, data)


    def ResetMassData(self):
        """
        ResetMassData(b2Body self)

        This resets the mass properties to the sum of the mass properties of the fixtures. This normally does not need to be called unless you called SetMassData to override the mass and you later want to reset the mass.
        """
        return _Box2D.b2Body_ResetMassData(self)


    def GetWorldPoint(self, localPoint):
        """
        GetWorldPoint(b2Body self, b2Vec2 localPoint) -> b2Vec2

        Get the world coordinates of a point given the local coordinates.

        Parameters:
        -----------

        localPoint: 
        a point on the body measured relative the the body's origin. 
        the same point expressed in world coordinates.
        """
        return _Box2D.b2Body_GetWorldPoint(self, localPoint)


    def GetWorldVector(self, localVector):
        """
        GetWorldVector(b2Body self, b2Vec2 localVector) -> b2Vec2

        Get the world coordinates of a vector given the local coordinates.

        Parameters:
        -----------

        localVector: 
        a vector fixed in the body. 
        the same vector expressed in world coordinates.
        """
        return _Box2D.b2Body_GetWorldVector(self, localVector)


    def GetLocalPoint(self, worldPoint):
        """
        GetLocalPoint(b2Body self, b2Vec2 worldPoint) -> b2Vec2

        Gets a local point relative to the body's origin given a world point.

        Parameters:
        -----------

        a: 
        point in world coordinates. 
        the corresponding local point relative to the body's origin.
        """
        return _Box2D.b2Body_GetLocalPoint(self, worldPoint)


    def GetLocalVector(self, worldVector):
        """
        GetLocalVector(b2Body self, b2Vec2 worldVector) -> b2Vec2

        Gets a local vector given a world vector.

        Parameters:
        -----------

        a: 
        vector in world coordinates. 
        the corresponding local vector.
        """
        return _Box2D.b2Body_GetLocalVector(self, worldVector)


    def GetLinearVelocityFromWorldPoint(self, worldPoint):
        """
        GetLinearVelocityFromWorldPoint(b2Body self, b2Vec2 worldPoint) -> b2Vec2

        Get the world linear velocity of a world point attached to this body.

        Parameters:
        -----------

        a: 
        point in world coordinates. 
        the world velocity of a point.
        """
        return _Box2D.b2Body_GetLinearVelocityFromWorldPoint(self, worldPoint)


    def GetLinearVelocityFromLocalPoint(self, localPoint):
        """
        GetLinearVelocityFromLocalPoint(b2Body self, b2Vec2 localPoint) -> b2Vec2

        Get the world velocity of a local point.

        Parameters:
        -----------

        a: 
        point in local coordinates. 
        the world velocity of a point.
        """
        return _Box2D.b2Body_GetLinearVelocityFromLocalPoint(self, localPoint)


    def __GetLinearDamping(self):
        """
        __GetLinearDamping(b2Body self) -> float32

        Get the linear damping of the body.
        """
        return _Box2D.b2Body___GetLinearDamping(self)


    def __SetLinearDamping(self, linearDamping):
        """
        __SetLinearDamping(b2Body self, float32 linearDamping)

        Set the linear damping of the body.
        """
        return _Box2D.b2Body___SetLinearDamping(self, linearDamping)


    def __GetAngularDamping(self):
        """
        __GetAngularDamping(b2Body self) -> float32

        Get the angular damping of the body.
        """
        return _Box2D.b2Body___GetAngularDamping(self)


    def __SetAngularDamping(self, angularDamping):
        """
        __SetAngularDamping(b2Body self, float32 angularDamping)

        Set the angular damping of the body.
        """
        return _Box2D.b2Body___SetAngularDamping(self, angularDamping)


    def __GetGravityScale(self):
        """__GetGravityScale(b2Body self) -> float32"""
        return _Box2D.b2Body___GetGravityScale(self)


    def __SetGravityScale(self, scale):
        """__SetGravityScale(b2Body self, float32 scale)"""
        return _Box2D.b2Body___SetGravityScale(self, scale)


    def __SetType(self, type):
        """
        __SetType(b2Body self, b2BodyType type)

        Set the type of this body. This may alter the mass and velocity.
        """
        return _Box2D.b2Body___SetType(self, type)


    def __GetType(self):
        """
        __GetType(b2Body self) -> b2BodyType

        Get the type of this body.
        """
        return _Box2D.b2Body___GetType(self)


    def __SetBullet(self, flag):
        """
        __SetBullet(b2Body self, bool flag)

        Should this body be treated like a bullet for continuous collision detection?
        """
        return _Box2D.b2Body___SetBullet(self, flag)


    def __IsBullet(self):
        """
        __IsBullet(b2Body self) -> bool

        Is this body treated like a bullet for continuous collision detection?
        """
        return _Box2D.b2Body___IsBullet(self)


    def __SetSleepingAllowed(self, flag):
        """
        __SetSleepingAllowed(b2Body self, bool flag)

        You can disable sleeping on this body. If you disable sleeping, the body will be woken.
        """
        return _Box2D.b2Body___SetSleepingAllowed(self, flag)


    def __IsSleepingAllowed(self):
        """
        __IsSleepingAllowed(b2Body self) -> bool

        Is this body allowed to sleep.
        """
        return _Box2D.b2Body___IsSleepingAllowed(self)


    def __SetAwake(self, flag):
        """
        __SetAwake(b2Body self, bool flag)

        Set the sleep state of the body. A sleeping body has very low CPU cost.

        Parameters:
        -----------

        flag: 
        set to true to put body to sleep, false to wake it.
        """
        return _Box2D.b2Body___SetAwake(self, flag)


    def __IsAwake(self):
        """
        __IsAwake(b2Body self) -> bool

        Get the sleeping state of this body. 
        true if the body is sleeping.
        """
        return _Box2D.b2Body___IsAwake(self)


    def __SetActive(self, flag):
        """
        __SetActive(b2Body self, bool flag)

        Set the active state of the body. An inactive body is not simulated and cannot be collided with or woken up. If you pass a flag of true, all fixtures will be added to the broad-phase. If you pass a flag of false, all fixtures will be removed from the broad-phase and all contacts will be destroyed. Fixtures and joints are otherwise unaffected. You may continue to create/destroy fixtures and joints on inactive bodies. Fixtures on an inactive body are implicitly inactive and will not participate in collisions, ray-casts, or queries. Joints connected to an inactive body are implicitly inactive. An inactive body is still owned by a  b2Worldobject and remains in the body list.
        """
        return _Box2D.b2Body___SetActive(self, flag)


    def __IsActive(self):
        """
        __IsActive(b2Body self) -> bool

        Get the active state of the body.
        """
        return _Box2D.b2Body___IsActive(self)


    def __SetFixedRotation(self, flag):
        """
        __SetFixedRotation(b2Body self, bool flag)

        Set this body to have fixed rotation. This causes the mass to be reset.
        """
        return _Box2D.b2Body___SetFixedRotation(self, flag)


    def __IsFixedRotation(self):
        """
        __IsFixedRotation(b2Body self) -> bool

        Does this body have fixed rotation?
        """
        return _Box2D.b2Body___IsFixedRotation(self)


    def __GetFixtureList_internal(self, *args):
        """
        __GetFixtureList_internal(b2Body self) -> b2Fixture
        __GetFixtureList_internal(b2Body self) -> b2Fixture

        Get the list of all fixtures attached to this body.
        """
        return _Box2D.b2Body___GetFixtureList_internal(self, *args)


    def __GetJointList_internal(self, *args):
        """
        __GetJointList_internal(b2Body self) -> b2JointEdge
        __GetJointList_internal(b2Body self) -> b2JointEdge

        Get the list of all joints attached to this body.
        """
        return _Box2D.b2Body___GetJointList_internal(self, *args)


    def __GetContactList_internal(self, *args):
        """
        __GetContactList_internal(b2Body self) -> b2ContactEdge
        __GetContactList_internal(b2Body self) -> b2ContactEdge

        Get the list of all contacts attached to this body. 
        WARNING: 
        this list changes during the time step and you may miss some collisions if you don't use  b2ContactListener.
        """
        return _Box2D.b2Body___GetContactList_internal(self, *args)


    def __GetNext(self, *args):
        """
        __GetNext(b2Body self) -> b2Body
        __GetNext(b2Body self) -> b2Body

        Get the next body in the world's body list.
        """
        return _Box2D.b2Body___GetNext(self, *args)


    def __GetWorld(self, *args):
        """
        __GetWorld(b2Body self) -> b2World
        __GetWorld(b2Body self) -> b2World

        Get the parent world of this body.
        """
        return _Box2D.b2Body___GetWorld(self, *args)


    def Dump(self):
        """Dump(b2Body self)"""
        return _Box2D.b2Body_Dump(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Body self) -> long"""
        return _Box2D.b2Body___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def DestroyFixture(self, fixture):
        """
        DestroyFixture(b2Body self, b2Fixture fixture)

        Destroy a fixture. This removes the fixture from the broad-phase and destroys all contacts associated with this fixture. This will automatically adjust the mass of the body if the body is dynamic and the fixture has positive density. All fixtures attached to a body are implicitly destroyed when the body is destroyed.

        Parameters:
        -----------

        fixture: 
        the fixture to be removed.

        WARNING: 
        This function is locked during callbacks.
        """
        return _Box2D.b2Body_DestroyFixture(self, fixture)


    def __CreateFixture(self, *args):
        """
        __CreateFixture(b2Body self, b2Shape shape, float32 density) -> b2Fixture
        __CreateFixture(b2Body self, b2FixtureDef defn) -> b2Fixture
        """
        return _Box2D.b2Body___CreateFixture(self, *args)


    def __GetUserData(self):
        """__GetUserData(b2Body self) -> PyObject *"""
        return _Box2D.b2Body___GetUserData(self)


    def __SetUserData(self, data):
        """__SetUserData(b2Body self, PyObject * data)"""
        return _Box2D.b2Body___SetUserData(self, data)


    def ClearUserData(self):
        """ClearUserData(b2Body self)"""
        return _Box2D.b2Body_ClearUserData(self)


    userData = property(__GetUserData, __SetUserData)


    __eq__ = b2BodyCompare
    __ne__ = lambda self,other: not b2BodyCompare(self,other)
    def __GetMassData(self):
        """
        Get a b2MassData object that represents this b2Body

        NOTE: To just get the mass, use body.mass
        """
        ret = b2MassData()
        ret.center=self.localCenter
        ret.I    = self.inertia
        ret.mass = self.mass
        return ret

    def __SetInertia(self, inertia):
        """
        Set the body's inertia
        """
        md = self.massData
        md.I = inertia
        self.massData=md

    def __SetMass(self, mass):
        """
        Set the body's mass
        """
        md = self.massData
        md.mass = mass
        self.massData=md

    def __SetLocalCenter(self, lcenter):
        """
        Set the body's local center
        """
        md = self.massData
        md.center = lcenter
        self.massData=md

    def __iter__(self):
        """
        Iterates over the fixtures in the body
        """
        for fixture in self.fixtures:
            yield fixture

    def __CreateShapeFixture(self, type_, **kwargs):
        """
        Internal function to handle creating circles, polygons, etc.
        without first creating a fixture. type_ is b2Shape.
        """
        shape=type_()
        fixture=b2FixtureDef(shape=shape)

        for key, value in kwargs.items():
    # Note that these hasattrs use the types to get around
    # the fact that some properties are write-only (like 'box' in
    # polygon shapes), and as such do not show up with 'hasattr'.
            if hasattr(type_, key):
                to_set=shape
            elif hasattr(b2FixtureDef, key):
                to_set=fixture
            else:
                raise AttributeError('Property %s not found in either %s or b2FixtureDef' % (key, type_.__name__))

            try:
                setattr(to_set, key, value)
            except Exception as ex:
                raise ex.__class__('Failed on kwargs, class="%s" key="%s": %s' \
                            % (to_set.__class__.__name__, key, ex))

        return self.CreateFixture(fixture)

    def CreatePolygonFixture(self, **kwargs):
        """
        Create a polygon shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the polygon
        or the fixture to this function. For example:
        CreatePolygonFixture(box=(1, 1), friction=0.2, density=1.0)
        where 'box' is a property from the polygon shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2PolygonShape, **kwargs)

    def CreateCircleFixture(self, **kwargs):
        """
        Create a circle shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the circle
        or the fixture to this function. For example:
        CreateCircleFixture(radius=0.2, friction=0.2, density=1.0)
        where 'radius' is a property from the circle shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2CircleShape, **kwargs)

    def CreateEdgeFixture(self, **kwargs):
        """
        Create a edge shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the edge
        or the fixture to this function. For example:
        CreateEdgeFixture(vertices=[(0,0),(1,0)], friction=0.2, density=1.0)
        where 'vertices' is a property from the edge shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2EdgeShape, **kwargs)

    def CreateLoopFixture(self, **kwargs):
        """
        Create a loop shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the loop
        or the fixture to this function. For example:
        CreateLoopFixture(vertices=[...], friction=0.2, density=1.0)
        where 'vertices' is a property from the loop shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2ChainShape, **kwargs)

    CreateChainFixture = CreateLoopFixture

    def CreateFixturesFromShapes(self, shapes=None, shapeFixture=None):
        """
        Create fixture(s) on the body from one or more shapes, and optionally a single
        fixture definition.

        Takes kwargs; examples of valid combinations are as follows:
        CreateFixturesFromShapes(shapes=b2CircleShape(radius=0.2))
        CreateFixturesFromShapes(shapes=b2CircleShape(radius=0.2), shapeFixture=b2FixtureDef(friction=0.2))
        CreateFixturesFromShapes(shapes=[b2CircleShape(radius=0.2), b2PolygonShape(box=[1,2])])
        """
        if shapes==None:
            raise TypeError('At least one shape required')

        if shapeFixture==None:
            shapeFixture=b2FixtureDef()
            oldShape=None
        else:
            oldShape = shapeFixture.shape

        ret=None
        try:
            if isinstance(shapes, (list, tuple)):
                ret = []
                for shape in shapes:
                    shapeFixture.shape = shape
                    ret.append(self.__CreateFixture(shapeFixture))
            else:
                shapeFixture.shape=shapes
                ret = self.__CreateFixture(shapeFixture)
        finally:
            shapeFixture.shape=oldShape

        return ret

    def CreateFixture(self, defn=None, **kwargs):
        """
        Create a fixtures on the body.

        Takes kwargs; examples of valid combinations are as follows:
        CreateFixture(b2FixtureDef(shape=s, restitution=0.2, ...))
        CreateFixture(shape=s, restitution=0.2, ...)
        """
        if defn is not None and isinstance(defn, b2FixtureDef):
            return self.__CreateFixture(defn)
        else:
            if 'shape' not in kwargs:
                raise ValueError('Must specify the shape for the fixture')
            return self.__CreateFixture(b2FixtureDef(**kwargs))

    def CreateEdgeChain(self, edge_list):
        """
        Creates a body a set of connected edge chains.
        Expects edge_list to be a list of vertices, length >= 2.
        """
        prev=None
        if len(edge_list) < 2:
            raise ValueError('Edge list length >= 2')

        shape=b2EdgeShape(vertices=[list(i) for i in edge_list[0:2]])
        self.CreateFixturesFromShapes(shape)

        prev = edge_list[1]
        for edge in edge_list[1:]:
            if len(edge) != 2:
                raise ValueError('Vertex length != 2, "%s"' % list(edge))
            shape.vertices = [list(prev), list(edge)]
            self.CreateFixturesFromShapes(shape)
            prev=edge

    # Read-write properties
    sleepingAllowed = property(__IsSleepingAllowed, __SetSleepingAllowed)
    angularVelocity = property(__GetAngularVelocity, __SetAngularVelocity)
    linearVelocity = property(__GetLinearVelocity, __SetLinearVelocity)
    awake = property(__IsAwake, __SetAwake)
    angularDamping = property(__GetAngularDamping, __SetAngularDamping)
    fixedRotation = property(__IsFixedRotation, __SetFixedRotation)
    linearDamping = property(__GetLinearDamping, __SetLinearDamping)
    bullet = property(__IsBullet, __SetBullet)
    type = property(__GetType, __SetType)
    active = property(__IsActive, __SetActive)
    angle = property(__GetAngle, lambda self, angle: self.__SetTransform(self.position, angle))
    transform = property(__GetTransform, lambda self, value: self.__SetTransform(*value))
    massData = property(__GetMassData, __SetMassData)
    mass = property(__GetMass, __SetMass)
    localCenter = property(__GetLocalCenter, __SetLocalCenter)
    inertia = property(__GetInertia, __SetInertia)
    position = property(__GetPosition, lambda self, pos: self.__SetTransform(pos, self.angle))
    gravityScale = property(__GetGravityScale, __SetGravityScale)

    # Read-only
    joints = property(lambda self: _list_from_linked_list(self.__GetJointList_internal()), None, 
                        doc="""All joints connected to the body as a list. 
                        NOTE: This re-creates the list on every call. See also joints_gen.""")
    contacts = property(lambda self: _list_from_linked_list(self.__GetContactList_internal()), None,
                        doc="""All contacts related to the body as a list. 
                        NOTE: This re-creates the list on every call. See also contacts_gen.""")
    fixtures = property(lambda self: _list_from_linked_list(self.__GetFixtureList_internal()), None,
                        doc="""All fixtures contained in this body as a list. 
                        NOTE: This re-creates the list on every call. See also fixtures_gen.""")
    joints_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetJointList_internal())), None,
                        doc="""Indexable generator of the connected joints to this body.
                        NOTE: When not using the whole list, this may be preferable to using 'joints'.""")
    contacts_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetContactList_internal())), None,
                        doc="""Indexable generator of the related contacts.
                        NOTE: When not using the whole list, this may be preferable to using 'contacts'.""")
    fixtures_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetFixtureList_internal())), None,
                        doc="""Indexable generator of the contained fixtures.
                        NOTE: When not using the whole list, this may be preferable to using 'fixtures'.""")
    next = property(__GetNext, None)
    worldCenter = property(__GetWorldCenter, None)
    world = property(__GetWorld, None)


b2Body.__SetTransform = new_instancemethod(_Box2D.b2Body___SetTransform, None, b2Body)
b2Body.__GetTransform = new_instancemethod(_Box2D.b2Body___GetTransform, None, b2Body)
b2Body.__GetPosition = new_instancemethod(_Box2D.b2Body___GetPosition, None, b2Body)
b2Body.__GetAngle = new_instancemethod(_Box2D.b2Body___GetAngle, None, b2Body)
b2Body.__GetWorldCenter = new_instancemethod(_Box2D.b2Body___GetWorldCenter, None, b2Body)
b2Body.__GetLocalCenter = new_instancemethod(_Box2D.b2Body___GetLocalCenter, None, b2Body)
b2Body.__SetLinearVelocity = new_instancemethod(_Box2D.b2Body___SetLinearVelocity, None, b2Body)
b2Body.__GetLinearVelocity = new_instancemethod(_Box2D.b2Body___GetLinearVelocity, None, b2Body)
b2Body.__SetAngularVelocity = new_instancemethod(_Box2D.b2Body___SetAngularVelocity, None, b2Body)
b2Body.__GetAngularVelocity = new_instancemethod(_Box2D.b2Body___GetAngularVelocity, None, b2Body)
b2Body.ApplyForce = new_instancemethod(_Box2D.b2Body_ApplyForce, None, b2Body)
b2Body.ApplyForceToCenter = new_instancemethod(_Box2D.b2Body_ApplyForceToCenter, None, b2Body)
b2Body.ApplyTorque = new_instancemethod(_Box2D.b2Body_ApplyTorque, None, b2Body)
b2Body.ApplyLinearImpulse = new_instancemethod(_Box2D.b2Body_ApplyLinearImpulse, None, b2Body)
b2Body.ApplyAngularImpulse = new_instancemethod(_Box2D.b2Body_ApplyAngularImpulse, None, b2Body)
b2Body.__GetMass = new_instancemethod(_Box2D.b2Body___GetMass, None, b2Body)
b2Body.__GetInertia = new_instancemethod(_Box2D.b2Body___GetInertia, None, b2Body)
b2Body.GetMassData = new_instancemethod(_Box2D.b2Body_GetMassData, None, b2Body)
b2Body.__SetMassData = new_instancemethod(_Box2D.b2Body___SetMassData, None, b2Body)
b2Body.ResetMassData = new_instancemethod(_Box2D.b2Body_ResetMassData, None, b2Body)
b2Body.GetWorldPoint = new_instancemethod(_Box2D.b2Body_GetWorldPoint, None, b2Body)
b2Body.GetWorldVector = new_instancemethod(_Box2D.b2Body_GetWorldVector, None, b2Body)
b2Body.GetLocalPoint = new_instancemethod(_Box2D.b2Body_GetLocalPoint, None, b2Body)
b2Body.GetLocalVector = new_instancemethod(_Box2D.b2Body_GetLocalVector, None, b2Body)
b2Body.GetLinearVelocityFromWorldPoint = new_instancemethod(_Box2D.b2Body_GetLinearVelocityFromWorldPoint, None, b2Body)
b2Body.GetLinearVelocityFromLocalPoint = new_instancemethod(_Box2D.b2Body_GetLinearVelocityFromLocalPoint, None, b2Body)
b2Body.__GetLinearDamping = new_instancemethod(_Box2D.b2Body___GetLinearDamping, None, b2Body)
b2Body.__SetLinearDamping = new_instancemethod(_Box2D.b2Body___SetLinearDamping, None, b2Body)
b2Body.__GetAngularDamping = new_instancemethod(_Box2D.b2Body___GetAngularDamping, None, b2Body)
b2Body.__SetAngularDamping = new_instancemethod(_Box2D.b2Body___SetAngularDamping, None, b2Body)
b2Body.__GetGravityScale = new_instancemethod(_Box2D.b2Body___GetGravityScale, None, b2Body)
b2Body.__SetGravityScale = new_instancemethod(_Box2D.b2Body___SetGravityScale, None, b2Body)
b2Body.__SetType = new_instancemethod(_Box2D.b2Body___SetType, None, b2Body)
b2Body.__GetType = new_instancemethod(_Box2D.b2Body___GetType, None, b2Body)
b2Body.__SetBullet = new_instancemethod(_Box2D.b2Body___SetBullet, None, b2Body)
b2Body.__IsBullet = new_instancemethod(_Box2D.b2Body___IsBullet, None, b2Body)
b2Body.__SetSleepingAllowed = new_instancemethod(_Box2D.b2Body___SetSleepingAllowed, None, b2Body)
b2Body.__IsSleepingAllowed = new_instancemethod(_Box2D.b2Body___IsSleepingAllowed, None, b2Body)
b2Body.__SetAwake = new_instancemethod(_Box2D.b2Body___SetAwake, None, b2Body)
b2Body.__IsAwake = new_instancemethod(_Box2D.b2Body___IsAwake, None, b2Body)
b2Body.__SetActive = new_instancemethod(_Box2D.b2Body___SetActive, None, b2Body)
b2Body.__IsActive = new_instancemethod(_Box2D.b2Body___IsActive, None, b2Body)
b2Body.__SetFixedRotation = new_instancemethod(_Box2D.b2Body___SetFixedRotation, None, b2Body)
b2Body.__IsFixedRotation = new_instancemethod(_Box2D.b2Body___IsFixedRotation, None, b2Body)
b2Body.__GetFixtureList_internal = new_instancemethod(_Box2D.b2Body___GetFixtureList_internal, None, b2Body)
b2Body.__GetJointList_internal = new_instancemethod(_Box2D.b2Body___GetJointList_internal, None, b2Body)
b2Body.__GetContactList_internal = new_instancemethod(_Box2D.b2Body___GetContactList_internal, None, b2Body)
b2Body.__GetNext = new_instancemethod(_Box2D.b2Body___GetNext, None, b2Body)
b2Body.__GetWorld = new_instancemethod(_Box2D.b2Body___GetWorld, None, b2Body)
b2Body.Dump = new_instancemethod(_Box2D.b2Body_Dump, None, b2Body)
b2Body.__hash__ = new_instancemethod(_Box2D.b2Body___hash__, None, b2Body)
b2Body.DestroyFixture = new_instancemethod(_Box2D.b2Body_DestroyFixture, None, b2Body)
b2Body.__CreateFixture = new_instancemethod(_Box2D.b2Body___CreateFixture, None, b2Body)
b2Body.__GetUserData = new_instancemethod(_Box2D.b2Body___GetUserData, None, b2Body)
b2Body.__SetUserData = new_instancemethod(_Box2D.b2Body___SetUserData, None, b2Body)
b2Body.ClearUserData = new_instancemethod(_Box2D.b2Body_ClearUserData, None, b2Body)
b2Body_swigregister = _Box2D.b2Body_swigregister
b2Body_swigregister(b2Body)

class b2Filter(object):
    """This holds contact filtering data."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2Filter_swiginit(self,_Box2D.new_b2Filter())
        _init_kwargs(self, **kwargs)


    categoryBits = _swig_property(_Box2D.b2Filter_categoryBits_get, _Box2D.b2Filter_categoryBits_set)
    maskBits = _swig_property(_Box2D.b2Filter_maskBits_get, _Box2D.b2Filter_maskBits_set)
    groupIndex = _swig_property(_Box2D.b2Filter_groupIndex_get, _Box2D.b2Filter_groupIndex_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Filter self) -> long"""
        return _Box2D.b2Filter___hash__(self)


    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2Filter
b2Filter.__hash__ = new_instancemethod(_Box2D.b2Filter___hash__, None, b2Filter)
b2Filter_swigregister = _Box2D.b2Filter_swigregister
b2Filter_swigregister(b2Filter)

class b2FixtureDef(object):
    """A fixture definition is used to create a fixture. This class defines an abstract fixture definition. You can reuse fixture definitions safely."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2FixtureDef_swiginit(self,_Box2D.new_b2FixtureDef())
        _init_kwargs(self, **kwargs)


    shape = _swig_property(_Box2D.b2FixtureDef_shape_get, _Box2D.b2FixtureDef_shape_set)
    friction = _swig_property(_Box2D.b2FixtureDef_friction_get, _Box2D.b2FixtureDef_friction_set)
    restitution = _swig_property(_Box2D.b2FixtureDef_restitution_get, _Box2D.b2FixtureDef_restitution_set)
    density = _swig_property(_Box2D.b2FixtureDef_density_get, _Box2D.b2FixtureDef_density_set)
    isSensor = _swig_property(_Box2D.b2FixtureDef_isSensor_get, _Box2D.b2FixtureDef_isSensor_set)
    filter = _swig_property(_Box2D.b2FixtureDef_filter_get, _Box2D.b2FixtureDef_filter_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2FixtureDef self) -> long"""
        return _Box2D.b2FixtureDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __GetUserData(self):
        """__GetUserData(b2FixtureDef self) -> PyObject *"""
        return _Box2D.b2FixtureDef___GetUserData(self)


    def __SetUserData(self, data):
        """__SetUserData(b2FixtureDef self, PyObject * data)"""
        return _Box2D.b2FixtureDef___SetUserData(self, data)


    def ClearUserData(self):
        """ClearUserData(b2FixtureDef self)"""
        return _Box2D.b2FixtureDef_ClearUserData(self)


    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()


    def __SetCategoryBits(self, value):
        self.filter.categoryBits=value
    def __SetGroupIndex(self, value):
        self.filter.groupIndex=value
    def __SetMaskBits(self, value):
        self.filter.maskBits=value

    categoryBits=property(lambda self: self.filter.categoryBits, __SetCategoryBits)
    groupIndex=property(lambda self: self.filter.groupIndex, __SetGroupIndex)
    maskBits=property(lambda self: self.filter.maskBits, __SetMaskBits)

    __swig_destroy__ = _Box2D.delete_b2FixtureDef
b2FixtureDef.__hash__ = new_instancemethod(_Box2D.b2FixtureDef___hash__, None, b2FixtureDef)
b2FixtureDef.__GetUserData = new_instancemethod(_Box2D.b2FixtureDef___GetUserData, None, b2FixtureDef)
b2FixtureDef.__SetUserData = new_instancemethod(_Box2D.b2FixtureDef___SetUserData, None, b2FixtureDef)
b2FixtureDef.ClearUserData = new_instancemethod(_Box2D.b2FixtureDef_ClearUserData, None, b2FixtureDef)
b2FixtureDef_swigregister = _Box2D.b2FixtureDef_swigregister
b2FixtureDef_swigregister(b2FixtureDef)

class b2FixtureProxy(object):
    """This proxy is used internally to connect fixtures to the broad-phase."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    aabb = _swig_property(_Box2D.b2FixtureProxy_aabb_get, _Box2D.b2FixtureProxy_aabb_set)
    fixture = _swig_property(_Box2D.b2FixtureProxy_fixture_get, _Box2D.b2FixtureProxy_fixture_set)
    childIndex = _swig_property(_Box2D.b2FixtureProxy_childIndex_get, _Box2D.b2FixtureProxy_childIndex_set)
    proxyId = _swig_property(_Box2D.b2FixtureProxy_proxyId_get, _Box2D.b2FixtureProxy_proxyId_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2FixtureProxy self) -> long"""
        return _Box2D.b2FixtureProxy___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        """
        __init__(b2FixtureProxy self) -> b2FixtureProxy

        This proxy is used internally to connect fixtures to the broad-phase.
        """
        _Box2D.b2FixtureProxy_swiginit(self, _Box2D.new_b2FixtureProxy())
    __swig_destroy__ = _Box2D.delete_b2FixtureProxy
b2FixtureProxy.__hash__ = new_instancemethod(_Box2D.b2FixtureProxy___hash__, None, b2FixtureProxy)
b2FixtureProxy_swigregister = _Box2D.b2FixtureProxy_swigregister
b2FixtureProxy_swigregister(b2FixtureProxy)

class b2Fixture(object):
    """
    A fixture is used to attach a shape to a body for collision detection. A fixture inherits its transform from its parent. Fixtures hold additional non-geometric data such as friction, collision filters, etc. Fixtures are created via  b2Body::CreateFixture. 
    WARNING: 
    you cannot reuse fixtures.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __GetType(self):
        """
        __GetType(b2Fixture self) -> b2Shape::Type

        Get the type of the child shape. You can use this to down cast to the concrete shape. 
        the shape type.
        """
        return _Box2D.b2Fixture___GetType(self)


    def __GetShape(self, *args):
        """
        __GetShape(b2Fixture self) -> b2Shape
        __GetShape(b2Fixture self) -> b2Shape

        Get the child shape. You can modify the child shape, however you should not change the number of vertices because this will crash some collision caching mechanisms. Manipulating the shape may lead to non-physical behavior.
        """
        return _Box2D.b2Fixture___GetShape(self, *args)


    def __SetSensor(self, sensor):
        """
        __SetSensor(b2Fixture self, bool sensor)

        Set if this fixture is a sensor.
        """
        return _Box2D.b2Fixture___SetSensor(self, sensor)


    def __IsSensor(self):
        """
        __IsSensor(b2Fixture self) -> bool

        Is this fixture a sensor (non-solid)? 
        the true if the shape is a sensor.
        """
        return _Box2D.b2Fixture___IsSensor(self)


    def __SetFilterData(self, filter):
        """
        __SetFilterData(b2Fixture self, b2Filter filter)

        Set the contact filtering data. This will not update contacts until the next time step when either parent body is active and awake. This automatically calls Refilter.
        """
        return _Box2D.b2Fixture___SetFilterData(self, filter)


    def __GetFilterData(self):
        """
        __GetFilterData(b2Fixture self) -> b2Filter

        Get the contact filtering data.
        """
        return _Box2D.b2Fixture___GetFilterData(self)


    def Refilter(self):
        """
        Refilter(b2Fixture self)

        Call this if you want to establish collision that was previously disabled by  b2ContactFilter::ShouldCollide.
        """
        return _Box2D.b2Fixture_Refilter(self)


    def __GetBody(self, *args):
        """
        __GetBody(b2Fixture self) -> b2Body
        __GetBody(b2Fixture self) -> b2Body

        Get the parent body of this fixture. This is NULL if the fixture is not attached. 
        the parent body.
        """
        return _Box2D.b2Fixture___GetBody(self, *args)


    def __GetNext(self, *args):
        """
        __GetNext(b2Fixture self) -> b2Fixture
        __GetNext(b2Fixture self) -> b2Fixture

        Get the next fixture in the parent body's fixture list. 
        the next shape.
        """
        return _Box2D.b2Fixture___GetNext(self, *args)


    def TestPoint(self, p):
        """
        TestPoint(b2Fixture self, b2Vec2 p) -> bool

        Test a point for containment in this fixture.

        Parameters:
        -----------

        p: 
        a point in world coordinates.
        """
        return _Box2D.b2Fixture_TestPoint(self, p)


    def RayCast(self, output, input, childIndex):
        """
        RayCast(b2Fixture self, b2RayCastOutput output, b2RayCastInput input, int32 childIndex) -> bool

        Cast a ray against this shape.

        Parameters:
        -----------

        output: 
        the ray-cast results.

        input: 
        the ray-cast input parameters.
        """
        return _Box2D.b2Fixture_RayCast(self, output, input, childIndex)


    def __GetMassData(self, massData):
        """
        __GetMassData(b2Fixture self, b2MassData massData)

        Get the mass data for this fixture. The mass data is based on the density and the shape. The rotational inertia is about the shape's origin. This operation may be expensive.
        """
        return _Box2D.b2Fixture___GetMassData(self, massData)


    def __SetDensity(self, density):
        """
        __SetDensity(b2Fixture self, float32 density)

        Set the density of this fixture. This will _not_ automatically adjust the mass of the body. You must call  b2Body::ResetMassDatato update the body's mass.
        """
        return _Box2D.b2Fixture___SetDensity(self, density)


    def __GetDensity(self):
        """
        __GetDensity(b2Fixture self) -> float32

        Get the density of this fixture.
        """
        return _Box2D.b2Fixture___GetDensity(self)


    def __GetFriction(self):
        """
        __GetFriction(b2Fixture self) -> float32

        Get the coefficient of friction.
        """
        return _Box2D.b2Fixture___GetFriction(self)


    def __SetFriction(self, friction):
        """
        __SetFriction(b2Fixture self, float32 friction)

        Set the coefficient of friction. This will immediately update the mixed friction on all associated contacts.
        """
        return _Box2D.b2Fixture___SetFriction(self, friction)


    def __GetRestitution(self):
        """
        __GetRestitution(b2Fixture self) -> float32

        Get the coefficient of restitution.
        """
        return _Box2D.b2Fixture___GetRestitution(self)


    def __SetRestitution(self, restitution):
        """
        __SetRestitution(b2Fixture self, float32 restitution)

        Set the coefficient of restitution. This will immediately update the mixed restitution on all associated contacts.
        """
        return _Box2D.b2Fixture___SetRestitution(self, restitution)


    def GetAABB(self, childIndex):
        """
        GetAABB(b2Fixture self, int32 childIndex) -> b2AABB

        Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a more accurate AABB, compute it using the shape and the body transform.
        """
        return _Box2D.b2Fixture_GetAABB(self, childIndex)


    def Dump(self, bodyIndex):
        """Dump(b2Fixture self, int32 bodyIndex)"""
        return _Box2D.b2Fixture_Dump(self, bodyIndex)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Fixture self) -> long"""
        return _Box2D.b2Fixture___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __GetUserData(self):
        """__GetUserData(b2Fixture self) -> PyObject *"""
        return _Box2D.b2Fixture___GetUserData(self)


    def __SetUserData(self, data):
        """__SetUserData(b2Fixture self, PyObject * data)"""
        return _Box2D.b2Fixture___SetUserData(self, data)


    def ClearUserData(self):
        """ClearUserData(b2Fixture self)"""
        return _Box2D.b2Fixture_ClearUserData(self)


    userData = property(__GetUserData, __SetUserData)

    __swig_destroy__ = _Box2D.delete_b2Fixture

    __eq__ = b2FixtureCompare
    __ne__ = lambda self,other: not b2FixtureCompare(self,other)

    # Read-write properties
    friction = property(__GetFriction, __SetFriction)
    restitution = property(__GetRestitution, __SetRestitution)
    filterData = property(__GetFilterData, __SetFilterData)
    sensor = property(__IsSensor, __SetSensor)
    density = property(__GetDensity, __SetDensity)

    # Read-only
    next = property(__GetNext, None)
    type = property(__GetType, None)
    shape = property(__GetShape, None)
    body = property(__GetBody, None)

    @property
    def massData(self):
        md=b2MassData()
        self.__GetMassData(md)
        return md

b2Fixture.__GetType = new_instancemethod(_Box2D.b2Fixture___GetType, None, b2Fixture)
b2Fixture.__GetShape = new_instancemethod(_Box2D.b2Fixture___GetShape, None, b2Fixture)
b2Fixture.__SetSensor = new_instancemethod(_Box2D.b2Fixture___SetSensor, None, b2Fixture)
b2Fixture.__IsSensor = new_instancemethod(_Box2D.b2Fixture___IsSensor, None, b2Fixture)
b2Fixture.__SetFilterData = new_instancemethod(_Box2D.b2Fixture___SetFilterData, None, b2Fixture)
b2Fixture.__GetFilterData = new_instancemethod(_Box2D.b2Fixture___GetFilterData, None, b2Fixture)
b2Fixture.Refilter = new_instancemethod(_Box2D.b2Fixture_Refilter, None, b2Fixture)
b2Fixture.__GetBody = new_instancemethod(_Box2D.b2Fixture___GetBody, None, b2Fixture)
b2Fixture.__GetNext = new_instancemethod(_Box2D.b2Fixture___GetNext, None, b2Fixture)
b2Fixture.TestPoint = new_instancemethod(_Box2D.b2Fixture_TestPoint, None, b2Fixture)
b2Fixture.RayCast = new_instancemethod(_Box2D.b2Fixture_RayCast, None, b2Fixture)
b2Fixture.__GetMassData = new_instancemethod(_Box2D.b2Fixture___GetMassData, None, b2Fixture)
b2Fixture.__SetDensity = new_instancemethod(_Box2D.b2Fixture___SetDensity, None, b2Fixture)
b2Fixture.__GetDensity = new_instancemethod(_Box2D.b2Fixture___GetDensity, None, b2Fixture)
b2Fixture.__GetFriction = new_instancemethod(_Box2D.b2Fixture___GetFriction, None, b2Fixture)
b2Fixture.__SetFriction = new_instancemethod(_Box2D.b2Fixture___SetFriction, None, b2Fixture)
b2Fixture.__GetRestitution = new_instancemethod(_Box2D.b2Fixture___GetRestitution, None, b2Fixture)
b2Fixture.__SetRestitution = new_instancemethod(_Box2D.b2Fixture___SetRestitution, None, b2Fixture)
b2Fixture.GetAABB = new_instancemethod(_Box2D.b2Fixture_GetAABB, None, b2Fixture)
b2Fixture.Dump = new_instancemethod(_Box2D.b2Fixture_Dump, None, b2Fixture)
b2Fixture.__hash__ = new_instancemethod(_Box2D.b2Fixture___hash__, None, b2Fixture)
b2Fixture.__GetUserData = new_instancemethod(_Box2D.b2Fixture___GetUserData, None, b2Fixture)
b2Fixture.__SetUserData = new_instancemethod(_Box2D.b2Fixture___SetUserData, None, b2Fixture)
b2Fixture.ClearUserData = new_instancemethod(_Box2D.b2Fixture_ClearUserData, None, b2Fixture)
b2Fixture_swigregister = _Box2D.b2Fixture_swigregister
b2Fixture_swigregister(b2Fixture)

class b2DestructionListener(object):
    """Joints and fixtures are destroyed when their associated body is destroyed. Implement this listener so that you may nullify references to these joints and shapes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2DestructionListener

    def SayGoodbye(self, *args):
        """
        SayGoodbye(b2DestructionListener self, b2Joint joint)
        SayGoodbye(b2DestructionListener self, b2Fixture fixture)

        Called when any fixture is about to be destroyed due to the destruction of its parent body.
        """
        return _Box2D.b2DestructionListener_SayGoodbye(self, *args)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2DestructionListener self) -> long"""
        return _Box2D.b2DestructionListener___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2DestructionListener:
            _self = None
        else:
            _self = self
        _Box2D.b2DestructionListener_swiginit(self,_Box2D.new_b2DestructionListener(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2DestructionListener(self)
        return weakref_proxy(self)
b2DestructionListener.SayGoodbye = new_instancemethod(_Box2D.b2DestructionListener_SayGoodbye, None, b2DestructionListener)
b2DestructionListener.__hash__ = new_instancemethod(_Box2D.b2DestructionListener___hash__, None, b2DestructionListener)
b2DestructionListener_swigregister = _Box2D.b2DestructionListener_swigregister
b2DestructionListener_swigregister(b2DestructionListener)

class b2ContactFilter(object):
    """Implement this class to provide collision filtering. In other words, you can implement this class if you want finer control over contact creation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2ContactFilter

    def ShouldCollide(self, fixtureA, fixtureB):
        """
        ShouldCollide(b2ContactFilter self, b2Fixture fixtureA, b2Fixture fixtureB) -> bool

        Return true if contact calculations should be performed between these two shapes. 
        WARNING: 
        for performance reasons this is only called when the AABBs begin to overlap.
        """
        return _Box2D.b2ContactFilter_ShouldCollide(self, fixtureA, fixtureB)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactFilter self) -> long"""
        return _Box2D.b2ContactFilter___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2ContactFilter:
            _self = None
        else:
            _self = self
        _Box2D.b2ContactFilter_swiginit(self,_Box2D.new_b2ContactFilter(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2ContactFilter(self)
        return weakref_proxy(self)
b2ContactFilter.ShouldCollide = new_instancemethod(_Box2D.b2ContactFilter_ShouldCollide, None, b2ContactFilter)
b2ContactFilter.__hash__ = new_instancemethod(_Box2D.b2ContactFilter___hash__, None, b2ContactFilter)
b2ContactFilter_swigregister = _Box2D.b2ContactFilter_swigregister
b2ContactFilter_swigregister(b2ContactFilter)

class b2ContactImpulse(object):
    """Contact impulses for reporting. Impulses are used instead of forces because sub-step forces may approach infinity for rigid body collisions. These match up one-to-one with the contact points in  b2Manifold."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    count = _swig_property(_Box2D.b2ContactImpulse_count_get, _Box2D.b2ContactImpulse_count_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactImpulse self) -> long"""
        return _Box2D.b2ContactImpulse___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __get_normal_impulses(self):
        """__get_normal_impulses(b2ContactImpulse self) -> PyObject *"""
        return _Box2D.b2ContactImpulse___get_normal_impulses(self)


    def __get_tangent_impulses(self):
        """__get_tangent_impulses(b2ContactImpulse self) -> PyObject *"""
        return _Box2D.b2ContactImpulse___get_tangent_impulses(self)


    normalImpulses = property(__get_normal_impulses, None)
    tangentImpulses = property(__get_tangent_impulses, None)


    def __init__(self, **kwargs):
        _Box2D.b2ContactImpulse_swiginit(self,_Box2D.new_b2ContactImpulse())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactImpulse
b2ContactImpulse.__hash__ = new_instancemethod(_Box2D.b2ContactImpulse___hash__, None, b2ContactImpulse)
b2ContactImpulse.__get_normal_impulses = new_instancemethod(_Box2D.b2ContactImpulse___get_normal_impulses, None, b2ContactImpulse)
b2ContactImpulse.__get_tangent_impulses = new_instancemethod(_Box2D.b2ContactImpulse___get_tangent_impulses, None, b2ContactImpulse)
b2ContactImpulse_swigregister = _Box2D.b2ContactImpulse_swigregister
b2ContactImpulse_swigregister(b2ContactImpulse)

class b2ContactListener(object):
    """
    Implement this class to get contact information. You can use these results for things like sounds and game logic. You can also get contact results by traversing the contact lists after the time step. However, you might miss some contacts because continuous physics leads to sub-stepping. Additionally you may receive multiple callbacks for the same contact in a single time step. You should strive to make your callbacks efficient because there may be many callbacks per time step. 
    WARNING: 
    You cannot create/destroy Box2D entities inside these callbacks.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2ContactListener

    def BeginContact(self, contact):
        """
        BeginContact(b2ContactListener self, b2Contact contact)

        Called when two fixtures begin to touch.
        """
        return _Box2D.b2ContactListener_BeginContact(self, contact)


    def EndContact(self, contact):
        """
        EndContact(b2ContactListener self, b2Contact contact)

        Called when two fixtures cease to touch.
        """
        return _Box2D.b2ContactListener_EndContact(self, contact)


    def PreSolve(self, contact, oldManifold):
        """
        PreSolve(b2ContactListener self, b2Contact contact, b2Manifold oldManifold)

        This is called after a contact is updated. This allows you to inspect a contact before it goes to the solver. If you are careful, you can modify the contact manifold (e.g. disable contact). A copy of the old manifold is provided so that you can detect changes. Note: this is called only for awake bodies. Note: this is called even when the number of contact points is zero. Note: this is not called for sensors. Note: if you set the number of contact points to zero, you will not get an EndContact callback. However, you may get a BeginContact callback the next step.
        """
        return _Box2D.b2ContactListener_PreSolve(self, contact, oldManifold)


    def PostSolve(self, contact, impulse):
        """
        PostSolve(b2ContactListener self, b2Contact contact, b2ContactImpulse impulse)

        This lets you inspect a contact after the solver is finished. This is useful for inspecting impulses. Note: the contact manifold does not include time of impact impulses, which can be arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly in a separate data structure. Note: this is only called for contacts that are touching, solid, and awake.
        """
        return _Box2D.b2ContactListener_PostSolve(self, contact, impulse)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactListener self) -> long"""
        return _Box2D.b2ContactListener___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2ContactListener:
            _self = None
        else:
            _self = self
        _Box2D.b2ContactListener_swiginit(self,_Box2D.new_b2ContactListener(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2ContactListener(self)
        return weakref_proxy(self)
b2ContactListener.BeginContact = new_instancemethod(_Box2D.b2ContactListener_BeginContact, None, b2ContactListener)
b2ContactListener.EndContact = new_instancemethod(_Box2D.b2ContactListener_EndContact, None, b2ContactListener)
b2ContactListener.PreSolve = new_instancemethod(_Box2D.b2ContactListener_PreSolve, None, b2ContactListener)
b2ContactListener.PostSolve = new_instancemethod(_Box2D.b2ContactListener_PostSolve, None, b2ContactListener)
b2ContactListener.__hash__ = new_instancemethod(_Box2D.b2ContactListener___hash__, None, b2ContactListener)
b2ContactListener_swigregister = _Box2D.b2ContactListener_swigregister
b2ContactListener_swigregister(b2ContactListener)

class b2QueryCallback(object):
    """Callback class for AABB queries. See b2World::Query"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2QueryCallback

    def ReportFixture(self, fixture):
        """
        ReportFixture(b2QueryCallback self, b2Fixture fixture) -> bool

        Called for each fixture found in the query AABB. 
        false to terminate the query.
        """
        return _Box2D.b2QueryCallback_ReportFixture(self, fixture)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2QueryCallback self) -> long"""
        return _Box2D.b2QueryCallback___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        if self.__class__ == b2QueryCallback:
            _self = None
        else:
            _self = self
        _Box2D.b2QueryCallback_swiginit(self,_Box2D.new_b2QueryCallback(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2QueryCallback(self)
        return weakref_proxy(self)
b2QueryCallback.ReportFixture = new_instancemethod(_Box2D.b2QueryCallback_ReportFixture, None, b2QueryCallback)
b2QueryCallback.__hash__ = new_instancemethod(_Box2D.b2QueryCallback___hash__, None, b2QueryCallback)
b2QueryCallback_swigregister = _Box2D.b2QueryCallback_swigregister
b2QueryCallback_swigregister(b2QueryCallback)

class b2RayCastCallback(object):
    """Callback class for ray casts. See  b2World::RayCast"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2RayCastCallback

    def ReportFixture(self, fixture, point, normal, fraction):
        """
        ReportFixture(b2RayCastCallback self, b2Fixture fixture, b2Vec2 point, b2Vec2 normal, float32 fraction) -> float32

        Called for each fixture found in the query. You control how the ray cast proceeds by returning a float: return -1: ignore this fixture and continue return 0: terminate the ray cast return fraction: clip the ray to this point return 1: don't clip the ray and continue

        Parameters:
        -----------

        fixture: 
        the fixture hit by the ray

        point: 
        the point of initial intersection

        normal: 
        the normal vector at the point of intersection 
        -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue
        """
        return _Box2D.b2RayCastCallback_ReportFixture(self, fixture, point, normal, fraction)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2RayCastCallback self) -> long"""
        return _Box2D.b2RayCastCallback___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self):
        """
        __init__(b2RayCastCallback self) -> b2RayCastCallback

        Callback class for ray casts. See  b2World::RayCast
        """
        if self.__class__ == b2RayCastCallback:
            _self = None
        else:
            _self = self
        _Box2D.b2RayCastCallback_swiginit(self, _Box2D.new_b2RayCastCallback(_self, ))
    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2RayCastCallback(self)
        return weakref_proxy(self)
b2RayCastCallback.ReportFixture = new_instancemethod(_Box2D.b2RayCastCallback_ReportFixture, None, b2RayCastCallback)
b2RayCastCallback.__hash__ = new_instancemethod(_Box2D.b2RayCastCallback___hash__, None, b2RayCastCallback)
b2RayCastCallback_swigregister = _Box2D.b2RayCastCallback_swigregister
b2RayCastCallback_swigregister(b2RayCastCallback)

class b2Profile(object):
    """Proxy of C++ b2Profile class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    step = _swig_property(_Box2D.b2Profile_step_get, _Box2D.b2Profile_step_set)
    collide = _swig_property(_Box2D.b2Profile_collide_get, _Box2D.b2Profile_collide_set)
    solve = _swig_property(_Box2D.b2Profile_solve_get, _Box2D.b2Profile_solve_set)
    solveInit = _swig_property(_Box2D.b2Profile_solveInit_get, _Box2D.b2Profile_solveInit_set)
    solveVelocity = _swig_property(_Box2D.b2Profile_solveVelocity_get, _Box2D.b2Profile_solveVelocity_set)
    solvePosition = _swig_property(_Box2D.b2Profile_solvePosition_get, _Box2D.b2Profile_solvePosition_set)
    broadphase = _swig_property(_Box2D.b2Profile_broadphase_get, _Box2D.b2Profile_broadphase_set)
    solveTOI = _swig_property(_Box2D.b2Profile_solveTOI_get, _Box2D.b2Profile_solveTOI_set)

    def __init__(self):
        """__init__(b2Profile self) -> b2Profile"""
        _Box2D.b2Profile_swiginit(self, _Box2D.new_b2Profile())
    __swig_destroy__ = _Box2D.delete_b2Profile
b2Profile_swigregister = _Box2D.b2Profile_swigregister
b2Profile_swigregister(b2Profile)

class b2SolverData(object):
    """Proxy of C++ b2SolverData class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    step = _swig_property(_Box2D.b2SolverData_step_get, _Box2D.b2SolverData_step_set)
    positions = _swig_property(_Box2D.b2SolverData_positions_get, _Box2D.b2SolverData_positions_set)
    velocities = _swig_property(_Box2D.b2SolverData_velocities_get, _Box2D.b2SolverData_velocities_set)

    def __init__(self):
        """__init__(b2SolverData self) -> b2SolverData"""
        _Box2D.b2SolverData_swiginit(self, _Box2D.new_b2SolverData())
    __swig_destroy__ = _Box2D.delete_b2SolverData
b2SolverData_swigregister = _Box2D.b2SolverData_swigregister
b2SolverData_swigregister(b2SolverData)

class b2ContactManager(object):
    """Proxy of C++ b2ContactManager class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self):
        """__init__(b2ContactManager self) -> b2ContactManager"""
        _Box2D.b2ContactManager_swiginit(self, _Box2D.new_b2ContactManager())

    def AddPair(self, proxyUserDataA, proxyUserDataB):
        """AddPair(b2ContactManager self, void * proxyUserDataA, void * proxyUserDataB)"""
        return _Box2D.b2ContactManager_AddPair(self, proxyUserDataA, proxyUserDataB)


    def FindNewContacts(self):
        """FindNewContacts(b2ContactManager self)"""
        return _Box2D.b2ContactManager_FindNewContacts(self)


    def Destroy(self, c):
        """Destroy(b2ContactManager self, b2Contact c)"""
        return _Box2D.b2ContactManager_Destroy(self, c)


    def Collide(self):
        """Collide(b2ContactManager self)"""
        return _Box2D.b2ContactManager_Collide(self)

    broadPhase = _swig_property(_Box2D.b2ContactManager_broadPhase_get, _Box2D.b2ContactManager_broadPhase_set)
    contactList = _swig_property(_Box2D.b2ContactManager_contactList_get, _Box2D.b2ContactManager_contactList_set)
    contactCount = _swig_property(_Box2D.b2ContactManager_contactCount_get, _Box2D.b2ContactManager_contactCount_set)
    contactFilter = _swig_property(_Box2D.b2ContactManager_contactFilter_get, _Box2D.b2ContactManager_contactFilter_set)
    contactListener = _swig_property(_Box2D.b2ContactManager_contactListener_get, _Box2D.b2ContactManager_contactListener_set)
    allocator = _swig_property(_Box2D.b2ContactManager_allocator_get, _Box2D.b2ContactManager_allocator_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactManager self) -> long"""
        return _Box2D.b2ContactManager___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



    __swig_destroy__ = _Box2D.delete_b2ContactManager
b2ContactManager.AddPair = new_instancemethod(_Box2D.b2ContactManager_AddPair, None, b2ContactManager)
b2ContactManager.FindNewContacts = new_instancemethod(_Box2D.b2ContactManager_FindNewContacts, None, b2ContactManager)
b2ContactManager.Destroy = new_instancemethod(_Box2D.b2ContactManager_Destroy, None, b2ContactManager)
b2ContactManager.Collide = new_instancemethod(_Box2D.b2ContactManager_Collide, None, b2ContactManager)
b2ContactManager.__hash__ = new_instancemethod(_Box2D.b2ContactManager___hash__, None, b2ContactManager)
b2ContactManager_swigregister = _Box2D.b2ContactManager_swigregister
b2ContactManager_swigregister(b2ContactManager)
b2_stackSize = b2Globals.b2_stackSize
b2_maxStackEntries = b2Globals.b2_maxStackEntries

class b2World(object):
    """The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient memory management facilities."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, gravity=(0, -10), doSleep=True, **kwargs): 
        """__init__(self, gravity=(0, -10), doSleep=True, **kwargs) -> b2World

        Additional kwargs like contactListener will be passed after the world is created.

        Examples:
         b2World(gravity=(0,-10), doSleep=True)
         b2World(contactListener=myListener)
        """
        _Box2D.b2World_swiginit(self,_Box2D.new_b2World(gravity))

        self.allowSleeping = doSleep

        for key, value in kwargs.items():
            try:
                setattr(self, key, value)
            except Exception as ex:
                raise ex.__class__('Failed on kwargs, class="%s" key="%s": %s' \
                            % (self.__class__.__name__, key, ex))


    __swig_destroy__ = _Box2D.delete_b2World

    def __SetDestructionListener_internal(self, listener):
        """
        __SetDestructionListener_internal(b2World self, b2DestructionListener listener)

        Register a destruction listener. The listener is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetDestructionListener_internal(self, listener)


    def __SetContactFilter_internal(self, filter):
        """
        __SetContactFilter_internal(b2World self, b2ContactFilter filter)

        Register a contact filter to provide specific control over collision. Otherwise the default filter is used (b2_defaultFilter). The listener is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetContactFilter_internal(self, filter)


    def __SetContactListener_internal(self, listener):
        """
        __SetContactListener_internal(b2World self, b2ContactListener listener)

        Register a contact event listener. The listener is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetContactListener_internal(self, listener)


    def __SetDebugDraw_internal(self, debugDraw):
        """
        __SetDebugDraw_internal(b2World self, b2Draw debugDraw)

        Register a routine for debug drawing. The debug draw functions are called inside with  b2World::DrawDebugDatamethod. The debug draw object is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetDebugDraw_internal(self, debugDraw)


    def Step(self, timeStep, velocityIterations, positionIterations):
        """
        Step(b2World self, float32 timeStep, int32 velocityIterations, int32 positionIterations)

        Take a time step. This performs collision detection, integration, and constraint solution.

        Parameters:
        -----------

        timeStep: 
        the amount of time to simulate, this should not vary.

        velocityIterations: 
        for the velocity constraint solver.

        positionIterations: 
        for the position constraint solver.
        """
        return _Box2D.b2World_Step(self, timeStep, velocityIterations, positionIterations)


    def ClearForces(self):
        """
        ClearForces(b2World self)

        Manually clear the force buffer on all bodies. By default, forces are cleared automatically after each call to Step. The default behavior is modified by calling SetAutoClearForces. The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain a fixed sized time step under a variable frame-rate. When you perform sub-stepping you will disable auto clearing of forces and instead call ClearForces after all sub-steps are complete in one pass of your game loop. 
        See: 
         SetAutoClearForces
        """
        return _Box2D.b2World_ClearForces(self)


    def DrawDebugData(self):
        """
        DrawDebugData(b2World self)

        Call this to draw shapes and other debug draw data.
        """
        return _Box2D.b2World_DrawDebugData(self)


    def QueryAABB(self, callback, aabb):
        """
        QueryAABB(b2World self, b2QueryCallback callback, b2AABB aabb)

        Query the world for all fixtures that potentially overlap the provided AABB.

        Parameters:
        -----------

        callback: 
        a user implemented callback class.

        aabb: 
        the query box.
        """
        return _Box2D.b2World_QueryAABB(self, callback, aabb)


    def RayCast(self, callback, point1, point2):
        """
        RayCast(b2World self, b2RayCastCallback callback, b2Vec2 point1, b2Vec2 point2)

        Ray-cast the world for all fixtures in the path of the ray. Your callback controls whether you get the closest point, any point, or n-points. The ray-cast ignores shapes that contain the starting point.

        Parameters:
        -----------

        callback: 
        a user implemented callback class.

        point1: 
        the ray starting point

        point2: 
        the ray ending point
        """
        return _Box2D.b2World_RayCast(self, callback, point1, point2)


    def __GetBodyList_internal(self, *args):
        """
        __GetBodyList_internal(b2World self) -> b2Body
        __GetBodyList_internal(b2World self) -> b2Body

        Get the world body list. With the returned body, use  b2Body::GetNextto get the next body in the world list. A NULL body indicates the end of the list. 
        the head of the world body list.
        """
        return _Box2D.b2World___GetBodyList_internal(self, *args)


    def __GetJointList_internal(self, *args):
        """
        __GetJointList_internal(b2World self) -> b2Joint
        __GetJointList_internal(b2World self) -> b2Joint

        Get the world joint list. With the returned joint, use  b2Joint::GetNextto get the next joint in the world list. A NULL joint indicates the end of the list. 
        the head of the world joint list.
        """
        return _Box2D.b2World___GetJointList_internal(self, *args)


    def __GetContactList_internal(self, *args):
        """
        __GetContactList_internal(b2World self) -> b2Contact
        __GetContactList_internal(b2World self) -> b2Contact

        Get the world contact list. With the returned contact, use  b2Contact::GetNextto get the next contact in the world list. A NULL contact indicates the end of the list. 
        the head of the world contact list.

        WARNING: 
        contacts are
        """
        return _Box2D.b2World___GetContactList_internal(self, *args)


    def SetAllowSleeping(self, flag):
        """SetAllowSleeping(b2World self, bool flag)"""
        return _Box2D.b2World_SetAllowSleeping(self, flag)


    def GetAllowSleeping(self):
        """GetAllowSleeping(b2World self) -> bool"""
        return _Box2D.b2World_GetAllowSleeping(self)


    def __SetWarmStarting(self, flag):
        """
        __SetWarmStarting(b2World self, bool flag)

        Enable/disable warm starting. For testing.
        """
        return _Box2D.b2World___SetWarmStarting(self, flag)


    def __GetWarmStarting(self):
        """__GetWarmStarting(b2World self) -> bool"""
        return _Box2D.b2World___GetWarmStarting(self)


    def __SetContinuousPhysics(self, flag):
        """
        __SetContinuousPhysics(b2World self, bool flag)

        Enable/disable continuous physics. For testing.
        """
        return _Box2D.b2World___SetContinuousPhysics(self, flag)


    def __GetContinuousPhysics(self):
        """__GetContinuousPhysics(b2World self) -> bool"""
        return _Box2D.b2World___GetContinuousPhysics(self)


    def __SetSubStepping(self, flag):
        """
        __SetSubStepping(b2World self, bool flag)

        Enable/disable single stepped continuous physics. For testing.
        """
        return _Box2D.b2World___SetSubStepping(self, flag)


    def __GetSubStepping(self):
        """__GetSubStepping(b2World self) -> bool"""
        return _Box2D.b2World___GetSubStepping(self)


    def __GetProxyCount(self):
        """
        __GetProxyCount(b2World self) -> int32

        Get the number of broad-phase proxies.
        """
        return _Box2D.b2World___GetProxyCount(self)


    def __GetBodyCount(self):
        """
        __GetBodyCount(b2World self) -> int32

        Get the number of bodies.
        """
        return _Box2D.b2World___GetBodyCount(self)


    def __GetJointCount(self):
        """
        __GetJointCount(b2World self) -> int32

        Get the number of joints.
        """
        return _Box2D.b2World___GetJointCount(self)


    def __GetContactCount(self):
        """
        __GetContactCount(b2World self) -> int32

        Get the number of contacts (each may have 0 or more contact points).
        """
        return _Box2D.b2World___GetContactCount(self)


    def GetTreeHeight(self):
        """GetTreeHeight(b2World self) -> int32"""
        return _Box2D.b2World_GetTreeHeight(self)


    def GetTreeBalance(self):
        """GetTreeBalance(b2World self) -> int32"""
        return _Box2D.b2World_GetTreeBalance(self)


    def GetTreeQuality(self):
        """GetTreeQuality(b2World self) -> float32"""
        return _Box2D.b2World_GetTreeQuality(self)


    def __SetGravity(self, gravity):
        """
        __SetGravity(b2World self, b2Vec2 gravity)

        Change the global gravity vector.
        """
        return _Box2D.b2World___SetGravity(self, gravity)


    def __GetGravity(self):
        """
        __GetGravity(b2World self) -> b2Vec2

        Get the global gravity vector.
        """
        return _Box2D.b2World___GetGravity(self)


    def __IsLocked(self):
        """
        __IsLocked(b2World self) -> bool

        Is the world locked (in the middle of a time step).
        """
        return _Box2D.b2World___IsLocked(self)


    def __SetAutoClearForces(self, flag):
        """
        __SetAutoClearForces(b2World self, bool flag)

        Set flag to control automatic clearing of forces after each time step.
        """
        return _Box2D.b2World___SetAutoClearForces(self, flag)


    def __GetAutoClearForces(self):
        """
        __GetAutoClearForces(b2World self) -> bool

        Get the flag that controls automatic clearing of forces after each time step.
        """
        return _Box2D.b2World___GetAutoClearForces(self)


    def ShiftOrigin(self, newOrigin):
        """ShiftOrigin(b2World self, b2Vec2 newOrigin)"""
        return _Box2D.b2World_ShiftOrigin(self, newOrigin)


    def __GetContactManager(self):
        """
        __GetContactManager(b2World self) -> b2ContactManager

        Get the contact manager for testing.
        """
        return _Box2D.b2World___GetContactManager(self)


    def GetProfile(self):
        """GetProfile(b2World self) -> b2Profile"""
        return _Box2D.b2World_GetProfile(self)


    def Dump(self):
        """Dump(b2World self)"""
        return _Box2D.b2World_Dump(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2World self) -> long"""
        return _Box2D.b2World___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __CreateBody(self, defn):
        """__CreateBody(b2World self, b2BodyDef defn) -> b2Body"""
        return _Box2D.b2World___CreateBody(self, defn)


    def __CreateJoint(self, defn):
        """__CreateJoint(b2World self, b2JointDef defn) -> b2Joint"""
        return _Box2D.b2World___CreateJoint(self, defn)


    def DestroyBody(self, body):
        """
        DestroyBody(b2World self, b2Body body)

        Destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during callbacks. 
        WARNING: 
        This automatically deletes all associated shapes and joints. 
        This function is locked during callbacks.
        """
        return _Box2D.b2World_DestroyBody(self, body)


    def DestroyJoint(self, joint):
        """
        DestroyJoint(b2World self, b2Joint joint)

        Destroy a joint. This may cause the connected bodies to begin colliding. 
        WARNING: 
        This function is locked during callbacks.
        """
        return _Box2D.b2World_DestroyJoint(self, joint)


    def __iter__(self):
        """
        Iterates over the bodies in the world
        """
        for body in self.bodies:
            yield body

    def CreateDynamicBody(self, **kwargs):
        """
        Create a single dynamic body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_dynamicBody
        return self.CreateBody(**kwargs)

    def CreateKinematicBody(self, **kwargs):
        """
        Create a single kinematic body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_kinematicBody
        return self.CreateBody(**kwargs)

    def CreateStaticBody(self, **kwargs):
        """
        Create a single static body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_staticBody
        return self.CreateBody(**kwargs)

    def CreateBody(self, defn=None, **kwargs):
        """
        Create a body in the world.
        Takes a single b2BodyDef argument, or kwargs to pass to a temporary b2BodyDef.
        world.CreateBody(position=(1,2), angle=1) 
        is short for:
        world.CreateBody(b2BodyDef(position=(1,2), angle=1))

        If the definition (or kwargs) sets 'fixtures', they will be created on the 
        newly created body. A single fixture is also accepted.

        CreateBody(..., fixtures=[])

        This is short for:
            body = CreateBody(...)
            for fixture in []:
                body.CreateFixture(fixture)

         'shapes' and 'shapeFixture' are also accepted:
         CreateBody(..., shapes=[], shapeFixture=b2FixtureDef())

        This is short for:
            body = CreateBody(...)
            body.CreateFixturesFromShapes(shapes=[], shapeFixture=b2FixtureDef())
        """
        if defn is not None:
            if not isinstance(defn, b2BodyDef):
                raise TypeError('Expected b2BodyDef')
        else:
            defn = b2BodyDef(**kwargs) 

        body=self.__CreateBody(defn)

        if defn.fixtures:
            if isinstance(defn.fixtures, (list, tuple)):
                for fixture in defn.fixtures:
                    body.CreateFixture(fixture)
            else:
                body.CreateFixture(defn.fixtures)
        if defn.shapes:
            body.CreateFixturesFromShapes(shapes=defn.shapes, shapeFixture=defn.shapeFixture)

        if 'massData' in kwargs:
            body.massData=kwargs['massData']
        if 'localCenter' in kwargs:
            body.localCenter=kwargs['localCenter']
        if 'inertia' in kwargs:
            body.inertia=kwargs['inertia']
        if 'mass' in kwargs:
            body.mass=kwargs['mass']

        return body

    def CreateDistanceJoint(self, **kwargs):
        """
        Create a single b2DistanceJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2DistanceJointDef(**kwargs))

    def CreateRopeJoint(self, **kwargs):
        """
        Create a single b2RopeJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2RopeJointDef(**kwargs))

    def CreateFrictionJoint(self, **kwargs):
        """
        Create a single b2FrictionJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2FrictionJointDef(**kwargs))

    def CreateGearJoint(self, **kwargs):
        """
        Create a single b2GearJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either joint1 or joint2 is left unset.
        """
        if 'joint1' not in kwargs or 'joint2' not in kwargs:
            raise ValueError('Gear joint requires that both joint1 and joint2 be set')
        return self.__CreateJoint(b2GearJointDef(**kwargs))

    def CreateWheelJoint(self, **kwargs):
        """
        Create a single b2WheelJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2WheelJointDef(**kwargs))

    def CreateMouseJoint(self, **kwargs):
        """
        Create a single b2MouseJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2MouseJointDef(**kwargs))

    def CreatePrismaticJoint(self, **kwargs):
        """
        Create a single b2PrismaticJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2PrismaticJointDef(**kwargs))

    def CreatePulleyJoint(self, **kwargs):
        """
        Create a single b2PulleyJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2PulleyJointDef(**kwargs))

    def CreateRevoluteJoint(self, **kwargs):
        """
        Create a single b2RevoluteJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2RevoluteJointDef(**kwargs))

    def CreateWeldJoint(self, **kwargs):
        """
        Create a single b2WeldJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2WeldJointDef(**kwargs))

    def CreateMotorJoint(self, **kwargs):
        """
        Create a single b2MotorJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2MotorJointDef(**kwargs))

    def CreateJoint(self, defn=None, type=None, **kwargs):
        """
        Create a joint in the world.
        Takes a single b2JointDef argument, or kwargs to pass to a temporary b2JointDef.

        All of these are exactly equivalent:
        world.CreateJoint(type=b2RevoluteJoint, bodyA=body, bodyB=body2)
        world.CreateJoint(type=b2RevoluteJointDef, bodyA=body, bodyB=body2)
        world.CreateJoint(b2RevoluteJointDef(bodyA=body, bodyB=body2))
        """
        if defn is not None:
            if not isinstance(defn, b2JointDef):
                raise TypeError('Expected b2JointDef')
            if defn.bodyA is None or defn.bodyB is None:
                raise ValueError('bodyA and bodyB must be set')
        else:
            if type is not None:
                if issubclass(type, b2JointDef):
                    class_type = type
                elif issubclass(type, b2Joint):  # a b2Joint passed in, so get the b2JointDef
                    class_type = globals()[type.__name__ + 'Def']
                else:
                    raise TypeError('Expected "type" to be a b2Joint or b2JointDef')
            else:
                raise TypeError('Expected "type" to be a b2Joint or b2JointDef')

            defn = class_type(**kwargs) 

        if isinstance(defn, b2GearJointDef):
            if not defn.joint1 or not defn.joint2:
                raise ValueError('Gear joint requires that both joint1 and joint2 be set')
        else:
            if not defn.bodyA or not defn.bodyB:
                raise ValueError('Body or bodies not set (bodyA, bodyB)')

        return self.__CreateJoint(defn)

    # The logic behind these functions is that they increase the refcount
    # of the listeners as you set them, so it is no longer necessary to keep
    # a copy on your own. Upon destruction of the object, it should be cleared
    # also clearing the refcount of the function.
    # Now using it also to buffer previously write-only values in the shadowed
    # class to make them read-write.
    def __GetData(self, name):
        if name in list(self.__data.keys()):
            return self.__data[name]
        else:
            return None
    def __SetData(self, name, value, fcn):
        self.__data[name] = value
        fcn(value)

    # Read-write properties
    gravity   = property(__GetGravity, __SetGravity)
    autoClearForces = property(__GetAutoClearForces, __SetAutoClearForces)
    __data = {} # holds the listeners so they can be properly destroyed, and buffer other data
    destructionListener = property(lambda self: self.__GetData('destruction'), 
                                   lambda self, fcn: self.__SetData('destruction', fcn, self.__SetDestructionListener_internal))
    contactListener= property(lambda self: self.__GetData('contact'), 
                              lambda self, fcn: self.__SetData('contact', fcn, self.__SetContactListener_internal))
    contactFilter= property(lambda self: self.__GetData('contactfilter'),
                            lambda self, fcn: self.__SetData('contactfilter', fcn, self.__SetContactFilter_internal))
    renderer= property(lambda self: self.__GetData('renderer'),
                        lambda self, fcn: self.__SetData('renderer', fcn, self.__SetDebugDraw_internal))

    continuousPhysics = property(__GetContinuousPhysics, __SetContinuousPhysics)
    warmStarting = property(__GetWarmStarting, __SetWarmStarting)
    subStepping = property(__GetSubStepping, __SetSubStepping)

    # Read-only 
    contactManager= property(__GetContactManager, None)
    contactCount  = property(__GetContactCount, None)
    bodyCount     = property(__GetBodyCount, None)
    jointCount    = property(__GetJointCount, None)
    proxyCount    = property(__GetProxyCount, None)
    joints  = property(lambda self: _list_from_linked_list(self.__GetJointList_internal()), None,
                        doc="""All joints in the world.  NOTE: This re-creates the list on every call. See also joints_gen.""")
    bodies  = property(lambda self: _list_from_linked_list(self.__GetBodyList_internal()), None,
                        doc="""All bodies in the world.  NOTE: This re-creates the list on every call. See also bodies_gen.""")
    contacts= property(lambda self: _list_from_linked_list(self.__GetContactList_internal()), None,
                        doc="""All contacts in the world.  NOTE: This re-creates the list on every call. See also contacts_gen.""")
    joints_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetJointList_internal())), None,
                        doc="""Indexable generator of the connected joints to this body.
                        NOTE: When not using the whole list, this may be preferable to using 'joints'.""")
    bodies_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetBodyList_internal())), None,
                        doc="""Indexable generator of all bodies.
                        NOTE: When not using the whole list, this may be preferable to using 'bodies'.""")
    contacts_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetContactList_internal())), None,
                        doc="""Indexable generator of all contacts.
                        NOTE: When not using the whole list, this may be preferable to using 'contacts'.""")
    locked  = property(__IsLocked, None)


b2World.__SetDestructionListener_internal = new_instancemethod(_Box2D.b2World___SetDestructionListener_internal, None, b2World)
b2World.__SetContactFilter_internal = new_instancemethod(_Box2D.b2World___SetContactFilter_internal, None, b2World)
b2World.__SetContactListener_internal = new_instancemethod(_Box2D.b2World___SetContactListener_internal, None, b2World)
b2World.__SetDebugDraw_internal = new_instancemethod(_Box2D.b2World___SetDebugDraw_internal, None, b2World)
b2World.Step = new_instancemethod(_Box2D.b2World_Step, None, b2World)
b2World.ClearForces = new_instancemethod(_Box2D.b2World_ClearForces, None, b2World)
b2World.DrawDebugData = new_instancemethod(_Box2D.b2World_DrawDebugData, None, b2World)
b2World.QueryAABB = new_instancemethod(_Box2D.b2World_QueryAABB, None, b2World)
b2World.RayCast = new_instancemethod(_Box2D.b2World_RayCast, None, b2World)
b2World.__GetBodyList_internal = new_instancemethod(_Box2D.b2World___GetBodyList_internal, None, b2World)
b2World.__GetJointList_internal = new_instancemethod(_Box2D.b2World___GetJointList_internal, None, b2World)
b2World.__GetContactList_internal = new_instancemethod(_Box2D.b2World___GetContactList_internal, None, b2World)
b2World.SetAllowSleeping = new_instancemethod(_Box2D.b2World_SetAllowSleeping, None, b2World)
b2World.GetAllowSleeping = new_instancemethod(_Box2D.b2World_GetAllowSleeping, None, b2World)
b2World.__SetWarmStarting = new_instancemethod(_Box2D.b2World___SetWarmStarting, None, b2World)
b2World.__GetWarmStarting = new_instancemethod(_Box2D.b2World___GetWarmStarting, None, b2World)
b2World.__SetContinuousPhysics = new_instancemethod(_Box2D.b2World___SetContinuousPhysics, None, b2World)
b2World.__GetContinuousPhysics = new_instancemethod(_Box2D.b2World___GetContinuousPhysics, None, b2World)
b2World.__SetSubStepping = new_instancemethod(_Box2D.b2World___SetSubStepping, None, b2World)
b2World.__GetSubStepping = new_instancemethod(_Box2D.b2World___GetSubStepping, None, b2World)
b2World.__GetProxyCount = new_instancemethod(_Box2D.b2World___GetProxyCount, None, b2World)
b2World.__GetBodyCount = new_instancemethod(_Box2D.b2World___GetBodyCount, None, b2World)
b2World.__GetJointCount = new_instancemethod(_Box2D.b2World___GetJointCount, None, b2World)
b2World.__GetContactCount = new_instancemethod(_Box2D.b2World___GetContactCount, None, b2World)
b2World.GetTreeHeight = new_instancemethod(_Box2D.b2World_GetTreeHeight, None, b2World)
b2World.GetTreeBalance = new_instancemethod(_Box2D.b2World_GetTreeBalance, None, b2World)
b2World.GetTreeQuality = new_instancemethod(_Box2D.b2World_GetTreeQuality, None, b2World)
b2World.__SetGravity = new_instancemethod(_Box2D.b2World___SetGravity, None, b2World)
b2World.__GetGravity = new_instancemethod(_Box2D.b2World___GetGravity, None, b2World)
b2World.__IsLocked = new_instancemethod(_Box2D.b2World___IsLocked, None, b2World)
b2World.__SetAutoClearForces = new_instancemethod(_Box2D.b2World___SetAutoClearForces, None, b2World)
b2World.__GetAutoClearForces = new_instancemethod(_Box2D.b2World___GetAutoClearForces, None, b2World)
b2World.ShiftOrigin = new_instancemethod(_Box2D.b2World_ShiftOrigin, None, b2World)
b2World.__GetContactManager = new_instancemethod(_Box2D.b2World___GetContactManager, None, b2World)
b2World.GetProfile = new_instancemethod(_Box2D.b2World_GetProfile, None, b2World)
b2World.Dump = new_instancemethod(_Box2D.b2World_Dump, None, b2World)
b2World.__hash__ = new_instancemethod(_Box2D.b2World___hash__, None, b2World)
b2World.__CreateBody = new_instancemethod(_Box2D.b2World___CreateBody, None, b2World)
b2World.__CreateJoint = new_instancemethod(_Box2D.b2World___CreateJoint, None, b2World)
b2World.DestroyBody = new_instancemethod(_Box2D.b2World_DestroyBody, None, b2World)
b2World.DestroyJoint = new_instancemethod(_Box2D.b2World_DestroyJoint, None, b2World)
b2World_swigregister = _Box2D.b2World_swigregister
b2World_swigregister(b2World)


def b2MixFriction(friction1, friction2):
    """
    b2MixFriction(float32 friction1, float32 friction2) -> float32

    Friction mixing law. Feel free to customize this.
    """
    return _Box2D.b2MixFriction(friction1, friction2)

def b2MixRestitution(restitution1, restitution2):
    """
    b2MixRestitution(float32 restitution1, float32 restitution2) -> float32

    Restitution mixing law. Feel free to customize this.
    """
    return _Box2D.b2MixRestitution(restitution1, restitution2)
class b2ContactEdge(object):
    """A contact edge is used to connect bodies and contacts together in a contact graph where each body is a node and each contact is an edge. A contact edge belongs to a doubly linked list maintained in each attached body. Each contact has two contact nodes, one for each attached body."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    other = _swig_property(_Box2D.b2ContactEdge_other_get, _Box2D.b2ContactEdge_other_set)
    contact = _swig_property(_Box2D.b2ContactEdge_contact_get, _Box2D.b2ContactEdge_contact_set)
    prev = _swig_property(_Box2D.b2ContactEdge_prev_get, _Box2D.b2ContactEdge_prev_set)
    next = _swig_property(_Box2D.b2ContactEdge_next_get, _Box2D.b2ContactEdge_next_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2ContactEdge self) -> long"""
        return _Box2D.b2ContactEdge___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2ContactEdge_swiginit(self,_Box2D.new_b2ContactEdge())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactEdge
b2ContactEdge.__hash__ = new_instancemethod(_Box2D.b2ContactEdge___hash__, None, b2ContactEdge)
b2ContactEdge_swigregister = _Box2D.b2ContactEdge_swigregister
b2ContactEdge_swigregister(b2ContactEdge)

class b2Contact(object):
    """The class manages contact between two shapes. A contact exists for each overlapping AABB in the broad-phase (except if filtered). Therefore a contact object may exist that has no contact points."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __GetManifold(self, *args):
        """
        __GetManifold(b2Contact self) -> b2Manifold
        __GetManifold(b2Contact self) -> b2Manifold

        Get the contact manifold. Do not modify the manifold unless you understand the internals of Box2D.
        """
        return _Box2D.b2Contact___GetManifold(self, *args)


    def __GetWorldManifold_internal(self, worldManifold):
        """
        __GetWorldManifold_internal(b2Contact self, b2WorldManifold worldManifold)

        Get the world manifold.
        """
        return _Box2D.b2Contact___GetWorldManifold_internal(self, worldManifold)


    def __IsTouching(self):
        """
        __IsTouching(b2Contact self) -> bool

        Is this contact touching?
        """
        return _Box2D.b2Contact___IsTouching(self)


    def __SetEnabled(self, flag):
        """
        __SetEnabled(b2Contact self, bool flag)

        Enable/disable this contact. This can be used inside the pre-solve contact listener. The contact is only disabled for the current time step (or sub-step in continuous collisions).
        """
        return _Box2D.b2Contact___SetEnabled(self, flag)


    def __IsEnabled(self):
        """
        __IsEnabled(b2Contact self) -> bool

        Has this contact been disabled?
        """
        return _Box2D.b2Contact___IsEnabled(self)


    def __GetNext(self, *args):
        """
        __GetNext(b2Contact self) -> b2Contact
        __GetNext(b2Contact self) -> b2Contact

        Get the next contact in the world's contact list.
        """
        return _Box2D.b2Contact___GetNext(self, *args)


    def __GetFixtureA(self, *args):
        """
        __GetFixtureA(b2Contact self) -> b2Fixture
        __GetFixtureA(b2Contact self) -> b2Fixture

        Get fixture A in this contact.
        """
        return _Box2D.b2Contact___GetFixtureA(self, *args)


    def __GetChildIndexA(self):
        """
        __GetChildIndexA(b2Contact self) -> int32

        Get the child primitive index for fixture A.
        """
        return _Box2D.b2Contact___GetChildIndexA(self)


    def __GetFixtureB(self, *args):
        """
        __GetFixtureB(b2Contact self) -> b2Fixture
        __GetFixtureB(b2Contact self) -> b2Fixture

        Get fixture B in this contact.
        """
        return _Box2D.b2Contact___GetFixtureB(self, *args)


    def __GetChildIndexB(self):
        """
        __GetChildIndexB(b2Contact self) -> int32

        Get the child primitive index for fixture B.
        """
        return _Box2D.b2Contact___GetChildIndexB(self)


    def __SetFriction(self, friction):
        """
        __SetFriction(b2Contact self, float32 friction)

        Override the default friction mixture. You can call this in  b2ContactListener::PreSolve. This value persists until set or reset.
        """
        return _Box2D.b2Contact___SetFriction(self, friction)


    def __GetFriction(self):
        """
        __GetFriction(b2Contact self) -> float32

        Get the friction.
        """
        return _Box2D.b2Contact___GetFriction(self)


    def ResetFriction(self):
        """
        ResetFriction(b2Contact self)

        Reset the friction mixture to the default value.
        """
        return _Box2D.b2Contact_ResetFriction(self)


    def __SetRestitution(self, restitution):
        """
        __SetRestitution(b2Contact self, float32 restitution)

        Override the default restitution mixture. You can call this in  b2ContactListener::PreSolve. The value persists until you set or reset.
        """
        return _Box2D.b2Contact___SetRestitution(self, restitution)


    def __GetRestitution(self):
        """
        __GetRestitution(b2Contact self) -> float32

        Get the restitution.
        """
        return _Box2D.b2Contact___GetRestitution(self)


    def ResetRestitution(self):
        """
        ResetRestitution(b2Contact self)

        Reset the restitution to the default value.
        """
        return _Box2D.b2Contact_ResetRestitution(self)


    def __SetTangentSpeed(self, speed):
        """__SetTangentSpeed(b2Contact self, float32 speed)"""
        return _Box2D.b2Contact___SetTangentSpeed(self, speed)


    def __GetTangentSpeed(self):
        """__GetTangentSpeed(b2Contact self) -> float32"""
        return _Box2D.b2Contact___GetTangentSpeed(self)


    def Evaluate(self, manifold, xfA, xfB):
        """
        Evaluate(b2Contact self, b2Manifold manifold, b2Transform xfA, b2Transform xfB)

        Evaluate this contact with your own manifold and transforms.
        """
        return _Box2D.b2Contact_Evaluate(self, manifold, xfA, xfB)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Contact self) -> long"""
        return _Box2D.b2Contact___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __GetWorldManifold(self):
        ret=b2WorldManifold()
        self.__GetWorldManifold_internal(ret)
        return ret

    # Read-write properties
    enabled = property(__IsEnabled, __SetEnabled)

    # Read-only
    next = property(__GetNext, None)
    fixtureB = property(__GetFixtureB, None)
    fixtureA = property(__GetFixtureA, None)
    manifold = property(__GetManifold, None)
    childIndexA = property(__GetChildIndexA, None)
    childIndexB = property(__GetChildIndexB, None)
    worldManifold = property(__GetWorldManifold, None)
    touching = property(__IsTouching, None)
    friction = property(__GetFriction, __SetFriction)
    restitution = property(__GetRestitution, __SetRestitution)
    tangentSpeed = property(__GetTangentSpeed, __SetTangentSpeed)


b2Contact.__GetManifold = new_instancemethod(_Box2D.b2Contact___GetManifold, None, b2Contact)
b2Contact.__GetWorldManifold_internal = new_instancemethod(_Box2D.b2Contact___GetWorldManifold_internal, None, b2Contact)
b2Contact.__IsTouching = new_instancemethod(_Box2D.b2Contact___IsTouching, None, b2Contact)
b2Contact.__SetEnabled = new_instancemethod(_Box2D.b2Contact___SetEnabled, None, b2Contact)
b2Contact.__IsEnabled = new_instancemethod(_Box2D.b2Contact___IsEnabled, None, b2Contact)
b2Contact.__GetNext = new_instancemethod(_Box2D.b2Contact___GetNext, None, b2Contact)
b2Contact.__GetFixtureA = new_instancemethod(_Box2D.b2Contact___GetFixtureA, None, b2Contact)
b2Contact.__GetChildIndexA = new_instancemethod(_Box2D.b2Contact___GetChildIndexA, None, b2Contact)
b2Contact.__GetFixtureB = new_instancemethod(_Box2D.b2Contact___GetFixtureB, None, b2Contact)
b2Contact.__GetChildIndexB = new_instancemethod(_Box2D.b2Contact___GetChildIndexB, None, b2Contact)
b2Contact.__SetFriction = new_instancemethod(_Box2D.b2Contact___SetFriction, None, b2Contact)
b2Contact.__GetFriction = new_instancemethod(_Box2D.b2Contact___GetFriction, None, b2Contact)
b2Contact.ResetFriction = new_instancemethod(_Box2D.b2Contact_ResetFriction, None, b2Contact)
b2Contact.__SetRestitution = new_instancemethod(_Box2D.b2Contact___SetRestitution, None, b2Contact)
b2Contact.__GetRestitution = new_instancemethod(_Box2D.b2Contact___GetRestitution, None, b2Contact)
b2Contact.ResetRestitution = new_instancemethod(_Box2D.b2Contact_ResetRestitution, None, b2Contact)
b2Contact.__SetTangentSpeed = new_instancemethod(_Box2D.b2Contact___SetTangentSpeed, None, b2Contact)
b2Contact.__GetTangentSpeed = new_instancemethod(_Box2D.b2Contact___GetTangentSpeed, None, b2Contact)
b2Contact.Evaluate = new_instancemethod(_Box2D.b2Contact_Evaluate, None, b2Contact)
b2Contact.__hash__ = new_instancemethod(_Box2D.b2Contact___hash__, None, b2Contact)
b2Contact_swigregister = _Box2D.b2Contact_swigregister
b2Contact_swigregister(b2Contact)

e_wheelJoint = _Box2D.e_wheelJoint
e_ropeJoint = _Box2D.e_ropeJoint
class b2Jacobian(object):
    """Proxy of C++ b2Jacobian class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    linear = _swig_property(_Box2D.b2Jacobian_linear_get, _Box2D.b2Jacobian_linear_set)
    angularA = _swig_property(_Box2D.b2Jacobian_angularA_get, _Box2D.b2Jacobian_angularA_set)
    angularB = _swig_property(_Box2D.b2Jacobian_angularB_get, _Box2D.b2Jacobian_angularB_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Jacobian self) -> long"""
        return _Box2D.b2Jacobian___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2Jacobian_swiginit(self,_Box2D.new_b2Jacobian())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Jacobian
b2Jacobian.__hash__ = new_instancemethod(_Box2D.b2Jacobian___hash__, None, b2Jacobian)
b2Jacobian_swigregister = _Box2D.b2Jacobian_swigregister
b2Jacobian_swigregister(b2Jacobian)

class b2JointEdge(object):
    """A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each joint is an edge. A joint edge belongs to a doubly linked list maintained in each attached body. Each joint has two joint nodes, one for each attached body."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    other = _swig_property(_Box2D.b2JointEdge_other_get, _Box2D.b2JointEdge_other_set)
    joint = _swig_property(_Box2D.b2JointEdge_joint_get, _Box2D.b2JointEdge_joint_set)
    prev = _swig_property(_Box2D.b2JointEdge_prev_get, _Box2D.b2JointEdge_prev_set)
    next = _swig_property(_Box2D.b2JointEdge_next_get, _Box2D.b2JointEdge_next_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2JointEdge self) -> long"""
        return _Box2D.b2JointEdge___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __init__(self, **kwargs):
        _Box2D.b2JointEdge_swiginit(self,_Box2D.new_b2JointEdge())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2JointEdge
b2JointEdge.__hash__ = new_instancemethod(_Box2D.b2JointEdge___hash__, None, b2JointEdge)
b2JointEdge_swigregister = _Box2D.b2JointEdge_swigregister
b2JointEdge_swigregister(b2JointEdge)

class b2JointDef(object):
    """Joint definitions are used to construct joints."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2JointDef_swiginit(self,_Box2D.new_b2JointDef())
        _init_kwargs(self, **kwargs)


    type = _swig_property(_Box2D.b2JointDef_type_get, _Box2D.b2JointDef_type_set)
    bodyA = _swig_property(_Box2D.b2JointDef_bodyA_get, _Box2D.b2JointDef_bodyA_set)
    bodyB = _swig_property(_Box2D.b2JointDef_bodyB_get, _Box2D.b2JointDef_bodyB_set)
    collideConnected = _swig_property(_Box2D.b2JointDef_collideConnected_get, _Box2D.b2JointDef_collideConnected_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2JointDef self) -> long"""
        return _Box2D.b2JointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __GetUserData(self):
        """__GetUserData(b2JointDef self) -> PyObject *"""
        return _Box2D.b2JointDef___GetUserData(self)


    def __SetUserData(self, data):
        """__SetUserData(b2JointDef self, PyObject * data)"""
        return _Box2D.b2JointDef___SetUserData(self, data)


    def ClearUserData(self):
        """ClearUserData(b2JointDef self)"""
        return _Box2D.b2JointDef_ClearUserData(self)


    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()


    def to_kwargs(self):
        """
        Returns a dictionary representing this joint definition
        """
        def is_prop(attr):
            try:
                is_property = isinstance(getattr(cls, attr), property)
            except AttributeError:
                return False

            return is_property and attr not in skip_props

        skip_props = ['anchor', 'anchorA', 'anchorB', 'axis']
        cls = type(self)
        return {attr: getattr(self, attr)
                for attr in dir(self)
                if is_prop(attr)
                }

    __swig_destroy__ = _Box2D.delete_b2JointDef
b2JointDef.__hash__ = new_instancemethod(_Box2D.b2JointDef___hash__, None, b2JointDef)
b2JointDef.__GetUserData = new_instancemethod(_Box2D.b2JointDef___GetUserData, None, b2JointDef)
b2JointDef.__SetUserData = new_instancemethod(_Box2D.b2JointDef___SetUserData, None, b2JointDef)
b2JointDef.ClearUserData = new_instancemethod(_Box2D.b2JointDef_ClearUserData, None, b2JointDef)
b2JointDef_swigregister = _Box2D.b2JointDef_swigregister
b2JointDef_swigregister(b2JointDef)

class b2Joint(object):
    """The base joint class. Joints are used to constraint two bodies together in various fashions. Some joints also feature limits and motors."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def __GetType(self):
        """
        __GetType(b2Joint self) -> b2JointType

        Get the type of the concrete joint.
        """
        return _Box2D.b2Joint___GetType(self)


    def __GetBodyA(self):
        """
        __GetBodyA(b2Joint self) -> b2Body

        Get the first body attached to this joint.
        """
        return _Box2D.b2Joint___GetBodyA(self)


    def __GetBodyB(self):
        """
        __GetBodyB(b2Joint self) -> b2Body

        Get the second body attached to this joint.
        """
        return _Box2D.b2Joint___GetBodyB(self)


    def __GetAnchorA(self):
        """
        __GetAnchorA(b2Joint self) -> b2Vec2

        Get the anchor point on bodyA in world coordinates.
        """
        return _Box2D.b2Joint___GetAnchorA(self)


    def __GetAnchorB(self):
        """
        __GetAnchorB(b2Joint self) -> b2Vec2

        Get the anchor point on bodyB in world coordinates.
        """
        return _Box2D.b2Joint___GetAnchorB(self)


    def GetReactionForce(self, inv_dt):
        """
        GetReactionForce(b2Joint self, float32 inv_dt) -> b2Vec2

        Get the reaction force on body2 at the joint anchor in Newtons.
        """
        return _Box2D.b2Joint_GetReactionForce(self, inv_dt)


    def GetReactionTorque(self, inv_dt):
        """
        GetReactionTorque(b2Joint self, float32 inv_dt) -> float32

        Get the reaction torque on body2 in N*m.
        """
        return _Box2D.b2Joint_GetReactionTorque(self, inv_dt)


    def __GetNext(self, *args):
        """
        __GetNext(b2Joint self) -> b2Joint
        __GetNext(b2Joint self) -> b2Joint

        Get the next joint the world joint list.
        """
        return _Box2D.b2Joint___GetNext(self, *args)


    def __IsActive(self):
        """
        __IsActive(b2Joint self) -> bool

        Short-cut function to determine if either body is inactive.
        """
        return _Box2D.b2Joint___IsActive(self)


    def __GetCollideConnected(self):
        """__GetCollideConnected(b2Joint self) -> bool"""
        return _Box2D.b2Joint___GetCollideConnected(self)


    def Dump(self):
        """Dump(b2Joint self)"""
        return _Box2D.b2Joint_Dump(self)


    def ShiftOrigin(self, newOrigin):
        """ShiftOrigin(b2Joint self, b2Vec2 newOrigin)"""
        return _Box2D.b2Joint_ShiftOrigin(self, newOrigin)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2Joint self) -> long"""
        return _Box2D.b2Joint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __GetUserData(self):
        """__GetUserData(b2Joint self) -> PyObject *"""
        return _Box2D.b2Joint___GetUserData(self)


    def __SetUserData(self, data):
        """__SetUserData(b2Joint self, PyObject * data)"""
        return _Box2D.b2Joint___SetUserData(self, data)


    def ClearUserData(self):
        """ClearUserData(b2Joint self)"""
        return _Box2D.b2Joint_ClearUserData(self)


    userData = property(__GetUserData, __SetUserData)


    __eq__ = b2JointCompare
    __ne__ = lambda self,other: not b2JointCompare(self,other)

    # Read-only
    next = property(__GetNext, None)
    bodyA = property(__GetBodyA, None)
    bodyB = property(__GetBodyB, None)
    type = property(__GetType, None)
    active = property(__IsActive, None)
    anchorB = property(__GetAnchorB, None)
    anchorA = property(__GetAnchorA, None)
    collideConnected = property(__GetCollideConnected, None)

    def getAsType(self):
        """
        Backward compatibility
        """
        return self

b2Joint.__GetType = new_instancemethod(_Box2D.b2Joint___GetType, None, b2Joint)
b2Joint.__GetBodyA = new_instancemethod(_Box2D.b2Joint___GetBodyA, None, b2Joint)
b2Joint.__GetBodyB = new_instancemethod(_Box2D.b2Joint___GetBodyB, None, b2Joint)
b2Joint.__GetAnchorA = new_instancemethod(_Box2D.b2Joint___GetAnchorA, None, b2Joint)
b2Joint.__GetAnchorB = new_instancemethod(_Box2D.b2Joint___GetAnchorB, None, b2Joint)
b2Joint.GetReactionForce = new_instancemethod(_Box2D.b2Joint_GetReactionForce, None, b2Joint)
b2Joint.GetReactionTorque = new_instancemethod(_Box2D.b2Joint_GetReactionTorque, None, b2Joint)
b2Joint.__GetNext = new_instancemethod(_Box2D.b2Joint___GetNext, None, b2Joint)
b2Joint.__IsActive = new_instancemethod(_Box2D.b2Joint___IsActive, None, b2Joint)
b2Joint.__GetCollideConnected = new_instancemethod(_Box2D.b2Joint___GetCollideConnected, None, b2Joint)
b2Joint.Dump = new_instancemethod(_Box2D.b2Joint_Dump, None, b2Joint)
b2Joint.ShiftOrigin = new_instancemethod(_Box2D.b2Joint_ShiftOrigin, None, b2Joint)
b2Joint.__hash__ = new_instancemethod(_Box2D.b2Joint___hash__, None, b2Joint)
b2Joint.__GetUserData = new_instancemethod(_Box2D.b2Joint___GetUserData, None, b2Joint)
b2Joint.__SetUserData = new_instancemethod(_Box2D.b2Joint___SetUserData, None, b2Joint)
b2Joint.ClearUserData = new_instancemethod(_Box2D.b2Joint_ClearUserData, None, b2Joint)
b2Joint_swigregister = _Box2D.b2Joint_swigregister
b2Joint_swigregister(b2Joint)

class b2DistanceJointDef(b2JointDef):
    """
    Distance joint definition. This requires defining an anchor point on both bodies and the non-zero length of the distance joint. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. This helps when saving and loading a game. 
    WARNING: 
    Do not use a zero or short length.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2DistanceJointDef_swiginit(self,_Box2D.new_b2DistanceJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if 'localAnchorA' in kwargs and 'localAnchorB' in kwargs and 'length' not in kwargs:
            self.__update_length()



    def Initialize(self, bodyA, bodyB, anchorA, anchorB):
        """
        Initialize(b2DistanceJointDef self, b2Body bodyA, b2Body bodyB, b2Vec2 anchorA, b2Vec2 anchorB)

        Initialize the bodies, anchors, and length using the world anchors.
        """
        return _Box2D.b2DistanceJointDef_Initialize(self, bodyA, bodyB, anchorA, anchorB)

    localAnchorA = _swig_property(_Box2D.b2DistanceJointDef_localAnchorA_get, _Box2D.b2DistanceJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2DistanceJointDef_localAnchorB_get, _Box2D.b2DistanceJointDef_localAnchorB_set)
    length = _swig_property(_Box2D.b2DistanceJointDef_length_get, _Box2D.b2DistanceJointDef_length_set)
    frequencyHz = _swig_property(_Box2D.b2DistanceJointDef_frequencyHz_get, _Box2D.b2DistanceJointDef_frequencyHz_set)
    dampingRatio = _swig_property(_Box2D.b2DistanceJointDef_dampingRatio_get, _Box2D.b2DistanceJointDef_dampingRatio_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2DistanceJointDef self) -> long"""
        return _Box2D.b2DistanceJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __update_length(self):
        if self.bodyA and self.bodyB:
            d = self.anchorB - self.anchorA
            self.length = d.length
    def __set_anchorA(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.__update_length()
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
        self.__update_length()
    def __get_anchorA(self):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2DistanceJointDef
b2DistanceJointDef.Initialize = new_instancemethod(_Box2D.b2DistanceJointDef_Initialize, None, b2DistanceJointDef)
b2DistanceJointDef.__hash__ = new_instancemethod(_Box2D.b2DistanceJointDef___hash__, None, b2DistanceJointDef)
b2DistanceJointDef_swigregister = _Box2D.b2DistanceJointDef_swigregister
b2DistanceJointDef_swigregister(b2DistanceJointDef)

class b2DistanceJoint(b2Joint):
    """A distance joint constrains two points on two bodies to remain at a fixed distance from each other. You can view this as a massless, rigid rod."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetLocalAnchorA(self):
        """GetLocalAnchorA(b2DistanceJoint self) -> b2Vec2"""
        return _Box2D.b2DistanceJoint_GetLocalAnchorA(self)


    def GetLocalAnchorB(self):
        """GetLocalAnchorB(b2DistanceJoint self) -> b2Vec2"""
        return _Box2D.b2DistanceJoint_GetLocalAnchorB(self)


    def __SetLength(self, length):
        """
        __SetLength(b2DistanceJoint self, float32 length)

        Set/get the natural length. Manipulating the length can lead to non-physical behavior when the frequency is zero.
        """
        return _Box2D.b2DistanceJoint___SetLength(self, length)


    def __GetLength(self):
        """__GetLength(b2DistanceJoint self) -> float32"""
        return _Box2D.b2DistanceJoint___GetLength(self)


    def __SetFrequency(self, hz):
        """__SetFrequency(b2DistanceJoint self, float32 hz)"""
        return _Box2D.b2DistanceJoint___SetFrequency(self, hz)


    def __GetFrequency(self):
        """__GetFrequency(b2DistanceJoint self) -> float32"""
        return _Box2D.b2DistanceJoint___GetFrequency(self)


    def __SetDampingRatio(self, ratio):
        """__SetDampingRatio(b2DistanceJoint self, float32 ratio)"""
        return _Box2D.b2DistanceJoint___SetDampingRatio(self, ratio)


    def __GetDampingRatio(self):
        """__GetDampingRatio(b2DistanceJoint self) -> float32"""
        return _Box2D.b2DistanceJoint___GetDampingRatio(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2DistanceJoint self) -> long"""
        return _Box2D.b2DistanceJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    length = property(__GetLength, __SetLength)
    frequency = property(__GetFrequency, __SetFrequency)
    dampingRatio = property(__GetDampingRatio, __SetDampingRatio)


    __swig_destroy__ = _Box2D.delete_b2DistanceJoint
b2DistanceJoint.GetLocalAnchorA = new_instancemethod(_Box2D.b2DistanceJoint_GetLocalAnchorA, None, b2DistanceJoint)
b2DistanceJoint.GetLocalAnchorB = new_instancemethod(_Box2D.b2DistanceJoint_GetLocalAnchorB, None, b2DistanceJoint)
b2DistanceJoint.__SetLength = new_instancemethod(_Box2D.b2DistanceJoint___SetLength, None, b2DistanceJoint)
b2DistanceJoint.__GetLength = new_instancemethod(_Box2D.b2DistanceJoint___GetLength, None, b2DistanceJoint)
b2DistanceJoint.__SetFrequency = new_instancemethod(_Box2D.b2DistanceJoint___SetFrequency, None, b2DistanceJoint)
b2DistanceJoint.__GetFrequency = new_instancemethod(_Box2D.b2DistanceJoint___GetFrequency, None, b2DistanceJoint)
b2DistanceJoint.__SetDampingRatio = new_instancemethod(_Box2D.b2DistanceJoint___SetDampingRatio, None, b2DistanceJoint)
b2DistanceJoint.__GetDampingRatio = new_instancemethod(_Box2D.b2DistanceJoint___GetDampingRatio, None, b2DistanceJoint)
b2DistanceJoint.__hash__ = new_instancemethod(_Box2D.b2DistanceJoint___hash__, None, b2DistanceJoint)
b2DistanceJoint_swigregister = _Box2D.b2DistanceJoint_swigregister
b2DistanceJoint_swigregister(b2DistanceJoint)

class b2FrictionJointDef(b2JointDef):
    """Friction joint definition."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2FrictionJointDef_swiginit(self,_Box2D.new_b2FrictionJointDef())
        _init_jointdef_kwargs(self, **kwargs)



    def Initialize(self, bodyA, bodyB, anchor):
        """
        Initialize(b2FrictionJointDef self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor)

        Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
        """
        return _Box2D.b2FrictionJointDef_Initialize(self, bodyA, bodyB, anchor)

    localAnchorA = _swig_property(_Box2D.b2FrictionJointDef_localAnchorA_get, _Box2D.b2FrictionJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2FrictionJointDef_localAnchorB_get, _Box2D.b2FrictionJointDef_localAnchorB_set)
    maxForce = _swig_property(_Box2D.b2FrictionJointDef_maxForce_get, _Box2D.b2FrictionJointDef_maxForce_set)
    maxTorque = _swig_property(_Box2D.b2FrictionJointDef_maxTorque_get, _Box2D.b2FrictionJointDef_maxTorque_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2FrictionJointDef self) -> long"""
        return _Box2D.b2FrictionJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2FrictionJointDef
b2FrictionJointDef.Initialize = new_instancemethod(_Box2D.b2FrictionJointDef_Initialize, None, b2FrictionJointDef)
b2FrictionJointDef.__hash__ = new_instancemethod(_Box2D.b2FrictionJointDef___hash__, None, b2FrictionJointDef)
b2FrictionJointDef_swigregister = _Box2D.b2FrictionJointDef_swigregister
b2FrictionJointDef_swigregister(b2FrictionJointDef)

class b2FrictionJoint(b2Joint):
    """Friction joint. This is used for top-down friction. It provides 2D translational friction and angular friction."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetLocalAnchorA(self):
        """GetLocalAnchorA(b2FrictionJoint self) -> b2Vec2"""
        return _Box2D.b2FrictionJoint_GetLocalAnchorA(self)


    def GetLocalAnchorB(self):
        """GetLocalAnchorB(b2FrictionJoint self) -> b2Vec2"""
        return _Box2D.b2FrictionJoint_GetLocalAnchorB(self)


    def __SetMaxForce(self, force):
        """
        __SetMaxForce(b2FrictionJoint self, float32 force)

        Set the maximum friction force in N.
        """
        return _Box2D.b2FrictionJoint___SetMaxForce(self, force)


    def __GetMaxForce(self):
        """
        __GetMaxForce(b2FrictionJoint self) -> float32

        Get the maximum friction force in N.
        """
        return _Box2D.b2FrictionJoint___GetMaxForce(self)


    def __SetMaxTorque(self, torque):
        """
        __SetMaxTorque(b2FrictionJoint self, float32 torque)

        Set the maximum friction torque in N*m.
        """
        return _Box2D.b2FrictionJoint___SetMaxTorque(self, torque)


    def __GetMaxTorque(self):
        """
        __GetMaxTorque(b2FrictionJoint self) -> float32

        Get the maximum friction torque in N*m.
        """
        return _Box2D.b2FrictionJoint___GetMaxTorque(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2FrictionJoint self) -> long"""
        return _Box2D.b2FrictionJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


            # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    maxTorque = property(__GetMaxTorque, __SetMaxTorque)

    __swig_destroy__ = _Box2D.delete_b2FrictionJoint
b2FrictionJoint.GetLocalAnchorA = new_instancemethod(_Box2D.b2FrictionJoint_GetLocalAnchorA, None, b2FrictionJoint)
b2FrictionJoint.GetLocalAnchorB = new_instancemethod(_Box2D.b2FrictionJoint_GetLocalAnchorB, None, b2FrictionJoint)
b2FrictionJoint.__SetMaxForce = new_instancemethod(_Box2D.b2FrictionJoint___SetMaxForce, None, b2FrictionJoint)
b2FrictionJoint.__GetMaxForce = new_instancemethod(_Box2D.b2FrictionJoint___GetMaxForce, None, b2FrictionJoint)
b2FrictionJoint.__SetMaxTorque = new_instancemethod(_Box2D.b2FrictionJoint___SetMaxTorque, None, b2FrictionJoint)
b2FrictionJoint.__GetMaxTorque = new_instancemethod(_Box2D.b2FrictionJoint___GetMaxTorque, None, b2FrictionJoint)
b2FrictionJoint.__hash__ = new_instancemethod(_Box2D.b2FrictionJoint___hash__, None, b2FrictionJoint)
b2FrictionJoint_swigregister = _Box2D.b2FrictionJoint_swigregister
b2FrictionJoint_swigregister(b2FrictionJoint)

class b2GearJointDef(b2JointDef):
    """Gear joint definition. This definition requires two existing revolute or prismatic joints (any combination will work). The provided joints must attach a dynamic body to a static body."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2GearJointDef_swiginit(self,_Box2D.new_b2GearJointDef())
        _init_kwargs(self, **kwargs)


    joint1 = _swig_property(_Box2D.b2GearJointDef_joint1_get, _Box2D.b2GearJointDef_joint1_set)
    joint2 = _swig_property(_Box2D.b2GearJointDef_joint2_get, _Box2D.b2GearJointDef_joint2_set)
    ratio = _swig_property(_Box2D.b2GearJointDef_ratio_get, _Box2D.b2GearJointDef_ratio_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2GearJointDef self) -> long"""
        return _Box2D.b2GearJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2GearJointDef
b2GearJointDef.__hash__ = new_instancemethod(_Box2D.b2GearJointDef___hash__, None, b2GearJointDef)
b2GearJointDef_swigregister = _Box2D.b2GearJointDef_swigregister
b2GearJointDef_swigregister(b2GearJointDef)

class b2GearJoint(b2Joint):
    """
    A gear joint is used to connect two joints together. Either joint can be a revolute or prismatic joint. You specify a gear ratio to bind the motions together: coordinate1 + ratio * coordinate2 = constant The ratio can be negative or positive. If one joint is a revolute joint and the other joint is a prismatic joint, then the ratio will have units of length or units of 1/length. 
    WARNING: 
    The revolute and prismatic joints must be attached to fixed bodies (which must be body1 on those joints).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetJoint1(self):
        """GetJoint1(b2GearJoint self) -> b2Joint"""
        return _Box2D.b2GearJoint_GetJoint1(self)


    def GetJoint2(self):
        """GetJoint2(b2GearJoint self) -> b2Joint"""
        return _Box2D.b2GearJoint_GetJoint2(self)


    def __SetRatio(self, ratio):
        """
        __SetRatio(b2GearJoint self, float32 ratio)

        Set/Get the gear ratio.
        """
        return _Box2D.b2GearJoint___SetRatio(self, ratio)


    def __GetRatio(self):
        """__GetRatio(b2GearJoint self) -> float32"""
        return _Box2D.b2GearJoint___GetRatio(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2GearJoint self) -> long"""
        return _Box2D.b2GearJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


            # Read-write properties
    ratio = property(__GetRatio, __SetRatio)


    __swig_destroy__ = _Box2D.delete_b2GearJoint
b2GearJoint.GetJoint1 = new_instancemethod(_Box2D.b2GearJoint_GetJoint1, None, b2GearJoint)
b2GearJoint.GetJoint2 = new_instancemethod(_Box2D.b2GearJoint_GetJoint2, None, b2GearJoint)
b2GearJoint.__SetRatio = new_instancemethod(_Box2D.b2GearJoint___SetRatio, None, b2GearJoint)
b2GearJoint.__GetRatio = new_instancemethod(_Box2D.b2GearJoint___GetRatio, None, b2GearJoint)
b2GearJoint.__hash__ = new_instancemethod(_Box2D.b2GearJoint___hash__, None, b2GearJoint)
b2GearJoint_swigregister = _Box2D.b2GearJoint_swigregister
b2GearJoint_swigregister(b2GearJoint)

class b2MotorJointDef(b2JointDef):
    """Proxy of C++ b2MotorJointDef class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, bodyA=None, bodyB=None, **kwargs):
        _Box2D.b2MotorJointDef_swiginit(self,_Box2D.new_b2MotorJointDef())
        _init_jointdef_kwargs(self, bodyA=bodyA, bodyB=bodyB, **kwargs)
        if bodyA is not None and bodyB is not None:
            if not kwargs:
                self.Initialize(bodyA, bodyB)



    def Initialize(self, bodyA, bodyB):
        """Initialize(b2MotorJointDef self, b2Body bodyA, b2Body bodyB)"""
        return _Box2D.b2MotorJointDef_Initialize(self, bodyA, bodyB)

    linearOffset = _swig_property(_Box2D.b2MotorJointDef_linearOffset_get, _Box2D.b2MotorJointDef_linearOffset_set)
    angularOffset = _swig_property(_Box2D.b2MotorJointDef_angularOffset_get, _Box2D.b2MotorJointDef_angularOffset_set)
    maxForce = _swig_property(_Box2D.b2MotorJointDef_maxForce_get, _Box2D.b2MotorJointDef_maxForce_set)
    maxTorque = _swig_property(_Box2D.b2MotorJointDef_maxTorque_get, _Box2D.b2MotorJointDef_maxTorque_set)
    correctionFactor = _swig_property(_Box2D.b2MotorJointDef_correctionFactor_get, _Box2D.b2MotorJointDef_correctionFactor_set)



    __swig_destroy__ = _Box2D.delete_b2MotorJointDef
b2MotorJointDef.Initialize = new_instancemethod(_Box2D.b2MotorJointDef_Initialize, None, b2MotorJointDef)
b2MotorJointDef_swigregister = _Box2D.b2MotorJointDef_swigregister
b2MotorJointDef_swigregister(b2MotorJointDef)

class b2MotorJoint(b2Joint):
    """Proxy of C++ b2MotorJoint class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __SetLinearOffset(self, linearOffset):
        """__SetLinearOffset(b2MotorJoint self, b2Vec2 linearOffset)"""
        return _Box2D.b2MotorJoint___SetLinearOffset(self, linearOffset)


    def __GetLinearOffset(self):
        """__GetLinearOffset(b2MotorJoint self) -> b2Vec2"""
        return _Box2D.b2MotorJoint___GetLinearOffset(self)


    def __SetAngularOffset(self, angularOffset):
        """__SetAngularOffset(b2MotorJoint self, float32 angularOffset)"""
        return _Box2D.b2MotorJoint___SetAngularOffset(self, angularOffset)


    def __GetAngularOffset(self):
        """__GetAngularOffset(b2MotorJoint self) -> float32"""
        return _Box2D.b2MotorJoint___GetAngularOffset(self)


    def __SetMaxForce(self, force):
        """__SetMaxForce(b2MotorJoint self, float32 force)"""
        return _Box2D.b2MotorJoint___SetMaxForce(self, force)


    def __GetMaxForce(self):
        """__GetMaxForce(b2MotorJoint self) -> float32"""
        return _Box2D.b2MotorJoint___GetMaxForce(self)


    def __SetMaxTorque(self, torque):
        """__SetMaxTorque(b2MotorJoint self, float32 torque)"""
        return _Box2D.b2MotorJoint___SetMaxTorque(self, torque)


    def __GetMaxTorque(self):
        """__GetMaxTorque(b2MotorJoint self) -> float32"""
        return _Box2D.b2MotorJoint___GetMaxTorque(self)


            # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    maxTorque = property(__GetMaxTorque, __SetMaxTorque)
    linearOffset = property(__GetLinearOffset, __SetLinearOffset)
    angularOffset = property(__GetAngularOffset, __SetAngularOffset) 

    __swig_destroy__ = _Box2D.delete_b2MotorJoint
b2MotorJoint.__SetLinearOffset = new_instancemethod(_Box2D.b2MotorJoint___SetLinearOffset, None, b2MotorJoint)
b2MotorJoint.__GetLinearOffset = new_instancemethod(_Box2D.b2MotorJoint___GetLinearOffset, None, b2MotorJoint)
b2MotorJoint.__SetAngularOffset = new_instancemethod(_Box2D.b2MotorJoint___SetAngularOffset, None, b2MotorJoint)
b2MotorJoint.__GetAngularOffset = new_instancemethod(_Box2D.b2MotorJoint___GetAngularOffset, None, b2MotorJoint)
b2MotorJoint.__SetMaxForce = new_instancemethod(_Box2D.b2MotorJoint___SetMaxForce, None, b2MotorJoint)
b2MotorJoint.__GetMaxForce = new_instancemethod(_Box2D.b2MotorJoint___GetMaxForce, None, b2MotorJoint)
b2MotorJoint.__SetMaxTorque = new_instancemethod(_Box2D.b2MotorJoint___SetMaxTorque, None, b2MotorJoint)
b2MotorJoint.__GetMaxTorque = new_instancemethod(_Box2D.b2MotorJoint___GetMaxTorque, None, b2MotorJoint)
b2MotorJoint_swigregister = _Box2D.b2MotorJoint_swigregister
b2MotorJoint_swigregister(b2MotorJoint)

class b2MouseJointDef(b2JointDef):
    """Mouse joint definition. This requires a world target point, tuning parameters, and the time step."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2MouseJointDef_swiginit(self,_Box2D.new_b2MouseJointDef())
        _init_kwargs(self, **kwargs)


    target = _swig_property(_Box2D.b2MouseJointDef_target_get, _Box2D.b2MouseJointDef_target_set)
    maxForce = _swig_property(_Box2D.b2MouseJointDef_maxForce_get, _Box2D.b2MouseJointDef_maxForce_set)
    frequencyHz = _swig_property(_Box2D.b2MouseJointDef_frequencyHz_get, _Box2D.b2MouseJointDef_frequencyHz_set)
    dampingRatio = _swig_property(_Box2D.b2MouseJointDef_dampingRatio_get, _Box2D.b2MouseJointDef_dampingRatio_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2MouseJointDef self) -> long"""
        return _Box2D.b2MouseJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2MouseJointDef
b2MouseJointDef.__hash__ = new_instancemethod(_Box2D.b2MouseJointDef___hash__, None, b2MouseJointDef)
b2MouseJointDef_swigregister = _Box2D.b2MouseJointDef_swigregister
b2MouseJointDef_swigregister(b2MouseJointDef)

class b2MouseJoint(b2Joint):
    """A mouse joint is used to make a point on a body track a specified world point. This a soft constraint with a maximum force. This allows the constraint to stretch and without applying huge forces. NOTE: this joint is not documented in the manual because it was developed to be used in the testbed. If you want to learn how to use the mouse joint, look at the testbed."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __SetTarget(self, target):
        """
        __SetTarget(b2MouseJoint self, b2Vec2 target)

        Use this to update the target point.
        """
        return _Box2D.b2MouseJoint___SetTarget(self, target)


    def __GetTarget(self):
        """__GetTarget(b2MouseJoint self) -> b2Vec2"""
        return _Box2D.b2MouseJoint___GetTarget(self)


    def __SetMaxForce(self, force):
        """
        __SetMaxForce(b2MouseJoint self, float32 force)

        Set/get the maximum force in Newtons.
        """
        return _Box2D.b2MouseJoint___SetMaxForce(self, force)


    def __GetMaxForce(self):
        """__GetMaxForce(b2MouseJoint self) -> float32"""
        return _Box2D.b2MouseJoint___GetMaxForce(self)


    def __SetFrequency(self, hz):
        """
        __SetFrequency(b2MouseJoint self, float32 hz)

        Set/get the frequency in Hertz.
        """
        return _Box2D.b2MouseJoint___SetFrequency(self, hz)


    def __GetFrequency(self):
        """__GetFrequency(b2MouseJoint self) -> float32"""
        return _Box2D.b2MouseJoint___GetFrequency(self)


    def __SetDampingRatio(self, ratio):
        """
        __SetDampingRatio(b2MouseJoint self, float32 ratio)

        Set/get the damping ratio (dimensionless).
        """
        return _Box2D.b2MouseJoint___SetDampingRatio(self, ratio)


    def __GetDampingRatio(self):
        """__GetDampingRatio(b2MouseJoint self) -> float32"""
        return _Box2D.b2MouseJoint___GetDampingRatio(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2MouseJoint self) -> long"""
        return _Box2D.b2MouseJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    frequency = property(__GetFrequency, __SetFrequency)
    dampingRatio = property(__GetDampingRatio, __SetDampingRatio)
    target = property(__GetTarget, __SetTarget)


    __swig_destroy__ = _Box2D.delete_b2MouseJoint
b2MouseJoint.__SetTarget = new_instancemethod(_Box2D.b2MouseJoint___SetTarget, None, b2MouseJoint)
b2MouseJoint.__GetTarget = new_instancemethod(_Box2D.b2MouseJoint___GetTarget, None, b2MouseJoint)
b2MouseJoint.__SetMaxForce = new_instancemethod(_Box2D.b2MouseJoint___SetMaxForce, None, b2MouseJoint)
b2MouseJoint.__GetMaxForce = new_instancemethod(_Box2D.b2MouseJoint___GetMaxForce, None, b2MouseJoint)
b2MouseJoint.__SetFrequency = new_instancemethod(_Box2D.b2MouseJoint___SetFrequency, None, b2MouseJoint)
b2MouseJoint.__GetFrequency = new_instancemethod(_Box2D.b2MouseJoint___GetFrequency, None, b2MouseJoint)
b2MouseJoint.__SetDampingRatio = new_instancemethod(_Box2D.b2MouseJoint___SetDampingRatio, None, b2MouseJoint)
b2MouseJoint.__GetDampingRatio = new_instancemethod(_Box2D.b2MouseJoint___GetDampingRatio, None, b2MouseJoint)
b2MouseJoint.__hash__ = new_instancemethod(_Box2D.b2MouseJoint___hash__, None, b2MouseJoint)
b2MouseJoint_swigregister = _Box2D.b2MouseJoint_swigregister
b2MouseJoint_swigregister(b2MouseJoint)

class b2PrismaticJointDef(b2JointDef):
    """
    Prismatic joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game. 
    WARNING: 
    at least one body should by dynamic with a non-fixed rotation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2PrismaticJointDef_swiginit(self,_Box2D.new_b2PrismaticJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle



    def Initialize(self, bodyA, bodyB, anchor, axis):
        """
        Initialize(b2PrismaticJointDef self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor, b2Vec2 axis)

        Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
        """
        return _Box2D.b2PrismaticJointDef_Initialize(self, bodyA, bodyB, anchor, axis)

    localAnchorA = _swig_property(_Box2D.b2PrismaticJointDef_localAnchorA_get, _Box2D.b2PrismaticJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2PrismaticJointDef_localAnchorB_get, _Box2D.b2PrismaticJointDef_localAnchorB_set)
    localAxisA = _swig_property(_Box2D.b2PrismaticJointDef_localAxisA_get, _Box2D.b2PrismaticJointDef_localAxisA_set)
    referenceAngle = _swig_property(_Box2D.b2PrismaticJointDef_referenceAngle_get, _Box2D.b2PrismaticJointDef_referenceAngle_set)
    enableLimit = _swig_property(_Box2D.b2PrismaticJointDef_enableLimit_get, _Box2D.b2PrismaticJointDef_enableLimit_set)
    lowerTranslation = _swig_property(_Box2D.b2PrismaticJointDef_lowerTranslation_get, _Box2D.b2PrismaticJointDef_lowerTranslation_set)
    upperTranslation = _swig_property(_Box2D.b2PrismaticJointDef_upperTranslation_get, _Box2D.b2PrismaticJointDef_upperTranslation_set)
    enableMotor = _swig_property(_Box2D.b2PrismaticJointDef_enableMotor_get, _Box2D.b2PrismaticJointDef_enableMotor_set)
    maxMotorForce = _swig_property(_Box2D.b2PrismaticJointDef_maxMotorForce_get, _Box2D.b2PrismaticJointDef_maxMotorForce_set)
    motorSpeed = _swig_property(_Box2D.b2PrismaticJointDef_motorSpeed_get, _Box2D.b2PrismaticJointDef_motorSpeed_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2PrismaticJointDef self) -> long"""
        return _Box2D.b2PrismaticJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    def __set_axis(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAxisA=self.bodyA.GetLocalVector(value)
    def __get_axis(self):
        if not self.bodyA:
            raise ValueError('Body A unset; unable to get world vector.')
        return self.bodyA.GetWorldVector(self.localAxisA)

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")
    axis = property(__get_axis, __set_axis, 
            doc="""The world translation axis on bodyA.
                Getting the property depends on bodyA and localAxisA.
                Setting the property requires that bodyA be set.""")

    __swig_destroy__ = _Box2D.delete_b2PrismaticJointDef
b2PrismaticJointDef.Initialize = new_instancemethod(_Box2D.b2PrismaticJointDef_Initialize, None, b2PrismaticJointDef)
b2PrismaticJointDef.__hash__ = new_instancemethod(_Box2D.b2PrismaticJointDef___hash__, None, b2PrismaticJointDef)
b2PrismaticJointDef_swigregister = _Box2D.b2PrismaticJointDef_swigregister
b2PrismaticJointDef_swigregister(b2PrismaticJointDef)

class b2PrismaticJoint(b2Joint):
    """A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in body1. Relative rotation is prevented. You can use a joint limit to restrict the range of motion and a joint motor to drive the motion or to model joint friction."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetLocalAnchorA(self):
        """GetLocalAnchorA(b2PrismaticJoint self) -> b2Vec2"""
        return _Box2D.b2PrismaticJoint_GetLocalAnchorA(self)


    def GetLocalAnchorB(self):
        """GetLocalAnchorB(b2PrismaticJoint self) -> b2Vec2"""
        return _Box2D.b2PrismaticJoint_GetLocalAnchorB(self)


    def GetLocalAxisA(self):
        """GetLocalAxisA(b2PrismaticJoint self) -> b2Vec2"""
        return _Box2D.b2PrismaticJoint_GetLocalAxisA(self)


    def GetReferenceAngle(self):
        """GetReferenceAngle(b2PrismaticJoint self) -> float32"""
        return _Box2D.b2PrismaticJoint_GetReferenceAngle(self)


    def __GetJointTranslation(self):
        """
        __GetJointTranslation(b2PrismaticJoint self) -> float32

        Get the current joint translation, usually in meters.
        """
        return _Box2D.b2PrismaticJoint___GetJointTranslation(self)


    def __GetJointSpeed(self):
        """
        __GetJointSpeed(b2PrismaticJoint self) -> float32

        Get the current joint translation speed, usually in meters per second.
        """
        return _Box2D.b2PrismaticJoint___GetJointSpeed(self)


    def __IsLimitEnabled(self):
        """
        __IsLimitEnabled(b2PrismaticJoint self) -> bool

        Is the joint limit enabled?
        """
        return _Box2D.b2PrismaticJoint___IsLimitEnabled(self)


    def __EnableLimit(self, flag):
        """
        __EnableLimit(b2PrismaticJoint self, bool flag)

        Enable/disable the joint limit.
        """
        return _Box2D.b2PrismaticJoint___EnableLimit(self, flag)


    def __GetLowerLimit(self):
        """
        __GetLowerLimit(b2PrismaticJoint self) -> float32

        Get the lower joint limit, usually in meters.
        """
        return _Box2D.b2PrismaticJoint___GetLowerLimit(self)


    def __GetUpperLimit(self):
        """
        __GetUpperLimit(b2PrismaticJoint self) -> float32

        Get the upper joint limit, usually in meters.
        """
        return _Box2D.b2PrismaticJoint___GetUpperLimit(self)


    def SetLimits(self, lower, upper):
        """
        SetLimits(b2PrismaticJoint self, float32 lower, float32 upper)

        Set the joint limits, usually in meters.
        """
        return _Box2D.b2PrismaticJoint_SetLimits(self, lower, upper)


    def __IsMotorEnabled(self):
        """
        __IsMotorEnabled(b2PrismaticJoint self) -> bool

        Is the joint motor enabled?
        """
        return _Box2D.b2PrismaticJoint___IsMotorEnabled(self)


    def __EnableMotor(self, flag):
        """
        __EnableMotor(b2PrismaticJoint self, bool flag)

        Enable/disable the joint motor.
        """
        return _Box2D.b2PrismaticJoint___EnableMotor(self, flag)


    def __SetMotorSpeed(self, speed):
        """
        __SetMotorSpeed(b2PrismaticJoint self, float32 speed)

        Set the motor speed, usually in meters per second.
        """
        return _Box2D.b2PrismaticJoint___SetMotorSpeed(self, speed)


    def __GetMotorSpeed(self):
        """
        __GetMotorSpeed(b2PrismaticJoint self) -> float32

        Get the motor speed, usually in meters per second.
        """
        return _Box2D.b2PrismaticJoint___GetMotorSpeed(self)


    def __SetMaxMotorForce(self, force):
        """
        __SetMaxMotorForce(b2PrismaticJoint self, float32 force)

        Set the maximum motor force, usually in N.
        """
        return _Box2D.b2PrismaticJoint___SetMaxMotorForce(self, force)


    def __GetMaxMotorForce(self):
        """__GetMaxMotorForce(b2PrismaticJoint self) -> float32"""
        return _Box2D.b2PrismaticJoint___GetMaxMotorForce(self)


    def GetMotorForce(self, inv_dt):
        """
        GetMotorForce(b2PrismaticJoint self, float32 inv_dt) -> float32

        Get the current motor force given the inverse time step, usually in N.
        """
        return _Box2D.b2PrismaticJoint_GetMotorForce(self, inv_dt)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2PrismaticJoint self) -> long"""
        return _Box2D.b2PrismaticJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    limitEnabled = property(__IsLimitEnabled, __EnableLimit)
    upperLimit = property(__GetUpperLimit, lambda self, v: self.SetLimits(self.lowerLimit, v))
    lowerLimit = property(__GetLowerLimit, lambda self, v: self.SetLimits(v, self.upperLimit))
    limits = property(lambda self: (self.lowerLimit, self.upperLimit), lambda self, v: self.SetLimits(*v) )
    maxMotorForce = property(__GetMaxMotorForce, __SetMaxMotorForce)

    # Read-only
    translation = property(__GetJointTranslation, None)
    speed = property(__GetJointSpeed, None)


    __swig_destroy__ = _Box2D.delete_b2PrismaticJoint
b2PrismaticJoint.GetLocalAnchorA = new_instancemethod(_Box2D.b2PrismaticJoint_GetLocalAnchorA, None, b2PrismaticJoint)
b2PrismaticJoint.GetLocalAnchorB = new_instancemethod(_Box2D.b2PrismaticJoint_GetLocalAnchorB, None, b2PrismaticJoint)
b2PrismaticJoint.GetLocalAxisA = new_instancemethod(_Box2D.b2PrismaticJoint_GetLocalAxisA, None, b2PrismaticJoint)
b2PrismaticJoint.GetReferenceAngle = new_instancemethod(_Box2D.b2PrismaticJoint_GetReferenceAngle, None, b2PrismaticJoint)
b2PrismaticJoint.__GetJointTranslation = new_instancemethod(_Box2D.b2PrismaticJoint___GetJointTranslation, None, b2PrismaticJoint)
b2PrismaticJoint.__GetJointSpeed = new_instancemethod(_Box2D.b2PrismaticJoint___GetJointSpeed, None, b2PrismaticJoint)
b2PrismaticJoint.__IsLimitEnabled = new_instancemethod(_Box2D.b2PrismaticJoint___IsLimitEnabled, None, b2PrismaticJoint)
b2PrismaticJoint.__EnableLimit = new_instancemethod(_Box2D.b2PrismaticJoint___EnableLimit, None, b2PrismaticJoint)
b2PrismaticJoint.__GetLowerLimit = new_instancemethod(_Box2D.b2PrismaticJoint___GetLowerLimit, None, b2PrismaticJoint)
b2PrismaticJoint.__GetUpperLimit = new_instancemethod(_Box2D.b2PrismaticJoint___GetUpperLimit, None, b2PrismaticJoint)
b2PrismaticJoint.SetLimits = new_instancemethod(_Box2D.b2PrismaticJoint_SetLimits, None, b2PrismaticJoint)
b2PrismaticJoint.__IsMotorEnabled = new_instancemethod(_Box2D.b2PrismaticJoint___IsMotorEnabled, None, b2PrismaticJoint)
b2PrismaticJoint.__EnableMotor = new_instancemethod(_Box2D.b2PrismaticJoint___EnableMotor, None, b2PrismaticJoint)
b2PrismaticJoint.__SetMotorSpeed = new_instancemethod(_Box2D.b2PrismaticJoint___SetMotorSpeed, None, b2PrismaticJoint)
b2PrismaticJoint.__GetMotorSpeed = new_instancemethod(_Box2D.b2PrismaticJoint___GetMotorSpeed, None, b2PrismaticJoint)
b2PrismaticJoint.__SetMaxMotorForce = new_instancemethod(_Box2D.b2PrismaticJoint___SetMaxMotorForce, None, b2PrismaticJoint)
b2PrismaticJoint.__GetMaxMotorForce = new_instancemethod(_Box2D.b2PrismaticJoint___GetMaxMotorForce, None, b2PrismaticJoint)
b2PrismaticJoint.GetMotorForce = new_instancemethod(_Box2D.b2PrismaticJoint_GetMotorForce, None, b2PrismaticJoint)
b2PrismaticJoint.__hash__ = new_instancemethod(_Box2D.b2PrismaticJoint___hash__, None, b2PrismaticJoint)
b2PrismaticJoint_swigregister = _Box2D.b2PrismaticJoint_swigregister
b2PrismaticJoint_swigregister(b2PrismaticJoint)

class b2PulleyJointDef(b2JointDef):
    """Pulley joint definition. This requires two ground anchors, two dynamic body anchor points, max lengths for each side, and a pulley ratio."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2PulleyJointDef_swiginit(self,_Box2D.new_b2PulleyJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        self.__init_pulley__(**kwargs)

    def __init_pulley__(self, anchorA=None, anchorB=None, lengthA=None, lengthB=None, groundAnchorA=None, groundAnchorB=None, maxLengthA=None, maxLengthB=None, ratio=None, **kwargs):
        lengthA_set, lengthB_set = False, False
        if anchorA is not None or anchorB is not None:
    # Some undoing -- if the user specified the length, we might
    # have overwritten it, so reset it.
            if lengthA is not None:
                self.lengthA = lengthA
                lengthA_set = True
            if lengthB is not None:
                self.lengthB = lengthB
                lengthB_set = True

        if anchorA is not None and groundAnchorA is not None and lengthA is None:
            d1 = self.anchorA - self.groundAnchorA
            self.lengthA = d1.length
            lengthA_set = True

        if anchorB is not None and groundAnchorB is not None and lengthB is None:
            d2 = self.anchorB - self.groundAnchorB
            self.lengthB = d2.length
            lengthB_set=True

        if ratio is not None:
    # Ratio too small?
            assert(self.ratio > globals()['b2_epsilon'])
            if lengthA_set and lengthB_set and maxLengthA is None and maxLengthB is None:
                C = self.lengthA + self.ratio * self.lengthB
                self.maxLengthA = C - self.ratio * b2_minPulleyLength
                self.maxLengthB = (C - b2_minPulleyLength) / self.ratio



    def Initialize(self, bodyA, bodyB, groundAnchorA, groundAnchorB, anchorA, anchorB, ratio):
        """
        Initialize(b2PulleyJointDef self, b2Body bodyA, b2Body bodyB, b2Vec2 groundAnchorA, b2Vec2 groundAnchorB, b2Vec2 anchorA, b2Vec2 anchorB, float32 ratio)

        Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
        """
        return _Box2D.b2PulleyJointDef_Initialize(self, bodyA, bodyB, groundAnchorA, groundAnchorB, anchorA, anchorB, ratio)

    groundAnchorA = _swig_property(_Box2D.b2PulleyJointDef_groundAnchorA_get, _Box2D.b2PulleyJointDef_groundAnchorA_set)
    groundAnchorB = _swig_property(_Box2D.b2PulleyJointDef_groundAnchorB_get, _Box2D.b2PulleyJointDef_groundAnchorB_set)
    localAnchorA = _swig_property(_Box2D.b2PulleyJointDef_localAnchorA_get, _Box2D.b2PulleyJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2PulleyJointDef_localAnchorB_get, _Box2D.b2PulleyJointDef_localAnchorB_set)
    lengthA = _swig_property(_Box2D.b2PulleyJointDef_lengthA_get, _Box2D.b2PulleyJointDef_lengthA_set)
    lengthB = _swig_property(_Box2D.b2PulleyJointDef_lengthB_get, _Box2D.b2PulleyJointDef_lengthB_set)
    ratio = _swig_property(_Box2D.b2PulleyJointDef_ratio_get, _Box2D.b2PulleyJointDef_ratio_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2PulleyJointDef self) -> long"""
        return _Box2D.b2PulleyJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __update_length(self):
        if self.bodyA:
            d1 = self.anchorA - self.groundAnchorA
            self.lengthA = d1.length
        if self.bodyB:
            d1 = self.anchorB - self.groundAnchorB
            self.lengthB = d1.length
    def __set_anchorA(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.__update_length()
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
        self.__update_length()
    def __get_anchorA(self):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2PulleyJointDef
b2PulleyJointDef.Initialize = new_instancemethod(_Box2D.b2PulleyJointDef_Initialize, None, b2PulleyJointDef)
b2PulleyJointDef.__hash__ = new_instancemethod(_Box2D.b2PulleyJointDef___hash__, None, b2PulleyJointDef)
b2PulleyJointDef_swigregister = _Box2D.b2PulleyJointDef_swigregister
b2PulleyJointDef_swigregister(b2PulleyJointDef)
b2_minPulleyLength = b2Globals.b2_minPulleyLength

class b2PulleyJoint(b2Joint):
    """The pulley joint is connected to two bodies and two fixed ground points. The pulley supports a ratio such that: length1 + ratio * length2 <= constant Yes, the force transmitted is scaled by the ratio. The pulley also enforces a maximum length limit on both sides. This is useful to prevent one side of the pulley hitting the top."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __GetGroundAnchorA(self):
        """
        __GetGroundAnchorA(b2PulleyJoint self) -> b2Vec2

        Get the first ground anchor.
        """
        return _Box2D.b2PulleyJoint___GetGroundAnchorA(self)


    def __GetGroundAnchorB(self):
        """
        __GetGroundAnchorB(b2PulleyJoint self) -> b2Vec2

        Get the second ground anchor.
        """
        return _Box2D.b2PulleyJoint___GetGroundAnchorB(self)


    def __GetLengthA(self):
        """__GetLengthA(b2PulleyJoint self) -> float32"""
        return _Box2D.b2PulleyJoint___GetLengthA(self)


    def __GetLengthB(self):
        """__GetLengthB(b2PulleyJoint self) -> float32"""
        return _Box2D.b2PulleyJoint___GetLengthB(self)


    def __GetRatio(self):
        """
        __GetRatio(b2PulleyJoint self) -> float32

        Get the pulley ratio.
        """
        return _Box2D.b2PulleyJoint___GetRatio(self)


    def GetCurrentLengthA(self):
        """GetCurrentLengthA(b2PulleyJoint self) -> float32"""
        return _Box2D.b2PulleyJoint_GetCurrentLengthA(self)


    def GetCurrentLengthB(self):
        """GetCurrentLengthB(b2PulleyJoint self) -> float32"""
        return _Box2D.b2PulleyJoint_GetCurrentLengthB(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2PulleyJoint self) -> long"""
        return _Box2D.b2PulleyJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



            # Read-only
    groundAnchorB = property(__GetGroundAnchorB, None)
    groundAnchorA = property(__GetGroundAnchorA, None)
    ratio = property(__GetRatio, None)
    lengthB = length2 = property(__GetLengthB, None)
    lengthA = length1 = property(__GetLengthA, None)


    __swig_destroy__ = _Box2D.delete_b2PulleyJoint
b2PulleyJoint.__GetGroundAnchorA = new_instancemethod(_Box2D.b2PulleyJoint___GetGroundAnchorA, None, b2PulleyJoint)
b2PulleyJoint.__GetGroundAnchorB = new_instancemethod(_Box2D.b2PulleyJoint___GetGroundAnchorB, None, b2PulleyJoint)
b2PulleyJoint.__GetLengthA = new_instancemethod(_Box2D.b2PulleyJoint___GetLengthA, None, b2PulleyJoint)
b2PulleyJoint.__GetLengthB = new_instancemethod(_Box2D.b2PulleyJoint___GetLengthB, None, b2PulleyJoint)
b2PulleyJoint.__GetRatio = new_instancemethod(_Box2D.b2PulleyJoint___GetRatio, None, b2PulleyJoint)
b2PulleyJoint.GetCurrentLengthA = new_instancemethod(_Box2D.b2PulleyJoint_GetCurrentLengthA, None, b2PulleyJoint)
b2PulleyJoint.GetCurrentLengthB = new_instancemethod(_Box2D.b2PulleyJoint_GetCurrentLengthB, None, b2PulleyJoint)
b2PulleyJoint.__hash__ = new_instancemethod(_Box2D.b2PulleyJoint___hash__, None, b2PulleyJoint)
b2PulleyJoint_swigregister = _Box2D.b2PulleyJoint_swigregister
b2PulleyJoint_swigregister(b2PulleyJoint)

class b2RevoluteJointDef(b2JointDef):
    """Revolute joint definition. This requires defining an anchor point where the bodies are joined. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. You also need to specify the initial relative angle for joint limits. This helps when saving and loading a game. The local anchor points are measured from the body's origin rather than the center of mass because: 1. you might not know where the center of mass will be. 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2RevoluteJointDef_swiginit(self,_Box2D.new_b2RevoluteJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle



    def Initialize(self, bodyA, bodyB, anchor):
        """
        Initialize(b2RevoluteJointDef self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor)

        Initialize the bodies, anchors, and reference angle using a world anchor point.
        """
        return _Box2D.b2RevoluteJointDef_Initialize(self, bodyA, bodyB, anchor)

    localAnchorA = _swig_property(_Box2D.b2RevoluteJointDef_localAnchorA_get, _Box2D.b2RevoluteJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2RevoluteJointDef_localAnchorB_get, _Box2D.b2RevoluteJointDef_localAnchorB_set)
    referenceAngle = _swig_property(_Box2D.b2RevoluteJointDef_referenceAngle_get, _Box2D.b2RevoluteJointDef_referenceAngle_set)
    enableLimit = _swig_property(_Box2D.b2RevoluteJointDef_enableLimit_get, _Box2D.b2RevoluteJointDef_enableLimit_set)
    lowerAngle = _swig_property(_Box2D.b2RevoluteJointDef_lowerAngle_get, _Box2D.b2RevoluteJointDef_lowerAngle_set)
    upperAngle = _swig_property(_Box2D.b2RevoluteJointDef_upperAngle_get, _Box2D.b2RevoluteJointDef_upperAngle_set)
    enableMotor = _swig_property(_Box2D.b2RevoluteJointDef_enableMotor_get, _Box2D.b2RevoluteJointDef_enableMotor_set)
    motorSpeed = _swig_property(_Box2D.b2RevoluteJointDef_motorSpeed_get, _Box2D.b2RevoluteJointDef_motorSpeed_set)
    maxMotorTorque = _swig_property(_Box2D.b2RevoluteJointDef_maxMotorTorque_get, _Box2D.b2RevoluteJointDef_maxMotorTorque_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2RevoluteJointDef self) -> long"""
        return _Box2D.b2RevoluteJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2RevoluteJointDef
b2RevoluteJointDef.Initialize = new_instancemethod(_Box2D.b2RevoluteJointDef_Initialize, None, b2RevoluteJointDef)
b2RevoluteJointDef.__hash__ = new_instancemethod(_Box2D.b2RevoluteJointDef___hash__, None, b2RevoluteJointDef)
b2RevoluteJointDef_swigregister = _Box2D.b2RevoluteJointDef_swigregister
b2RevoluteJointDef_swigregister(b2RevoluteJointDef)

class b2RevoluteJoint(b2Joint):
    """A revolute joint constrains two bodies to share a common point while they are free to rotate about the point. The relative rotation about the shared point is the joint angle. You can limit the relative rotation with a joint limit that specifies a lower and upper angle. You can use a motor to drive the relative rotation about the shared point. A maximum motor torque is provided so that infinite forces are not generated."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetLocalAnchorA(self):
        """GetLocalAnchorA(b2RevoluteJoint self) -> b2Vec2"""
        return _Box2D.b2RevoluteJoint_GetLocalAnchorA(self)


    def GetLocalAnchorB(self):
        """GetLocalAnchorB(b2RevoluteJoint self) -> b2Vec2"""
        return _Box2D.b2RevoluteJoint_GetLocalAnchorB(self)


    def GetReferenceAngle(self):
        """GetReferenceAngle(b2RevoluteJoint self) -> float32"""
        return _Box2D.b2RevoluteJoint_GetReferenceAngle(self)


    def __GetJointAngle(self):
        """
        __GetJointAngle(b2RevoluteJoint self) -> float32

        Get the current joint angle in radians.
        """
        return _Box2D.b2RevoluteJoint___GetJointAngle(self)


    def __GetJointSpeed(self):
        """
        __GetJointSpeed(b2RevoluteJoint self) -> float32

        Get the current joint angle speed in radians per second.
        """
        return _Box2D.b2RevoluteJoint___GetJointSpeed(self)


    def __IsLimitEnabled(self):
        """
        __IsLimitEnabled(b2RevoluteJoint self) -> bool

        Is the joint limit enabled?
        """
        return _Box2D.b2RevoluteJoint___IsLimitEnabled(self)


    def __EnableLimit(self, flag):
        """
        __EnableLimit(b2RevoluteJoint self, bool flag)

        Enable/disable the joint limit.
        """
        return _Box2D.b2RevoluteJoint___EnableLimit(self, flag)


    def __GetLowerLimit(self):
        """
        __GetLowerLimit(b2RevoluteJoint self) -> float32

        Get the lower joint limit in radians.
        """
        return _Box2D.b2RevoluteJoint___GetLowerLimit(self)


    def __GetUpperLimit(self):
        """
        __GetUpperLimit(b2RevoluteJoint self) -> float32

        Get the upper joint limit in radians.
        """
        return _Box2D.b2RevoluteJoint___GetUpperLimit(self)


    def SetLimits(self, lower, upper):
        """
        SetLimits(b2RevoluteJoint self, float32 lower, float32 upper)

        Set the joint limits in radians.
        """
        return _Box2D.b2RevoluteJoint_SetLimits(self, lower, upper)


    def __IsMotorEnabled(self):
        """
        __IsMotorEnabled(b2RevoluteJoint self) -> bool

        Is the joint motor enabled?
        """
        return _Box2D.b2RevoluteJoint___IsMotorEnabled(self)


    def __EnableMotor(self, flag):
        """
        __EnableMotor(b2RevoluteJoint self, bool flag)

        Enable/disable the joint motor.
        """
        return _Box2D.b2RevoluteJoint___EnableMotor(self, flag)


    def __SetMotorSpeed(self, speed):
        """
        __SetMotorSpeed(b2RevoluteJoint self, float32 speed)

        Set the motor speed in radians per second.
        """
        return _Box2D.b2RevoluteJoint___SetMotorSpeed(self, speed)


    def __GetMotorSpeed(self):
        """
        __GetMotorSpeed(b2RevoluteJoint self) -> float32

        Get the motor speed in radians per second.
        """
        return _Box2D.b2RevoluteJoint___GetMotorSpeed(self)


    def __SetMaxMotorTorque(self, torque):
        """
        __SetMaxMotorTorque(b2RevoluteJoint self, float32 torque)

        Set the maximum motor torque, usually in N-m.
        """
        return _Box2D.b2RevoluteJoint___SetMaxMotorTorque(self, torque)


    def GetMaxMotorTorque(self):
        """GetMaxMotorTorque(b2RevoluteJoint self) -> float32"""
        return _Box2D.b2RevoluteJoint_GetMaxMotorTorque(self)


    def GetMotorTorque(self, inv_dt):
        """
        GetMotorTorque(b2RevoluteJoint self, float32 inv_dt) -> float32

        Get the current motor torque given the inverse time step. Unit is N*m.
        """
        return _Box2D.b2RevoluteJoint_GetMotorTorque(self, inv_dt)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2RevoluteJoint self) -> long"""
        return _Box2D.b2RevoluteJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    upperLimit = property(__GetUpperLimit, lambda self, v: self.SetLimits(self.lowerLimit, v))
    lowerLimit = property(__GetLowerLimit, lambda self, v: self.SetLimits(v, self.upperLimit))
    limits = property(lambda self: (self.lowerLimit, self.upperLimit), lambda self, v: self.SetLimits(*v) )
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    limitEnabled = property(__IsLimitEnabled, __EnableLimit)

    # Read-only
    angle = property(__GetJointAngle, None)
    speed = property(__GetJointSpeed, None)

    # Write-only
    maxMotorTorque = property(None, __SetMaxMotorTorque)


    __swig_destroy__ = _Box2D.delete_b2RevoluteJoint
b2RevoluteJoint.GetLocalAnchorA = new_instancemethod(_Box2D.b2RevoluteJoint_GetLocalAnchorA, None, b2RevoluteJoint)
b2RevoluteJoint.GetLocalAnchorB = new_instancemethod(_Box2D.b2RevoluteJoint_GetLocalAnchorB, None, b2RevoluteJoint)
b2RevoluteJoint.GetReferenceAngle = new_instancemethod(_Box2D.b2RevoluteJoint_GetReferenceAngle, None, b2RevoluteJoint)
b2RevoluteJoint.__GetJointAngle = new_instancemethod(_Box2D.b2RevoluteJoint___GetJointAngle, None, b2RevoluteJoint)
b2RevoluteJoint.__GetJointSpeed = new_instancemethod(_Box2D.b2RevoluteJoint___GetJointSpeed, None, b2RevoluteJoint)
b2RevoluteJoint.__IsLimitEnabled = new_instancemethod(_Box2D.b2RevoluteJoint___IsLimitEnabled, None, b2RevoluteJoint)
b2RevoluteJoint.__EnableLimit = new_instancemethod(_Box2D.b2RevoluteJoint___EnableLimit, None, b2RevoluteJoint)
b2RevoluteJoint.__GetLowerLimit = new_instancemethod(_Box2D.b2RevoluteJoint___GetLowerLimit, None, b2RevoluteJoint)
b2RevoluteJoint.__GetUpperLimit = new_instancemethod(_Box2D.b2RevoluteJoint___GetUpperLimit, None, b2RevoluteJoint)
b2RevoluteJoint.SetLimits = new_instancemethod(_Box2D.b2RevoluteJoint_SetLimits, None, b2RevoluteJoint)
b2RevoluteJoint.__IsMotorEnabled = new_instancemethod(_Box2D.b2RevoluteJoint___IsMotorEnabled, None, b2RevoluteJoint)
b2RevoluteJoint.__EnableMotor = new_instancemethod(_Box2D.b2RevoluteJoint___EnableMotor, None, b2RevoluteJoint)
b2RevoluteJoint.__SetMotorSpeed = new_instancemethod(_Box2D.b2RevoluteJoint___SetMotorSpeed, None, b2RevoluteJoint)
b2RevoluteJoint.__GetMotorSpeed = new_instancemethod(_Box2D.b2RevoluteJoint___GetMotorSpeed, None, b2RevoluteJoint)
b2RevoluteJoint.__SetMaxMotorTorque = new_instancemethod(_Box2D.b2RevoluteJoint___SetMaxMotorTorque, None, b2RevoluteJoint)
b2RevoluteJoint.GetMaxMotorTorque = new_instancemethod(_Box2D.b2RevoluteJoint_GetMaxMotorTorque, None, b2RevoluteJoint)
b2RevoluteJoint.GetMotorTorque = new_instancemethod(_Box2D.b2RevoluteJoint_GetMotorTorque, None, b2RevoluteJoint)
b2RevoluteJoint.__hash__ = new_instancemethod(_Box2D.b2RevoluteJoint___hash__, None, b2RevoluteJoint)
b2RevoluteJoint_swigregister = _Box2D.b2RevoluteJoint_swigregister
b2RevoluteJoint_swigregister(b2RevoluteJoint)

class b2RopeJointDef(b2JointDef):
    """Rope joint definition. This requires two body anchor points and a maximum lengths. Note: by default the connected objects will not collide. see collideConnected in  b2JointDef."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2RopeJointDef_swiginit(self,_Box2D.new_b2RopeJointDef())
        _init_jointdef_kwargs(self, **kwargs)


    localAnchorA = _swig_property(_Box2D.b2RopeJointDef_localAnchorA_get, _Box2D.b2RopeJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2RopeJointDef_localAnchorB_get, _Box2D.b2RopeJointDef_localAnchorB_set)
    maxLength = _swig_property(_Box2D.b2RopeJointDef_maxLength_get, _Box2D.b2RopeJointDef_maxLength_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2RopeJointDef self) -> long"""
        return _Box2D.b2RopeJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __set_anchorA(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchorA(self):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2RopeJointDef
b2RopeJointDef.__hash__ = new_instancemethod(_Box2D.b2RopeJointDef___hash__, None, b2RopeJointDef)
b2RopeJointDef_swigregister = _Box2D.b2RopeJointDef_swigregister
b2RopeJointDef_swigregister(b2RopeJointDef)

class b2RopeJoint(b2Joint):
    """A rope joint enforces a maximum distance between two points on two bodies. It has no other effect. Warning: if you attempt to change the maximum length during the simulation you will get some non-physical behavior. A model that would allow you to dynamically modify the length would have some sponginess, so I chose not to implement it that way. See  b2DistanceJointif you want to dynamically control length."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetLocalAnchorA(self):
        """GetLocalAnchorA(b2RopeJoint self) -> b2Vec2"""
        return _Box2D.b2RopeJoint_GetLocalAnchorA(self)


    def GetLocalAnchorB(self):
        """GetLocalAnchorB(b2RopeJoint self) -> b2Vec2"""
        return _Box2D.b2RopeJoint_GetLocalAnchorB(self)


    def SetMaxLength(self, length):
        """SetMaxLength(b2RopeJoint self, float32 length)"""
        return _Box2D.b2RopeJoint_SetMaxLength(self, length)


    def __GetMaxLength(self):
        """
        __GetMaxLength(b2RopeJoint self) -> float32

        Get the maximum length of the rope.
        """
        return _Box2D.b2RopeJoint___GetMaxLength(self)


    def __GetLimitState(self):
        """__GetLimitState(b2RopeJoint self) -> b2LimitState"""
        return _Box2D.b2RopeJoint___GetLimitState(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2RopeJoint self) -> long"""
        return _Box2D.b2RopeJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



            # Read-only properties
    maxLength = property(__GetMaxLength, None)
    limitState = property(__GetLimitState, None)

    # Read-write properties


    __swig_destroy__ = _Box2D.delete_b2RopeJoint
b2RopeJoint.GetLocalAnchorA = new_instancemethod(_Box2D.b2RopeJoint_GetLocalAnchorA, None, b2RopeJoint)
b2RopeJoint.GetLocalAnchorB = new_instancemethod(_Box2D.b2RopeJoint_GetLocalAnchorB, None, b2RopeJoint)
b2RopeJoint.SetMaxLength = new_instancemethod(_Box2D.b2RopeJoint_SetMaxLength, None, b2RopeJoint)
b2RopeJoint.__GetMaxLength = new_instancemethod(_Box2D.b2RopeJoint___GetMaxLength, None, b2RopeJoint)
b2RopeJoint.__GetLimitState = new_instancemethod(_Box2D.b2RopeJoint___GetLimitState, None, b2RopeJoint)
b2RopeJoint.__hash__ = new_instancemethod(_Box2D.b2RopeJoint___hash__, None, b2RopeJoint)
b2RopeJoint_swigregister = _Box2D.b2RopeJoint_swigregister
b2RopeJoint_swigregister(b2RopeJoint)

class b2WeldJointDef(b2JointDef):
    """Weld joint definition. You need to specify local anchor points where they are attached and the relative body angle. The position of the anchor points is important for computing the reaction torque."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2WeldJointDef_swiginit(self,_Box2D.new_b2WeldJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle



    def Initialize(self, bodyA, bodyB, anchor):
        """
        Initialize(b2WeldJointDef self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor)

        Initialize the bodies, anchors, and reference angle using a world anchor point.
        """
        return _Box2D.b2WeldJointDef_Initialize(self, bodyA, bodyB, anchor)

    localAnchorA = _swig_property(_Box2D.b2WeldJointDef_localAnchorA_get, _Box2D.b2WeldJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2WeldJointDef_localAnchorB_get, _Box2D.b2WeldJointDef_localAnchorB_set)
    referenceAngle = _swig_property(_Box2D.b2WeldJointDef_referenceAngle_get, _Box2D.b2WeldJointDef_referenceAngle_set)
    frequencyHz = _swig_property(_Box2D.b2WeldJointDef_frequencyHz_get, _Box2D.b2WeldJointDef_frequencyHz_set)
    dampingRatio = _swig_property(_Box2D.b2WeldJointDef_dampingRatio_get, _Box2D.b2WeldJointDef_dampingRatio_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2WeldJointDef self) -> long"""
        return _Box2D.b2WeldJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2WeldJointDef
b2WeldJointDef.Initialize = new_instancemethod(_Box2D.b2WeldJointDef_Initialize, None, b2WeldJointDef)
b2WeldJointDef.__hash__ = new_instancemethod(_Box2D.b2WeldJointDef___hash__, None, b2WeldJointDef)
b2WeldJointDef_swigregister = _Box2D.b2WeldJointDef_swigregister
b2WeldJointDef_swigregister(b2WeldJointDef)

class b2WeldJoint(b2Joint):
    """A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the island constraint solver is approximate."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetLocalAnchorA(self):
        """GetLocalAnchorA(b2WeldJoint self) -> b2Vec2"""
        return _Box2D.b2WeldJoint_GetLocalAnchorA(self)


    def GetLocalAnchorB(self):
        """GetLocalAnchorB(b2WeldJoint self) -> b2Vec2"""
        return _Box2D.b2WeldJoint_GetLocalAnchorB(self)


    def GetReferenceAngle(self):
        """GetReferenceAngle(b2WeldJoint self) -> float32"""
        return _Box2D.b2WeldJoint_GetReferenceAngle(self)


    def SetFrequency(self, hz):
        """SetFrequency(b2WeldJoint self, float32 hz)"""
        return _Box2D.b2WeldJoint_SetFrequency(self, hz)


    def GetFrequency(self):
        """GetFrequency(b2WeldJoint self) -> float32"""
        return _Box2D.b2WeldJoint_GetFrequency(self)


    def SetDampingRatio(self, ratio):
        """SetDampingRatio(b2WeldJoint self, float32 ratio)"""
        return _Box2D.b2WeldJoint_SetDampingRatio(self, ratio)


    def GetDampingRatio(self):
        """GetDampingRatio(b2WeldJoint self) -> float32"""
        return _Box2D.b2WeldJoint_GetDampingRatio(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2WeldJoint self) -> long"""
        return _Box2D.b2WeldJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 

    __swig_destroy__ = _Box2D.delete_b2WeldJoint
b2WeldJoint.GetLocalAnchorA = new_instancemethod(_Box2D.b2WeldJoint_GetLocalAnchorA, None, b2WeldJoint)
b2WeldJoint.GetLocalAnchorB = new_instancemethod(_Box2D.b2WeldJoint_GetLocalAnchorB, None, b2WeldJoint)
b2WeldJoint.GetReferenceAngle = new_instancemethod(_Box2D.b2WeldJoint_GetReferenceAngle, None, b2WeldJoint)
b2WeldJoint.SetFrequency = new_instancemethod(_Box2D.b2WeldJoint_SetFrequency, None, b2WeldJoint)
b2WeldJoint.GetFrequency = new_instancemethod(_Box2D.b2WeldJoint_GetFrequency, None, b2WeldJoint)
b2WeldJoint.SetDampingRatio = new_instancemethod(_Box2D.b2WeldJoint_SetDampingRatio, None, b2WeldJoint)
b2WeldJoint.GetDampingRatio = new_instancemethod(_Box2D.b2WeldJoint_GetDampingRatio, None, b2WeldJoint)
b2WeldJoint.__hash__ = new_instancemethod(_Box2D.b2WeldJoint___hash__, None, b2WeldJoint)
b2WeldJoint_swigregister = _Box2D.b2WeldJoint_swigregister
b2WeldJoint_swigregister(b2WeldJoint)

class b2WheelJointDef(b2JointDef):
    """Line joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, **kwargs):
        _Box2D.b2WheelJointDef_swiginit(self,_Box2D.new_b2WheelJointDef())
        _init_jointdef_kwargs(self, **kwargs)



    def Initialize(self, bodyA, bodyB, anchor, axis):
        """
        Initialize(b2WheelJointDef self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor, b2Vec2 axis)

        Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
        """
        return _Box2D.b2WheelJointDef_Initialize(self, bodyA, bodyB, anchor, axis)

    localAnchorA = _swig_property(_Box2D.b2WheelJointDef_localAnchorA_get, _Box2D.b2WheelJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2WheelJointDef_localAnchorB_get, _Box2D.b2WheelJointDef_localAnchorB_set)
    localAxisA = _swig_property(_Box2D.b2WheelJointDef_localAxisA_get, _Box2D.b2WheelJointDef_localAxisA_set)
    enableMotor = _swig_property(_Box2D.b2WheelJointDef_enableMotor_get, _Box2D.b2WheelJointDef_enableMotor_set)
    maxMotorTorque = _swig_property(_Box2D.b2WheelJointDef_maxMotorTorque_get, _Box2D.b2WheelJointDef_maxMotorTorque_set)
    motorSpeed = _swig_property(_Box2D.b2WheelJointDef_motorSpeed_get, _Box2D.b2WheelJointDef_motorSpeed_set)
    frequencyHz = _swig_property(_Box2D.b2WheelJointDef_frequencyHz_get, _Box2D.b2WheelJointDef_frequencyHz_set)
    dampingRatio = _swig_property(_Box2D.b2WheelJointDef_dampingRatio_get, _Box2D.b2WheelJointDef_dampingRatio_set)

    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2WheelJointDef self) -> long"""
        return _Box2D.b2WheelJointDef___hash__(self)


    def __repr__(self):
        return _format_repr(self) 


    def __set_anchor(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        if not self.bodyB:
            raise ValueError('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise ValueError('Neither body was set; unable to get world point.')
    def __set_axis(self, value):
        if not self.bodyA:
            raise ValueError('bodyA not set.')
        self.localAxisA=self.bodyA.GetLocalVector(value)
    def __get_axis(self):
        if self.bodyA:
            return self.bodyA.GetWorldVector(self.localAxisA)
        raise ValueError('Body A unset; unable to get world vector.')

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")
    axis = property(__get_axis, __set_axis, 
            doc="""The world translation axis on bodyA.
                Getting the property depends on bodyA and localAxisA.
                Setting the property requires that bodyA be set.""")

    __swig_destroy__ = _Box2D.delete_b2WheelJointDef
b2WheelJointDef.Initialize = new_instancemethod(_Box2D.b2WheelJointDef_Initialize, None, b2WheelJointDef)
b2WheelJointDef.__hash__ = new_instancemethod(_Box2D.b2WheelJointDef___hash__, None, b2WheelJointDef)
b2WheelJointDef_swigregister = _Box2D.b2WheelJointDef_swigregister
b2WheelJointDef_swigregister(b2WheelJointDef)

class b2WheelJoint(b2Joint):
    """A line joint. This joint provides two degrees of freedom: translation along an axis fixed in body1 and rotation in the plane. You can use a joint limit to restrict the range of motion and a joint motor to drive the rotation or to model rotational friction. This joint is designed for vehicle suspensions."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetLocalAnchorA(self):
        """GetLocalAnchorA(b2WheelJoint self) -> b2Vec2"""
        return _Box2D.b2WheelJoint_GetLocalAnchorA(self)


    def GetLocalAnchorB(self):
        """GetLocalAnchorB(b2WheelJoint self) -> b2Vec2"""
        return _Box2D.b2WheelJoint_GetLocalAnchorB(self)


    def GetLocalAxisA(self):
        """GetLocalAxisA(b2WheelJoint self) -> b2Vec2"""
        return _Box2D.b2WheelJoint_GetLocalAxisA(self)


    def __GetJointTranslation(self):
        """
        __GetJointTranslation(b2WheelJoint self) -> float32

        Get the current joint translation, usually in meters.
        """
        return _Box2D.b2WheelJoint___GetJointTranslation(self)


    def __GetJointSpeed(self):
        """
        __GetJointSpeed(b2WheelJoint self) -> float32

        Get the current joint translation speed, usually in meters per second.
        """
        return _Box2D.b2WheelJoint___GetJointSpeed(self)


    def __IsMotorEnabled(self):
        """
        __IsMotorEnabled(b2WheelJoint self) -> bool

        Is the joint motor enabled?
        """
        return _Box2D.b2WheelJoint___IsMotorEnabled(self)


    def __EnableMotor(self, flag):
        """
        __EnableMotor(b2WheelJoint self, bool flag)

        Enable/disable the joint motor.
        """
        return _Box2D.b2WheelJoint___EnableMotor(self, flag)


    def __SetMotorSpeed(self, speed):
        """
        __SetMotorSpeed(b2WheelJoint self, float32 speed)

        Set the motor speed, usually in radians per second.
        """
        return _Box2D.b2WheelJoint___SetMotorSpeed(self, speed)


    def __GetMotorSpeed(self):
        """
        __GetMotorSpeed(b2WheelJoint self) -> float32

        Get the motor speed, usually in radians per second.
        """
        return _Box2D.b2WheelJoint___GetMotorSpeed(self)


    def __SetMaxMotorTorque(self, torque):
        """
        __SetMaxMotorTorque(b2WheelJoint self, float32 torque)

        Set/Get the maximum motor force, usually in N-m.
        """
        return _Box2D.b2WheelJoint___SetMaxMotorTorque(self, torque)


    def __GetMaxMotorTorque(self):
        """__GetMaxMotorTorque(b2WheelJoint self) -> float32"""
        return _Box2D.b2WheelJoint___GetMaxMotorTorque(self)


    def GetMotorTorque(self, inv_dt):
        """
        GetMotorTorque(b2WheelJoint self, float32 inv_dt) -> float32

        Get the current motor torque given the inverse time step, usually in N-m.
        """
        return _Box2D.b2WheelJoint_GetMotorTorque(self, inv_dt)


    def __SetSpringFrequencyHz(self, hz):
        """
        __SetSpringFrequencyHz(b2WheelJoint self, float32 hz)

        Set/Get the spring frequency in hertz. Setting the frequency to zero disables the spring.
        """
        return _Box2D.b2WheelJoint___SetSpringFrequencyHz(self, hz)


    def __GetSpringFrequencyHz(self):
        """__GetSpringFrequencyHz(b2WheelJoint self) -> float32"""
        return _Box2D.b2WheelJoint___GetSpringFrequencyHz(self)


    def __SetSpringDampingRatio(self, ratio):
        """
        __SetSpringDampingRatio(b2WheelJoint self, float32 ratio)

        Set/Get the spring damping ratio.
        """
        return _Box2D.b2WheelJoint___SetSpringDampingRatio(self, ratio)


    def __GetSpringDampingRatio(self):
        """__GetSpringDampingRatio(b2WheelJoint self) -> float32"""
        return _Box2D.b2WheelJoint___GetSpringDampingRatio(self)


    __dir__ = _dir_filter


    def __hash__(self):
        """__hash__(b2WheelJoint self) -> long"""
        return _Box2D.b2WheelJoint___hash__(self)


    def __repr__(self):
        return _format_repr(self) 



            # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    maxMotorTorque = property(__GetMaxMotorTorque, __SetMaxMotorTorque)
    springFrequencyHz = property(__GetSpringFrequencyHz , __SetSpringFrequencyHz)
    springDampingRatio = property(__GetSpringDampingRatio , __SetSpringDampingRatio)

    # Read-only
    speed = property(__GetJointSpeed, None)
    translation = property(__GetJointTranslation, None)


    __swig_destroy__ = _Box2D.delete_b2WheelJoint
b2WheelJoint.GetLocalAnchorA = new_instancemethod(_Box2D.b2WheelJoint_GetLocalAnchorA, None, b2WheelJoint)
b2WheelJoint.GetLocalAnchorB = new_instancemethod(_Box2D.b2WheelJoint_GetLocalAnchorB, None, b2WheelJoint)
b2WheelJoint.GetLocalAxisA = new_instancemethod(_Box2D.b2WheelJoint_GetLocalAxisA, None, b2WheelJoint)
b2WheelJoint.__GetJointTranslation = new_instancemethod(_Box2D.b2WheelJoint___GetJointTranslation, None, b2WheelJoint)
b2WheelJoint.__GetJointSpeed = new_instancemethod(_Box2D.b2WheelJoint___GetJointSpeed, None, b2WheelJoint)
b2WheelJoint.__IsMotorEnabled = new_instancemethod(_Box2D.b2WheelJoint___IsMotorEnabled, None, b2WheelJoint)
b2WheelJoint.__EnableMotor = new_instancemethod(_Box2D.b2WheelJoint___EnableMotor, None, b2WheelJoint)
b2WheelJoint.__SetMotorSpeed = new_instancemethod(_Box2D.b2WheelJoint___SetMotorSpeed, None, b2WheelJoint)
b2WheelJoint.__GetMotorSpeed = new_instancemethod(_Box2D.b2WheelJoint___GetMotorSpeed, None, b2WheelJoint)
b2WheelJoint.__SetMaxMotorTorque = new_instancemethod(_Box2D.b2WheelJoint___SetMaxMotorTorque, None, b2WheelJoint)
b2WheelJoint.__GetMaxMotorTorque = new_instancemethod(_Box2D.b2WheelJoint___GetMaxMotorTorque, None, b2WheelJoint)
b2WheelJoint.GetMotorTorque = new_instancemethod(_Box2D.b2WheelJoint_GetMotorTorque, None, b2WheelJoint)
b2WheelJoint.__SetSpringFrequencyHz = new_instancemethod(_Box2D.b2WheelJoint___SetSpringFrequencyHz, None, b2WheelJoint)
b2WheelJoint.__GetSpringFrequencyHz = new_instancemethod(_Box2D.b2WheelJoint___GetSpringFrequencyHz, None, b2WheelJoint)
b2WheelJoint.__SetSpringDampingRatio = new_instancemethod(_Box2D.b2WheelJoint___SetSpringDampingRatio, None, b2WheelJoint)
b2WheelJoint.__GetSpringDampingRatio = new_instancemethod(_Box2D.b2WheelJoint___GetSpringDampingRatio, None, b2WheelJoint)
b2WheelJoint.__hash__ = new_instancemethod(_Box2D.b2WheelJoint___hash__, None, b2WheelJoint)
b2WheelJoint_swigregister = _Box2D.b2WheelJoint_swigregister
b2WheelJoint_swigregister(b2WheelJoint)


        # Backward-compatibility 
b2LoopShape = b2ChainShape

# Initialize the alternative namespace b2.*, and clean-up the
# dir listing of Box2D by removing *_swigregister.
#
# To see what this is, try import Box2D; print(dir(Box2D.b2))
from . import b2

s=None
to_remove=[]
for s in locals():
    if s.endswith('_swigregister'):
        to_remove.append(s)
    elif s!='b2' and s.startswith('b2'):
        if s[2]=='_': # Covers b2_*
            setattr(b2, s[3].lower() + s[4:], locals()[s])
        else: # The other b2*
            if s[3].isupper():
                setattr(b2, s[2:], locals()[s])
            else:
                setattr(b2, s[2].lower() + s[3:], locals()[s])
for s in to_remove:
    del locals()[s]

del s
del to_remove



