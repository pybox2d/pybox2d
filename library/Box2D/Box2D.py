# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info
if version_info >= (3,0,0):
    new_instancemethod = lambda func, inst, cls: _Box2D.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Box2D', [dirname(__file__)])
        except ImportError:
            import _Box2D
            return _Box2D
        if fp is not None:
            try:
                _mod = imp.load_module('_Box2D', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Box2D = swig_import_helper()
    del swig_import_helper
else:
    import _Box2D
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


def _dir_filter(self):
    # Using introspection, mimic dir() by adding up all of the __dicts__
    # for the current class and all base classes (type(self).__mro__ returns
    # all of the classes that make it up)
    # Basically filters by:
    # __x__ OK
    # __x bad
    # _classname bad
    def check(s):
        if s.startswith('__'):
            if s.endswith('__'):
                return True
            else:
                return False
        else:
            for typename in typenames:
                if typename in s:
                    return False
            return True
    
    keys=sum([list(c.__dict__.keys()) for c in type(self).__mro__], [])
    typenames=["_%s" % c.__name__ for c in type(self).__mro__]
    ret=[s for s in list(set(keys)) if check(s)]
    ret.sort()
    return ret


def _init_kwargs(self, **kwargs):
    for key, value in list(kwargs.items()):
        try:
            setattr(self, key, value)
        except Exception as ex:
            raise ex.__class__('Failed on kwargs for %s.%s: %s' \
                        % (self.__class__.__name__, key, ex))
def _init_jointdef_kwargs(self, **kwargs):
    keys = list(kwargs.items()) 
    if 'bodyA' in kwargs or 'bodyB' in kwargs:
        # A little trick, make sure that bodyA and bodyB are defined before the rest
        bodies = dict((key, kwargs[key]) for key in kwargs.keys()
                            if key in ('bodyA', 'bodyB'))
        _init_kwargs(self, **bodies)
        others = dict((key, kwargs[key]) for key in kwargs.keys()
                            if key not in ('bodyA', 'bodyB'))
        _init_kwargs(self, **others)
    else:
        _init_kwargs(self, **kwargs)

_format_recursed=0
def _format_repr(item, props, indent_amount=4, max_level=4, max_str_len=250, max_sub_lines=10):
    global _format_recursed
    _format_recursed+=1
    indent_str=' ' * (_format_recursed*indent_amount) 
    ret=['%s(' % item.__class__.__name__]

    #ret.append(str(_format_recursed))
    if _format_recursed > max_level:
        _format_recursed-=1
        return indent_str + '(*recursion*)'
    
    for prop in props:
        try:
            s=repr(getattr(item, prop))
        except Exception as ex:
            s='(*repr failed: %s*)' % ex

        if s.count('\n') > max_sub_lines:
            length=0
            for i, line in enumerate(s.split('\n')[:max_sub_lines]):
                length+=len(line)
                if length > max_str_len:
                    ending_delim=''
                    for j in s[::-1]:
                        if j in ')]}':
                            ending_delim+=j
                        else:
                            break
                    ret[-1]+='(...) %s' % ending_delim[::-1]
                    break

                if i==0:
                    ret.append('%s=%s' % (prop, line))
                else:
                    ret.append(line) 
        else:
            if '\n' in s:
                toadd=s.split('\n')
                ret.append('%s=%s' % (prop, toadd[0]))
                ret.extend(toadd[1:])
            else:
                ret.append('%s=%s,' % (prop, s))
    
    separator='\n%s' % indent_str
    _format_recursed-=1
    
    if len(ret) <= 3:
        ret[-1]+=')'
        if _format_recursed==0:
            return ''.join(ret)
        else:
            return [''.join(ret)]
    else:
        ret.append(')')
        return separator.join(ret)


def __jointeq(*args, **kwargs):
  """__jointeq(b2Joint a, b2Joint b) -> bool"""
  return _Box2D.__jointeq(*args, **kwargs)

def __bodyeq(*args, **kwargs):
  """__bodyeq(b2Body a, b2Body b) -> bool"""
  return _Box2D.__bodyeq(*args, **kwargs)

def __shapeeq(*args, **kwargs):
  """__shapeeq(b2Shape a, b2Shape b) -> bool"""
  return _Box2D.__shapeeq(*args, **kwargs)

def __fixtureeq(*args, **kwargs):
  """__fixtureeq(b2Fixture a, b2Fixture b) -> bool"""
  return _Box2D.__fixtureeq(*args, **kwargs)

def __b2ComputeCentroid(*args, **kwargs):
  """__b2ComputeCentroid(b2Vec2 vs, int32 count) -> b2Vec2"""
  return _Box2D.__b2ComputeCentroid(*args, **kwargs)

def b2CheckVertices(*args, **kwargs):
  """b2CheckVertices(b2Vec2 vertices, int32 count, bool additional_checks = True) -> bool"""
  return _Box2D.b2CheckVertices(*args, **kwargs)

def b2CheckPolygon(*args, **kwargs):
  """b2CheckPolygon(b2PolygonShape shape, bool additional_checks = True) -> bool"""
  return _Box2D.b2CheckPolygon(*args, **kwargs)
RAND_LIMIT = _Box2D.RAND_LIMIT
b2_epsilon = 1.192092896e-07

class _indexable_generator(list):
    def __init__(self, iter):
        list.__init__(self)
        self.iter=iter
        self.__full=False
    def __len__(self):
        self.__fill_list__()
        return list.len(self)
    def __iter__(self):
        for item in self.iter:
            self.append(item)
            yield item
        self.__full=True
    def __fill_list__(self):
        for item in self.iter:
            self.append(item)
        self.__full=True
    def __getitem__(self, i):
        """Support indexing positive/negative elements of the generator,
        but no slices. If you want those, use list(generator)"""
        if not self.__full:
            if i < 0:
                self.__fill_list__()
            elif i >= list.__len__(self):
                diff=i-list.__len__(self)+1
                for j in xrange(diff):
                    value=self.iter.next()
                    self.append(value)

        return list.__getitem__(self,i)

def _generator_from_linked_list(first):
    if first:
        one = first
        while one:
            yield one
            one = one.next

def _list_from_linked_list(first):
    if not first:
        return []

    one = first
    lst = []
    while one:
        lst.append(one)
        one = one.next

    # linked lists are stored in reverse order from creation order
    lst.reverse() 
    return lst

# Support using == on bodies, joints, and shapes
def b2ShapeCompare(a, b):
    if not isinstance(a, b2Shape) or not isinstance(b, b2Shape):
        return False
    return __shapeeq(a, b)
def b2BodyCompare(a, b):
    if not isinstance(a, b2Body) or not isinstance(b, b2Body):
        return False
    return __bodyeq(a, b)
def b2JointCompare(a, b):
    if not isinstance(a, b2Joint) or not isinstance(b, b2Joint):
        return False
    return __jointeq(a, b)
def b2FixtureCompare(a, b):
    if not isinstance(a, b2Fixture) or not isinstance(b, b2Fixture):
        return False
    return __fixtureeq(a, b)


def b2Distance(*args, **kwargs):
    """
    Compute the closest points between two shapes.

    Can be called one of two ways:
    + b2Distance(b2DistanceInput) # utilizes the b2DistanceInput structure, where you define your own proxies

    Or utilizing kwargs:
    + b2Distance(shapeA=a, shapeB=b, transformA=sa, transformB=sb [, useRadii=True])

    Returns a tuple in the form:
     ((pointAx, pointAy), (pointBx, pointBy), distance, iterations)
    """
    if len(args) in (1, 7):
        out=_b2Distance(*args)
    elif kwargs: # use kwargs
        shapeA = kwargs['shapeA']
        shapeB = kwargs['shapeB']
        transformA = kwargs['transformA']
        transformB = kwargs['transformB']
        if 'useRadii' in kwargs:
            useRadii = kwargs['useRadii']
        else:
            useRadii=True
        if 'idxA' in kwargs:
            idxA = kwargs['idxA']
        else:
            idxA=0
        if 'idxB' in kwargs:
            idxB = kwargs['idxB']
        else:
            idxB=0
        out=_b2Distance(shapeA, idxA, shapeB, idxB, transformA, transformB, useRadii)
    else:
        raise ValueError('Expected arguments for b2Distance or kwargs')

    return (tuple(out.pointA), tuple(out.pointB), out.distance, out.iterations)


def b2GetPointStates(*args, **kwargs):
  """
    b2GetPointStates(b2Manifold manifold1, b2Manifold manifold2) -> PyObject

    Compute the point states given two manifolds. The states pertain to the transition from manifold1 to manifold2. So state1 is either persist or remove while state2 is either add or persist.
    """
  return _Box2D.b2GetPointStates(*args, **kwargs)
class b2ContactPoint(object):
    """Proxy of C++ b2ContactPoint class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2ContactPoint_swiginit(self,_Box2D.new_b2ContactPoint())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactPoint
    fixtureA = _swig_property(_Box2D.b2ContactPoint_fixtureA_get, _Box2D.b2ContactPoint_fixtureA_set)
    fixtureB = _swig_property(_Box2D.b2ContactPoint_fixtureB_get, _Box2D.b2ContactPoint_fixtureB_set)
    normal = _swig_property(_Box2D.b2ContactPoint_normal_get, _Box2D.b2ContactPoint_normal_set)
    position = _swig_property(_Box2D.b2ContactPoint_position_get, _Box2D.b2ContactPoint_position_set)
    state = _swig_property(_Box2D.b2ContactPoint_state_get, _Box2D.b2ContactPoint_state_set)
    def __repr__(self):
        return _format_repr(self, ['fixtureA','fixtureB','normal','position','state']) 

b2ContactPoint_swigregister = _Box2D.b2ContactPoint_swigregister
b2ContactPoint_swigregister(b2ContactPoint)
b2Globals = _Box2D.b2Globals

def b2Random(*args):
  """
    b2Random() -> float32
    b2Random(float32 lo, float32 hi) -> float32
    """
  return _Box2D.b2Random(*args)

def _b2Distance(*args):
  """
    _b2Distance(b2Shape shapeA, int idxA, b2Shape shapeB, int idxB, 
        b2Transform transformA, b2Transform transformB, 
        bool useRadii = True) -> b2DistanceOutput
    _b2Distance(b2DistanceInput input) -> b2DistanceOutput
    """
  return _Box2D._b2Distance(*args)

def b2TimeOfImpact(*args, **kwargs):
    """
    Compute the upper bound on time before two shapes penetrate. Time is represented as
    a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,
    non-tunneling collision. If you change the time interval, you should call this function
    again.
    Note: use b2Distance to compute the contact point and normal at the time of impact.
    
    Can be called one of several ways:
    + b2TimeOfImpact(b2TOIInput) # utilizes the b2TOIInput structure, where you define your own proxies

    Or utilizing kwargs:
    + b2TimeOfImpact(shapeA=a, shapeB=b, idxA=0, idxB=0, sweepA=sa, sweepB=sb, tMax=t)
    Where idxA and idxB are optional and used only if the shapes are loops (they indicate which section to use.)
    sweep[A,B] are of type b2Sweep.

    Returns a tuple in the form:
    (output state, time of impact)

    Where output state is in b2TOIOutput.[
            e_unknown, 
            e_failed,
            e_overlapped,
            e_touching,
            e_separated ]
    """
    if len(args) == 5 or len(args) == 1:
        out=_b2TimeOfImpact(*args)
    elif kwargs: # use kwargs
        shapeA = kwargs['shapeA']
        shapeB = kwargs['shapeB']
        sweepA = kwargs['sweepA']
        sweepB = kwargs['sweepB']
        tMax = kwargs['tMax']
        if 'idxA' in kwargs:
            idxA = kwargs['idxA']
        else:
            idxA=0
        if 'idxB' in kwargs:
            idxB = kwargs['idxB']
        else:
            idxB=0
        out=_b2TimeOfImpact(shapeA, idxA, shapeB, idxB, sweepA, sweepB, tMax)
    else:
        raise ValueError('Expected arguments for b2TimeOfImpact or kwargs')

    return (out.state, out.t)

class b2AssertException(object):
    """Proxy of C++ b2AssertException class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __repr__(self):
        return "b2AssertException()"

    def __init__(self): 
        """__init__(self) -> b2AssertException"""
        _Box2D.b2AssertException_swiginit(self,_Box2D.new_b2AssertException())
    __swig_destroy__ = _Box2D.delete_b2AssertException
b2AssertException_swigregister = _Box2D.b2AssertException_swigregister
b2AssertException_swigregister(b2AssertException)

def _b2TimeOfImpact(*args):
  """
    _b2TimeOfImpact(b2Shape shapeA, int idxA, b2Shape shapeB, int idxB, 
        b2Sweep sweepA, b2Sweep sweepB, float32 tMax) -> b2TOIOutput
    _b2TimeOfImpact(b2TOIInput input) -> b2TOIOutput
    """
  return _Box2D._b2TimeOfImpact(*args)

b2_pi = _Box2D.b2_pi
b2_maxManifoldPoints = _Box2D.b2_maxManifoldPoints
b2_maxPolygonVertices = _Box2D.b2_maxPolygonVertices
b2_aabbExtension = _Box2D.b2_aabbExtension
b2_aabbMultiplier = _Box2D.b2_aabbMultiplier
b2_linearSlop = _Box2D.b2_linearSlop
b2_angularSlop = _Box2D.b2_angularSlop
b2_polygonRadius = _Box2D.b2_polygonRadius
b2_maxSubSteps = _Box2D.b2_maxSubSteps
b2_maxTOIContacts = _Box2D.b2_maxTOIContacts
b2_velocityThreshold = _Box2D.b2_velocityThreshold
b2_maxLinearCorrection = _Box2D.b2_maxLinearCorrection
b2_maxAngularCorrection = _Box2D.b2_maxAngularCorrection
b2_maxTranslation = _Box2D.b2_maxTranslation
b2_maxTranslationSquared = _Box2D.b2_maxTranslationSquared
b2_maxRotation = _Box2D.b2_maxRotation
b2_maxRotationSquared = _Box2D.b2_maxRotationSquared
b2_contactBaumgarte = _Box2D.b2_contactBaumgarte
b2_timeToSleep = _Box2D.b2_timeToSleep
b2_linearSleepTolerance = _Box2D.b2_linearSleepTolerance
b2_angularSleepTolerance = _Box2D.b2_angularSleepTolerance

def b2Alloc(*args, **kwargs):
  """
    b2Alloc(int32 size) -> void

    Implement this function to use your own memory allocator.
    """
  return _Box2D.b2Alloc(*args, **kwargs)

def b2Free(*args, **kwargs):
  """
    b2Free(void mem)

    If you implement b2Alloc, you should also implement this function.
    """
  return _Box2D.b2Free(*args, **kwargs)
class b2Version(object):
    """Version numbering scheme. See http://en.wikipedia.org/wiki/Software_versioning"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    major = _swig_property(_Box2D.b2Version_major_get, _Box2D.b2Version_major_set)
    minor = _swig_property(_Box2D.b2Version_minor_get, _Box2D.b2Version_minor_set)
    revision = _swig_property(_Box2D.b2Version_revision_get, _Box2D.b2Version_revision_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['major','minor','revision']) 

    def __repr__(self):
        return "b2Version(%s.%s.%s)" % (self.major, self.minor, self.revision)

    def __init__(self, **kwargs):
        _Box2D.b2Version_swiginit(self,_Box2D.new_b2Version())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Version
b2Version_swigregister = _Box2D.b2Version_swigregister
b2Version_swigregister(b2Version)


def b2IsValid(*args, **kwargs):
  """
    b2IsValid(float32 x) -> bool

    This function is used to ensure that a floating point number is not a NaN or infinity.
    """
  return _Box2D.b2IsValid(*args, **kwargs)

def b2InvSqrt(*args, **kwargs):
  """
    b2InvSqrt(float32 x) -> float32

    This is a approximate yet fast inverse square-root.
    """
  return _Box2D.b2InvSqrt(*args, **kwargs)
class b2Vec2(object):
    """A 2D column vector."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetZero(self):
        """
        SetZero(self)

        Set this vector to all zeros.
        """
        return _Box2D.b2Vec2_SetZero(self)

    def Set(self, *args, **kwargs):
        """
        Set(self, float32 x_, float32 y_)

        Set this vector to some specified coordinates.
        """
        return _Box2D.b2Vec2_Set(self, *args, **kwargs)

    def __neg__(self):
        """__neg__(self) -> b2Vec2"""
        return _Box2D.b2Vec2___neg__(self)

    def __call__(self, *args):
        """
        __call__(self, int32 i) -> float32
        __call__(self, int32 i) -> float32
        """
        return _Box2D.b2Vec2___call__(self, *args)

    def __add_vector(self, *args, **kwargs):
        """__add_vector(self, b2Vec2 v)"""
        return _Box2D.b2Vec2___add_vector(self, *args, **kwargs)

    def __sub_vector(self, *args, **kwargs):
        """__sub_vector(self, b2Vec2 v)"""
        return _Box2D.b2Vec2___sub_vector(self, *args, **kwargs)

    def __mul_float(self, *args, **kwargs):
        """__mul_float(self, float32 a)"""
        return _Box2D.b2Vec2___mul_float(self, *args, **kwargs)

    def __Length(self):
        """
        __Length(self) -> float32

        Get the length of this vector (the norm).
        """
        return _Box2D.b2Vec2___Length(self)

    def __LengthSquared(self):
        """
        __LengthSquared(self) -> float32

        Get the length squared. For performance, use this instead of  b2Vec2::Length(if possible).
        """
        return _Box2D.b2Vec2___LengthSquared(self)

    def Normalize(self):
        """
        Normalize(self) -> float32

        Convert this vector into a unit vector. Returns the length.
        """
        return _Box2D.b2Vec2_Normalize(self)

    def __IsValid(self):
        """
        __IsValid(self) -> bool

        Does this vector contain finite coordinates?
        """
        return _Box2D.b2Vec2___IsValid(self)

    def __Skew(self):
        """
        __Skew(self) -> b2Vec2

        Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        """
        return _Box2D.b2Vec2___Skew(self)

    x = _swig_property(_Box2D.b2Vec2_x_get, _Box2D.b2Vec2_x_set)
    y = _swig_property(_Box2D.b2Vec2_y_get, _Box2D.b2Vec2_y_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['length','lengthSquared','skew','tuple','valid','x','y']) 

    def __init__(self, *args): 
        """
        __init__(self) -> b2Vec2
        __init__(self, float32 x, float32 y) -> b2Vec2
        __init__(self, b2Vec2 other) -> b2Vec2

        Construct using coordinates.
        """
        _Box2D.b2Vec2_swiginit(self,_Box2D.new_b2Vec2(*args))
    __iter__ = lambda self: iter( (self.x, self.y) )
    __eq__ = lambda self, other: self.__equ(other)
    __ne__ = lambda self,other: not self.__equ(other)
    def __repr__(self):
        return "b2Vec2(%g,%g)" % (self.x, self.y)
    def __len__(self):
        return 2
    def __neg__(self):
        return b2Vec2(-self.x, -self.y)
    def __copy__(self):
        return b2Vec2(self.x, self.y)
    def copy(self):
        """
        Return a copy of the vector.
        Remember that the following:
            a = b2Vec2()
            b = a
        Does not copy the vector itself, but b now refers to a.
        """
        return b2Vec2(self.x, self.y)
    def __iadd__(self, other):
        self.__add_vector(other)
        return self
    def __isub__(self, other):
        self.__sub_vector(other)
        return self
    def __imul__(self, a):
        self.__mul_float(a)
        return self
    def __itruediv__(self, a):
        self.__div_float(a)
        return self
    def __idiv__(self, a):
        self.__div_float(a)
        return self
    def __set(self, x, y):
        self.x = x
        self.y = y
    def __nonzero__(self):
        return self.x!=0.0 or self.y!=0.0

    tuple = property(lambda self: (self.x, self.y), lambda self, value: self.__set(*value))
    length = property(__Length, None)
    lengthSquared = property(__LengthSquared, None)
    valid = property(__IsValid, None)
    skew = property(__Skew, None) 


    def cross(self, *args):
        """
        cross(self, b2Vec2 other) -> float32
        cross(self, float32 s) -> b2Vec2
        """
        return _Box2D.b2Vec2_cross(self, *args)

    def __getitem__(self, *args, **kwargs):
        """__getitem__(self, int i) -> float32"""
        return _Box2D.b2Vec2___getitem__(self, *args, **kwargs)

    def __setitem__(self, *args, **kwargs):
        """__setitem__(self, int i, float32 value)"""
        return _Box2D.b2Vec2___setitem__(self, *args, **kwargs)

    def __equ(self, *args, **kwargs):
        """__equ(self, b2Vec2 other) -> bool"""
        return _Box2D.b2Vec2___equ(self, *args, **kwargs)

    def dot(self, *args, **kwargs):
        """dot(self, b2Vec2 other) -> float32"""
        return _Box2D.b2Vec2_dot(self, *args, **kwargs)

    def __truediv__(self, *args, **kwargs):
        """__truediv__(self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___truediv__(self, *args, **kwargs)

    def __div__(self, *args, **kwargs):
        """__div__(self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___div__(self, *args, **kwargs)

    def __mul__(self, *args, **kwargs):
        """__mul__(self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___mul__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, b2Vec2 other) -> b2Vec2"""
        return _Box2D.b2Vec2___add__(self, *args, **kwargs)

    def __sub__(self, *args, **kwargs):
        """__sub__(self, b2Vec2 other) -> b2Vec2"""
        return _Box2D.b2Vec2___sub__(self, *args, **kwargs)

    def __rmul__(self, *args, **kwargs):
        """__rmul__(self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___rmul__(self, *args, **kwargs)

    def __rdiv__(self, *args, **kwargs):
        """__rdiv__(self, float32 a) -> b2Vec2"""
        return _Box2D.b2Vec2___rdiv__(self, *args, **kwargs)

    def __div_float(self, *args, **kwargs):
        """__div_float(self, float32 a)"""
        return _Box2D.b2Vec2___div_float(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2Vec2
b2Vec2.SetZero = new_instancemethod(_Box2D.b2Vec2_SetZero,None,b2Vec2)
b2Vec2.Set = new_instancemethod(_Box2D.b2Vec2_Set,None,b2Vec2)
b2Vec2.__neg__ = new_instancemethod(_Box2D.b2Vec2___neg__,None,b2Vec2)
b2Vec2.__call__ = new_instancemethod(_Box2D.b2Vec2___call__,None,b2Vec2)
b2Vec2.__add_vector = new_instancemethod(_Box2D.b2Vec2___add_vector,None,b2Vec2)
b2Vec2.__sub_vector = new_instancemethod(_Box2D.b2Vec2___sub_vector,None,b2Vec2)
b2Vec2.__mul_float = new_instancemethod(_Box2D.b2Vec2___mul_float,None,b2Vec2)
b2Vec2.__Length = new_instancemethod(_Box2D.b2Vec2___Length,None,b2Vec2)
b2Vec2.__LengthSquared = new_instancemethod(_Box2D.b2Vec2___LengthSquared,None,b2Vec2)
b2Vec2.Normalize = new_instancemethod(_Box2D.b2Vec2_Normalize,None,b2Vec2)
b2Vec2.__IsValid = new_instancemethod(_Box2D.b2Vec2___IsValid,None,b2Vec2)
b2Vec2.__Skew = new_instancemethod(_Box2D.b2Vec2___Skew,None,b2Vec2)
b2Vec2.cross = new_instancemethod(_Box2D.b2Vec2_cross,None,b2Vec2)
b2Vec2.__getitem__ = new_instancemethod(_Box2D.b2Vec2___getitem__,None,b2Vec2)
b2Vec2.__setitem__ = new_instancemethod(_Box2D.b2Vec2___setitem__,None,b2Vec2)
b2Vec2.__equ = new_instancemethod(_Box2D.b2Vec2___equ,None,b2Vec2)
b2Vec2.dot = new_instancemethod(_Box2D.b2Vec2_dot,None,b2Vec2)
b2Vec2.__truediv__ = new_instancemethod(_Box2D.b2Vec2___truediv__,None,b2Vec2)
b2Vec2.__div__ = new_instancemethod(_Box2D.b2Vec2___div__,None,b2Vec2)
b2Vec2.__mul__ = new_instancemethod(_Box2D.b2Vec2___mul__,None,b2Vec2)
b2Vec2.__add__ = new_instancemethod(_Box2D.b2Vec2___add__,None,b2Vec2)
b2Vec2.__sub__ = new_instancemethod(_Box2D.b2Vec2___sub__,None,b2Vec2)
b2Vec2.__rmul__ = new_instancemethod(_Box2D.b2Vec2___rmul__,None,b2Vec2)
b2Vec2.__rdiv__ = new_instancemethod(_Box2D.b2Vec2___rdiv__,None,b2Vec2)
b2Vec2.__div_float = new_instancemethod(_Box2D.b2Vec2___div_float,None,b2Vec2)
b2Vec2_swigregister = _Box2D.b2Vec2_swigregister
b2Vec2_swigregister(b2Vec2)

class b2Vec3(object):
    """A 2D column vector with 3 elements."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def SetZero(self):
        """
        SetZero(self)

        Set this vector to all zeros.
        """
        return _Box2D.b2Vec3_SetZero(self)

    def Set(self, *args, **kwargs):
        """
        Set(self, float32 x_, float32 y_, float32 z_)

        Set this vector to some specified coordinates.
        """
        return _Box2D.b2Vec3_Set(self, *args, **kwargs)

    def __neg__(self):
        """__neg__(self) -> b2Vec3"""
        return _Box2D.b2Vec3___neg__(self)

    def __add_vector(self, *args, **kwargs):
        """__add_vector(self, b2Vec3 v)"""
        return _Box2D.b2Vec3___add_vector(self, *args, **kwargs)

    def __sub_vector(self, *args, **kwargs):
        """__sub_vector(self, b2Vec3 v)"""
        return _Box2D.b2Vec3___sub_vector(self, *args, **kwargs)

    def __mul_float(self, *args, **kwargs):
        """__mul_float(self, float32 s)"""
        return _Box2D.b2Vec3___mul_float(self, *args, **kwargs)

    x = _swig_property(_Box2D.b2Vec3_x_get, _Box2D.b2Vec3_x_set)
    y = _swig_property(_Box2D.b2Vec3_y_get, _Box2D.b2Vec3_y_set)
    z = _swig_property(_Box2D.b2Vec3_z_get, _Box2D.b2Vec3_z_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['length','lengthSquared','tuple','valid','x','y','z']) 

    def __init__(self, *args): 
        """
        __init__(self) -> b2Vec3
        __init__(self, float32 x, float32 y, float32 z) -> b2Vec3
        __init__(self, b2Vec3 other) -> b2Vec3
        __init__(self, b2Vec2 other) -> b2Vec3

        Construct using coordinates.
        """
        _Box2D.b2Vec3_swiginit(self,_Box2D.new_b2Vec3(*args))
    __iter__ = lambda self: iter( (self.x, self.y, self.z) )
    __eq__ = lambda self, other: (self.x == other.x and self.y == other.y and self.z == other.z)
    __ne__ = lambda self,other: (self.x != other.x or self.y != other.y or self.z != other.z)
    def __repr__(self):
        return "b2Vec3(%g,%g,%g)" % (self.x, self.y, self.z)
    def __len__(self):
        return 3
    def __copy__(self):
        return b2Vec3(self.x, self.y, self.z)
    def __neg__(self):
        return b2Vec3(-self.x, -self.y, -self.z)
    def copy(self):
        """
        Return a copy of the vector.
        Remember that the following:
            a = b2Vec3()
            b = a
        Does not copy the vector itself, but b now refers to a.
        """
        return b2Vec3(self.x, self.y, self.z)
    def __iadd__(self, other):
        self.__add_vector(other)
        return self
    def __isub__(self, other):
        self.__sub_vector(other)
        return self
    def __imul__(self, a):
        self.__mul_float(a)
        return self
    def __itruediv__(self, a):
        self.__div_float(a)
        return self
    def __idiv__(self, a):
        self.__div_float(a)
        return self
    def dot(self, v):
        """
        Dot product with v (list/tuple or b2Vec3)
        """
        if isinstance(v, (list, tuple)):
            return self.x*v[0] + self.y*v[1] + self.z*v[2]
        else:
            return self.x*v.x + self.y*v.y + self.z*v.z
    def __set(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z
    def __nonzero__(self):
        return self.x!=0.0 or self.y!=0.0 or self.z!=0.0

    tuple = property(lambda self: (self.x, self.y, self.z), lambda self, value: self.__set(*value))
    length = property(_Box2D.b2Vec3___Length, None)
    lengthSquared = property(_Box2D.b2Vec3___LengthSquared, None)
    valid = property(_Box2D.b2Vec3___IsValid, None)


    def cross(self, *args, **kwargs):
        """cross(self, b2Vec3 b) -> b2Vec3"""
        return _Box2D.b2Vec3_cross(self, *args, **kwargs)

    def __getitem__(self, *args, **kwargs):
        """__getitem__(self, int i) -> float32"""
        return _Box2D.b2Vec3___getitem__(self, *args, **kwargs)

    def __setitem__(self, *args, **kwargs):
        """__setitem__(self, int i, float32 value)"""
        return _Box2D.b2Vec3___setitem__(self, *args, **kwargs)

    def __IsValid(self):
        """__IsValid(self) -> bool"""
        return _Box2D.b2Vec3___IsValid(self)

    def __Length(self):
        """__Length(self) -> float32"""
        return _Box2D.b2Vec3___Length(self)

    def __LengthSquared(self):
        """__LengthSquared(self) -> float32"""
        return _Box2D.b2Vec3___LengthSquared(self)

    def __truediv__(self, *args, **kwargs):
        """__truediv__(self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___truediv__(self, *args, **kwargs)

    def __div__(self, *args, **kwargs):
        """__div__(self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___div__(self, *args, **kwargs)

    def __mul__(self, *args, **kwargs):
        """__mul__(self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___mul__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, b2Vec3 other) -> b2Vec3"""
        return _Box2D.b2Vec3___add__(self, *args, **kwargs)

    def __sub__(self, *args, **kwargs):
        """__sub__(self, b2Vec3 other) -> b2Vec3"""
        return _Box2D.b2Vec3___sub__(self, *args, **kwargs)

    def __rmul__(self, *args, **kwargs):
        """__rmul__(self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___rmul__(self, *args, **kwargs)

    def __rdiv__(self, *args, **kwargs):
        """__rdiv__(self, float32 a) -> b2Vec3"""
        return _Box2D.b2Vec3___rdiv__(self, *args, **kwargs)

    def __div_float(self, *args, **kwargs):
        """__div_float(self, float32 a)"""
        return _Box2D.b2Vec3___div_float(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2Vec3
b2Vec3.SetZero = new_instancemethod(_Box2D.b2Vec3_SetZero,None,b2Vec3)
b2Vec3.Set = new_instancemethod(_Box2D.b2Vec3_Set,None,b2Vec3)
b2Vec3.__neg__ = new_instancemethod(_Box2D.b2Vec3___neg__,None,b2Vec3)
b2Vec3.__add_vector = new_instancemethod(_Box2D.b2Vec3___add_vector,None,b2Vec3)
b2Vec3.__sub_vector = new_instancemethod(_Box2D.b2Vec3___sub_vector,None,b2Vec3)
b2Vec3.__mul_float = new_instancemethod(_Box2D.b2Vec3___mul_float,None,b2Vec3)
b2Vec3.cross = new_instancemethod(_Box2D.b2Vec3_cross,None,b2Vec3)
b2Vec3.__getitem__ = new_instancemethod(_Box2D.b2Vec3___getitem__,None,b2Vec3)
b2Vec3.__setitem__ = new_instancemethod(_Box2D.b2Vec3___setitem__,None,b2Vec3)
b2Vec3.__IsValid = new_instancemethod(_Box2D.b2Vec3___IsValid,None,b2Vec3)
b2Vec3.__Length = new_instancemethod(_Box2D.b2Vec3___Length,None,b2Vec3)
b2Vec3.__LengthSquared = new_instancemethod(_Box2D.b2Vec3___LengthSquared,None,b2Vec3)
b2Vec3.__truediv__ = new_instancemethod(_Box2D.b2Vec3___truediv__,None,b2Vec3)
b2Vec3.__div__ = new_instancemethod(_Box2D.b2Vec3___div__,None,b2Vec3)
b2Vec3.__mul__ = new_instancemethod(_Box2D.b2Vec3___mul__,None,b2Vec3)
b2Vec3.__add__ = new_instancemethod(_Box2D.b2Vec3___add__,None,b2Vec3)
b2Vec3.__sub__ = new_instancemethod(_Box2D.b2Vec3___sub__,None,b2Vec3)
b2Vec3.__rmul__ = new_instancemethod(_Box2D.b2Vec3___rmul__,None,b2Vec3)
b2Vec3.__rdiv__ = new_instancemethod(_Box2D.b2Vec3___rdiv__,None,b2Vec3)
b2Vec3.__div_float = new_instancemethod(_Box2D.b2Vec3___div_float,None,b2Vec3)
b2Vec3_swigregister = _Box2D.b2Vec3_swigregister
b2Vec3_swigregister(b2Vec3)

class b2Mat22(object):
    """A 2-by-2 matrix. Stored in column-major order."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> b2Mat22
        __init__(self, b2Vec2 c1, b2Vec2 c2) -> b2Mat22
        __init__(self, float32 a11, float32 a12, float32 a21, float32 a22) -> b2Mat22
        __init__(self, float32 angle) -> b2Mat22

        Construct this matrix using an angle. This matrix becomes an orthonormal rotation matrix.
        """
        _Box2D.b2Mat22_swiginit(self,_Box2D.new_b2Mat22(*args))
    def __SetAngle(self, *args):
        """
        __SetAngle(self, b2Vec2 c1, b2Vec2 c2)
        __SetAngle(self, float32 angle)

        Initialize this matrix using an angle. This matrix becomes an orthonormal rotation matrix.
        """
        return _Box2D.b2Mat22___SetAngle(self, *args)

    def SetIdentity(self):
        """
        SetIdentity(self)

        Set this to the identity matrix.
        """
        return _Box2D.b2Mat22_SetIdentity(self)

    def SetZero(self):
        """
        SetZero(self)

        Set this matrix to all zeros.
        """
        return _Box2D.b2Mat22_SetZero(self)

    def __GetAngle(self):
        """
        __GetAngle(self) -> float32

        Extract the angle from this matrix (assumed to be a rotation matrix).
        """
        return _Box2D.b2Mat22___GetAngle(self)

    def __GetInverse(self):
        """__GetInverse(self) -> b2Mat22"""
        return _Box2D.b2Mat22___GetInverse(self)

    def Solve(self, *args, **kwargs):
        """
        Solve(self, b2Vec2 b) -> b2Vec2

        Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse in one-shot cases.
        """
        return _Box2D.b2Mat22_Solve(self, *args, **kwargs)

    col1 = _swig_property(_Box2D.b2Mat22_col1_get, _Box2D.b2Mat22_col1_set)
    col2 = _swig_property(_Box2D.b2Mat22_col2_get, _Box2D.b2Mat22_col2_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['angle','col1','col2','inverse']) 

    # Read-only
    inverse = property(__GetInverse, None)
    angle = property(__GetAngle, __SetAngle)

    def __mul__(self, *args):
        """
        __mul__(self, b2Vec2 v) -> b2Vec2
        __mul__(self, b2Mat22 m) -> b2Mat22
        """
        return _Box2D.b2Mat22___mul__(self, *args)

    def __add__(self, *args, **kwargs):
        """__add__(self, b2Mat22 m) -> b2Mat22"""
        return _Box2D.b2Mat22___add__(self, *args, **kwargs)

    def __sub__(self, *args, **kwargs):
        """__sub__(self, b2Mat22 m) -> b2Mat22"""
        return _Box2D.b2Mat22___sub__(self, *args, **kwargs)

    def __iadd(self, *args, **kwargs):
        """__iadd(self, b2Mat22 m)"""
        return _Box2D.b2Mat22___iadd(self, *args, **kwargs)

    def __isub(self, *args, **kwargs):
        """__isub(self, b2Mat22 m)"""
        return _Box2D.b2Mat22___isub(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2Mat22
b2Mat22.__SetAngle = new_instancemethod(_Box2D.b2Mat22___SetAngle,None,b2Mat22)
b2Mat22.SetIdentity = new_instancemethod(_Box2D.b2Mat22_SetIdentity,None,b2Mat22)
b2Mat22.SetZero = new_instancemethod(_Box2D.b2Mat22_SetZero,None,b2Mat22)
b2Mat22.__GetAngle = new_instancemethod(_Box2D.b2Mat22___GetAngle,None,b2Mat22)
b2Mat22.__GetInverse = new_instancemethod(_Box2D.b2Mat22___GetInverse,None,b2Mat22)
b2Mat22.Solve = new_instancemethod(_Box2D.b2Mat22_Solve,None,b2Mat22)
b2Mat22.__mul__ = new_instancemethod(_Box2D.b2Mat22___mul__,None,b2Mat22)
b2Mat22.__add__ = new_instancemethod(_Box2D.b2Mat22___add__,None,b2Mat22)
b2Mat22.__sub__ = new_instancemethod(_Box2D.b2Mat22___sub__,None,b2Mat22)
b2Mat22.__iadd = new_instancemethod(_Box2D.b2Mat22___iadd,None,b2Mat22)
b2Mat22.__isub = new_instancemethod(_Box2D.b2Mat22___isub,None,b2Mat22)
b2Mat22_swigregister = _Box2D.b2Mat22_swigregister
b2Mat22_swigregister(b2Mat22)

class b2Mat33(object):
    """A 3-by-3 matrix. Stored in column-major order."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> b2Mat33
        __init__(self, b2Vec3 c1, b2Vec3 c2, b2Vec3 c3) -> b2Mat33

        Construct this matrix using columns.
        """
        _Box2D.b2Mat33_swiginit(self,_Box2D.new_b2Mat33(*args))
    def SetZero(self):
        """
        SetZero(self)

        Set this matrix to all zeros.
        """
        return _Box2D.b2Mat33_SetZero(self)

    def Solve33(self, *args, **kwargs):
        """
        Solve33(self, b2Vec3 b) -> b2Vec3

        Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse in one-shot cases.
        """
        return _Box2D.b2Mat33_Solve33(self, *args, **kwargs)

    def Solve22(self, *args, **kwargs):
        """
        Solve22(self, b2Vec2 b) -> b2Vec2

        Solve A * x = b, where b is a column vector. This is more efficient than computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix equation.
        """
        return _Box2D.b2Mat33_Solve22(self, *args, **kwargs)

    col1 = _swig_property(_Box2D.b2Mat33_col1_get, _Box2D.b2Mat33_col1_set)
    col2 = _swig_property(_Box2D.b2Mat33_col2_get, _Box2D.b2Mat33_col2_set)
    col3 = _swig_property(_Box2D.b2Mat33_col3_get, _Box2D.b2Mat33_col3_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['col1','col2','col3']) 

    def __mul__(self, *args, **kwargs):
        """__mul__(self, b2Vec3 v) -> b2Vec3"""
        return _Box2D.b2Mat33___mul__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, b2Mat33 other) -> b2Mat33"""
        return _Box2D.b2Mat33___add__(self, *args, **kwargs)

    def __sub__(self, *args, **kwargs):
        """__sub__(self, b2Mat33 other) -> b2Mat33"""
        return _Box2D.b2Mat33___sub__(self, *args, **kwargs)

    def __iadd(self, *args, **kwargs):
        """__iadd(self, b2Mat33 other)"""
        return _Box2D.b2Mat33___iadd(self, *args, **kwargs)

    def __isub(self, *args, **kwargs):
        """__isub(self, b2Mat33 other)"""
        return _Box2D.b2Mat33___isub(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2Mat33
b2Mat33.SetZero = new_instancemethod(_Box2D.b2Mat33_SetZero,None,b2Mat33)
b2Mat33.Solve33 = new_instancemethod(_Box2D.b2Mat33_Solve33,None,b2Mat33)
b2Mat33.Solve22 = new_instancemethod(_Box2D.b2Mat33_Solve22,None,b2Mat33)
b2Mat33.__mul__ = new_instancemethod(_Box2D.b2Mat33___mul__,None,b2Mat33)
b2Mat33.__add__ = new_instancemethod(_Box2D.b2Mat33___add__,None,b2Mat33)
b2Mat33.__sub__ = new_instancemethod(_Box2D.b2Mat33___sub__,None,b2Mat33)
b2Mat33.__iadd = new_instancemethod(_Box2D.b2Mat33___iadd,None,b2Mat33)
b2Mat33.__isub = new_instancemethod(_Box2D.b2Mat33___isub,None,b2Mat33)
b2Mat33_swigregister = _Box2D.b2Mat33_swigregister
b2Mat33_swigregister(b2Mat33)

class b2Transform(object):
    """A transform contains translation and rotation. It is used to represent the position and orientation of rigid frames."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> b2Transform
        __init__(self, b2Vec2 position, b2Mat22 R) -> b2Transform

        Initialize using a position vector and a rotation matrix.
        """
        _Box2D.b2Transform_swiginit(self,_Box2D.new_b2Transform(*args))
    def SetIdentity(self):
        """
        SetIdentity(self)

        Set this to the identity transform.
        """
        return _Box2D.b2Transform_SetIdentity(self)

    def Set(self, *args, **kwargs):
        """
        Set(self, b2Vec2 p, float32 angle)

        Set this based on the position and angle.
        """
        return _Box2D.b2Transform_Set(self, *args, **kwargs)

    def __GetAngle(self):
        """
        __GetAngle(self) -> float32

        Calculate the angle that the rotation matrix represents.
        """
        return _Box2D.b2Transform___GetAngle(self)

    position = _swig_property(_Box2D.b2Transform_position_get, _Box2D.b2Transform_position_set)
    R = _swig_property(_Box2D.b2Transform_R_get, _Box2D.b2Transform_R_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['R','angle','position']) 

    def __SetAngle(self, angle):
        self.R.angle=angle

    # Read-only
    angle = property(__GetAngle, __SetAngle) 

    def __mul__(self, *args, **kwargs):
        """__mul__(self, b2Vec2 v) -> b2Vec2"""
        return _Box2D.b2Transform___mul__(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2Transform
b2Transform.SetIdentity = new_instancemethod(_Box2D.b2Transform_SetIdentity,None,b2Transform)
b2Transform.Set = new_instancemethod(_Box2D.b2Transform_Set,None,b2Transform)
b2Transform.__GetAngle = new_instancemethod(_Box2D.b2Transform___GetAngle,None,b2Transform)
b2Transform.__mul__ = new_instancemethod(_Box2D.b2Transform___mul__,None,b2Transform)
b2Transform_swigregister = _Box2D.b2Transform_swigregister
b2Transform_swigregister(b2Transform)

class b2Sweep(object):
    """This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body origin, which may no coincide with the center of mass. However, to support dynamics we must interpolate the center of mass position."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Advance(self, *args, **kwargs):
        """
        Advance(self, float32 alpha)

        Advance the sweep forward, yielding a new initial state.

        Parameters:
        -----------

        alpha: 
        the new initial time.
        """
        return _Box2D.b2Sweep_Advance(self, *args, **kwargs)

    def Normalize(self):
        """
        Normalize(self)

        Normalize the angles.
        """
        return _Box2D.b2Sweep_Normalize(self)

    localCenter = _swig_property(_Box2D.b2Sweep_localCenter_get, _Box2D.b2Sweep_localCenter_set)
    c0 = _swig_property(_Box2D.b2Sweep_c0_get, _Box2D.b2Sweep_c0_set)
    c = _swig_property(_Box2D.b2Sweep_c_get, _Box2D.b2Sweep_c_set)
    a0 = _swig_property(_Box2D.b2Sweep_a0_get, _Box2D.b2Sweep_a0_set)
    a = _swig_property(_Box2D.b2Sweep_a_get, _Box2D.b2Sweep_a_set)
    alpha0 = _swig_property(_Box2D.b2Sweep_alpha0_get, _Box2D.b2Sweep_alpha0_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['a','a0','alpha0','c','c0','localCenter']) 

    def GetTransform(self, *args):
        """
        GetTransform(self, b2Transform xf, float32 beta)
        GetTransform(self, float32 alpha) -> b2Transform

        Get the interpolated transform at a specific time.

        Parameters:
        -----------

        beta: 
        is a factor in [0,1], where 0 indicates alpha0.
        """
        return _Box2D.b2Sweep_GetTransform(self, *args)

    def __init__(self, **kwargs):
        _Box2D.b2Sweep_swiginit(self,_Box2D.new_b2Sweep())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Sweep
b2Sweep.Advance = new_instancemethod(_Box2D.b2Sweep_Advance,None,b2Sweep)
b2Sweep.Normalize = new_instancemethod(_Box2D.b2Sweep_Normalize,None,b2Sweep)
b2Sweep.GetTransform = new_instancemethod(_Box2D.b2Sweep_GetTransform,None,b2Sweep)
b2Sweep_swigregister = _Box2D.b2Sweep_swigregister
b2Sweep_swigregister(b2Sweep)


def b2DistanceSquared(*args, **kwargs):
  """b2DistanceSquared(b2Vec2 a, b2Vec2 b) -> float32"""
  return _Box2D.b2DistanceSquared(*args, **kwargs)

def b2Min(*args, **kwargs):
  """b2Min(b2Vec2 a, b2Vec2 b) -> b2Vec2"""
  return _Box2D.b2Min(*args, **kwargs)

def b2Max(*args, **kwargs):
  """b2Max(b2Vec2 a, b2Vec2 b) -> b2Vec2"""
  return _Box2D.b2Max(*args, **kwargs)

def b2Clamp(*args, **kwargs):
  """b2Clamp(b2Vec2 a, b2Vec2 low, b2Vec2 high) -> b2Vec2"""
  return _Box2D.b2Clamp(*args, **kwargs)

def b2NextPowerOfTwo(*args, **kwargs):
  """
    b2NextPowerOfTwo(uint32 x) -> uint32

    "Next Largest Power of 2 Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next largest power of 2. For a 32-bit value:"
    """
  return _Box2D.b2NextPowerOfTwo(*args, **kwargs)

def b2IsPowerOfTwo(*args, **kwargs):
  """b2IsPowerOfTwo(uint32 x) -> bool"""
  return _Box2D.b2IsPowerOfTwo(*args, **kwargs)
class b2ContactFeature(object):
    """The features that intersect to form the contact point This must be 4 bytes or less."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_vertex = _Box2D.b2ContactFeature_e_vertex
    e_face = _Box2D.b2ContactFeature_e_face
    indexA = _swig_property(_Box2D.b2ContactFeature_indexA_get, _Box2D.b2ContactFeature_indexA_set)
    indexB = _swig_property(_Box2D.b2ContactFeature_indexB_get, _Box2D.b2ContactFeature_indexB_set)
    typeA = _swig_property(_Box2D.b2ContactFeature_typeA_get, _Box2D.b2ContactFeature_typeA_set)
    typeB = _swig_property(_Box2D.b2ContactFeature_typeB_get, _Box2D.b2ContactFeature_typeB_set)
    def __repr__(self):
        return _format_repr(self, ['indexA','indexB','typeA','typeB']) 

    def __init__(self): 
        """__init__(self) -> b2ContactFeature"""
        _Box2D.b2ContactFeature_swiginit(self,_Box2D.new_b2ContactFeature())
    __swig_destroy__ = _Box2D.delete_b2ContactFeature
b2ContactFeature_swigregister = _Box2D.b2ContactFeature_swigregister
b2ContactFeature_swigregister(b2ContactFeature)
b2Vec2_zero = b2Globals.b2Vec2_zero
b2Mat22_identity = b2Globals.b2Mat22_identity
b2Transform_identity = b2Globals.b2Transform_identity

def b2Dot(*args):
  """
    b2Dot(b2Vec2 a, b2Vec2 b) -> float32
    b2Dot(b2Vec3 a, b2Vec3 b) -> float32

    Perform the dot product on two vectors.
    """
  return _Box2D.b2Dot(*args)

def b2Cross(*args):
  """
    b2Cross(b2Vec2 a, b2Vec2 b) -> float32
    b2Cross(b2Vec2 a, float32 s) -> b2Vec2
    b2Cross(float32 s, b2Vec2 a) -> b2Vec2
    b2Cross(b2Vec3 a, b2Vec3 b) -> b2Vec3

    Perform the cross product on two vectors.
    """
  return _Box2D.b2Cross(*args)

def b2Mul(*args):
  """
    b2Mul(b2Mat22 A, b2Vec2 v) -> b2Vec2
    b2Mul(b2Mat22 A, b2Mat22 B) -> b2Mat22
    b2Mul(b2Mat33 A, b2Vec3 v) -> b2Vec3
    b2Mul(b2Transform T, b2Vec2 v) -> b2Vec2

    Multiply a matrix times a vector.
    """
  return _Box2D.b2Mul(*args)

def b2MulT(*args):
  """
    b2MulT(b2Mat22 A, b2Vec2 v) -> b2Vec2
    b2MulT(b2Mat22 A, b2Mat22 B) -> b2Mat22
    b2MulT(b2Transform T, b2Vec2 v) -> b2Vec2
    b2MulT(b2Transform A, b2Transform B) -> b2Transform

    Multiply a matrix transpose times a vector. If a rotation matrix is provided, then this transforms the vector from one frame to another (inverse transform).
    """
  return _Box2D.b2MulT(*args)

def b2Abs(*args):
  """
    b2Abs(b2Vec2 a) -> b2Vec2
    b2Abs(b2Mat22 A) -> b2Mat22
    """
  return _Box2D.b2Abs(*args)
b2_nullFeature = b2Globals.b2_nullFeature

class b2ContactID(object):
    """Proxy of C++ b2ContactID class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    cf = _swig_property(_Box2D.b2ContactID_cf_get, _Box2D.b2ContactID_cf_set)
    key = _swig_property(_Box2D.b2ContactID_key_get, _Box2D.b2ContactID_key_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['cf','key']) 

    def __init__(self, **kwargs):
        _Box2D.b2ContactID_swiginit(self,_Box2D.new_b2ContactID())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactID
b2ContactID_swigregister = _Box2D.b2ContactID_swigregister
b2ContactID_swigregister(b2ContactID)

class b2ManifoldPoint(object):
    """A manifold point is a contact point belonging to a contact manifold. It holds details related to the geometry and dynamics of the contact points. The local point usage depends on the manifold type: -e_circles: the local center of circleB -e_faceA: the local center of cirlceB or the clip point of polygonB -e_faceB: the clip point of polygonA This structure is stored across time steps, so we keep it small. Note: the impulses are used for internal caching and may not provide reliable contact forces, especially for high speed collisions."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    localPoint = _swig_property(_Box2D.b2ManifoldPoint_localPoint_get, _Box2D.b2ManifoldPoint_localPoint_set)
    normalImpulse = _swig_property(_Box2D.b2ManifoldPoint_normalImpulse_get, _Box2D.b2ManifoldPoint_normalImpulse_set)
    tangentImpulse = _swig_property(_Box2D.b2ManifoldPoint_tangentImpulse_get, _Box2D.b2ManifoldPoint_tangentImpulse_set)
    id = _swig_property(_Box2D.b2ManifoldPoint_id_get, _Box2D.b2ManifoldPoint_id_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['id','isNew','localPoint','normalImpulse','tangentImpulse']) 

    def __init__(self, **kwargs):
        _Box2D.b2ManifoldPoint_swiginit(self,_Box2D.new_b2ManifoldPoint())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ManifoldPoint
b2ManifoldPoint_swigregister = _Box2D.b2ManifoldPoint_swigregister
b2ManifoldPoint_swigregister(b2ManifoldPoint)

class b2Manifold(object):
    """
    A manifold for two touching convex shapes. Box2D supports multiple types of contact:
    clip point versus plane with radius
    point versus point with radius (circles) The local point usage depends on the manifold type: -e_circles: the local center of circleA -e_faceA: the center of faceA -e_faceB: the center of faceB Similarly the local normal usage: -e_circles: not used -e_faceA: the normal on polygonA -e_faceB: the normal on polygonB We store contacts in this way so that position correction can account for movement, which is critical for continuous physics. All contact scenarios must be expressed in one of these types. This structure is stored across time steps, so we keep it small.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_circles = _Box2D.b2Manifold_e_circles
    e_faceA = _Box2D.b2Manifold_e_faceA
    e_faceB = _Box2D.b2Manifold_e_faceB
    localNormal = _swig_property(_Box2D.b2Manifold_localNormal_get, _Box2D.b2Manifold_localNormal_set)
    localPoint = _swig_property(_Box2D.b2Manifold_localPoint_get, _Box2D.b2Manifold_localPoint_set)
    type_ = _swig_property(_Box2D.b2Manifold_type__get, _Box2D.b2Manifold_type__set)
    pointCount = _swig_property(_Box2D.b2Manifold_pointCount_get, _Box2D.b2Manifold_pointCount_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['localNormal','localPoint','pointCount','points','type_']) 

    def __GetPoints(self):
        return [self.__GetPoint(i) for i in range(self.pointCount)]
    points = property(__GetPoints, None)

    def __GetPoint(self, *args, **kwargs):
        """__GetPoint(self, int i) -> b2ManifoldPoint"""
        return _Box2D.b2Manifold___GetPoint(self, *args, **kwargs)

    def __init__(self, **kwargs):
        _Box2D.b2Manifold_swiginit(self,_Box2D.new_b2Manifold())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Manifold
b2Manifold.__GetPoint = new_instancemethod(_Box2D.b2Manifold___GetPoint,None,b2Manifold)
b2Manifold_swigregister = _Box2D.b2Manifold_swigregister
b2Manifold_swigregister(b2Manifold)

class b2WorldManifold(object):
    """This is used to compute the current state of a contact manifold."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Manifold manifold, b2Transform xfA, float32 radiusA, 
            b2Transform xfB, float32 radiusB)

        Evaluate the manifold with supplied transforms. This assumes modest motion from the original state. This does not change the point count, impulses, etc. The radii must come from the shapes that generated the manifold.
        """
        return _Box2D.b2WorldManifold_Initialize(self, *args, **kwargs)

    normal = _swig_property(_Box2D.b2WorldManifold_normal_get, _Box2D.b2WorldManifold_normal_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['normal','points']) 

    def __GetPoints(self):
        """__GetPoints(self) -> PyObject"""
        return _Box2D.b2WorldManifold___GetPoints(self)

    points = property(__GetPoints, None)

    def __init__(self, **kwargs):
        _Box2D.b2WorldManifold_swiginit(self,_Box2D.new_b2WorldManifold())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2WorldManifold
b2WorldManifold.Initialize = new_instancemethod(_Box2D.b2WorldManifold_Initialize,None,b2WorldManifold)
b2WorldManifold.__GetPoints = new_instancemethod(_Box2D.b2WorldManifold___GetPoints,None,b2WorldManifold)
b2WorldManifold_swigregister = _Box2D.b2WorldManifold_swigregister
b2WorldManifold_swigregister(b2WorldManifold)

b2_nullState = _Box2D.b2_nullState
b2_addState = _Box2D.b2_addState
b2_persistState = _Box2D.b2_persistState
b2_removeState = _Box2D.b2_removeState
class b2ClipVertex(object):
    """Used for computing contact manifolds."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    v = _swig_property(_Box2D.b2ClipVertex_v_get, _Box2D.b2ClipVertex_v_set)
    id = _swig_property(_Box2D.b2ClipVertex_id_get, _Box2D.b2ClipVertex_id_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['id','v']) 

    def __init__(self, **kwargs):
        _Box2D.b2ClipVertex_swiginit(self,_Box2D.new_b2ClipVertex())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ClipVertex
b2ClipVertex_swigregister = _Box2D.b2ClipVertex_swigregister
b2ClipVertex_swigregister(b2ClipVertex)

class b2RayCastInput(object):
    """Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1)."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    p1 = _swig_property(_Box2D.b2RayCastInput_p1_get, _Box2D.b2RayCastInput_p1_set)
    p2 = _swig_property(_Box2D.b2RayCastInput_p2_get, _Box2D.b2RayCastInput_p2_set)
    maxFraction = _swig_property(_Box2D.b2RayCastInput_maxFraction_get, _Box2D.b2RayCastInput_maxFraction_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['maxFraction','p1','p2']) 

    def __init__(self, **kwargs):
        _Box2D.b2RayCastInput_swiginit(self,_Box2D.new_b2RayCastInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2RayCastInput
b2RayCastInput_swigregister = _Box2D.b2RayCastInput_swigregister
b2RayCastInput_swigregister(b2RayCastInput)

class b2RayCastOutput(object):
    """Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2 come from  b2RayCastInput."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    normal = _swig_property(_Box2D.b2RayCastOutput_normal_get, _Box2D.b2RayCastOutput_normal_set)
    fraction = _swig_property(_Box2D.b2RayCastOutput_fraction_get, _Box2D.b2RayCastOutput_fraction_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['fraction','normal']) 

    def __init__(self, **kwargs):
        _Box2D.b2RayCastOutput_swiginit(self,_Box2D.new_b2RayCastOutput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2RayCastOutput
b2RayCastOutput_swigregister = _Box2D.b2RayCastOutput_swigregister
b2RayCastOutput_swigregister(b2RayCastOutput)

class b2AABB(object):
    """An axis aligned bounding box."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __IsValid(self):
        """
        __IsValid(self) -> bool

        Verify that the bounds are sorted.
        """
        return _Box2D.b2AABB___IsValid(self)

    def __GetCenter(self):
        """
        __GetCenter(self) -> b2Vec2

        Get the center of the AABB.
        """
        return _Box2D.b2AABB___GetCenter(self)

    def __GetExtents(self):
        """
        __GetExtents(self) -> b2Vec2

        Get the extents of the AABB (half-widths).
        """
        return _Box2D.b2AABB___GetExtents(self)

    def __GetPerimeter(self):
        """
        __GetPerimeter(self) -> float32

        Get the perimeter length.
        """
        return _Box2D.b2AABB___GetPerimeter(self)

    def Combine(self, *args):
        """
        Combine(self, b2AABB aabb)
        Combine(self, b2AABB aabb1, b2AABB aabb2)

        Combine two AABBs into this one.
        """
        return _Box2D.b2AABB_Combine(self, *args)

    def RayCast(self, *args, **kwargs):
        """RayCast(self, b2RayCastOutput output, b2RayCastInput input) -> bool"""
        return _Box2D.b2AABB_RayCast(self, *args, **kwargs)

    lowerBound = _swig_property(_Box2D.b2AABB_lowerBound_get, _Box2D.b2AABB_lowerBound_set)
    upperBound = _swig_property(_Box2D.b2AABB_upperBound_get, _Box2D.b2AABB_upperBound_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['center','extents','lowerBound','perimeter','upperBound','valid']) 

    # Read-only
    valid = property(__IsValid, None)
    extents = property(__GetExtents, None)
    center = property(__GetCenter, None)
    perimeter = property(__GetPerimeter, None)


    def __contains__(self, *args):
        """
        __contains__(self, b2AABB aabb) -> bool
        __contains__(self, b2Vec2 point) -> bool
        """
        return _Box2D.b2AABB___contains__(self, *args)

    def overlaps(self, *args, **kwargs):
        """overlaps(self, b2AABB aabb2) -> bool"""
        return _Box2D.b2AABB_overlaps(self, *args, **kwargs)

    def __init__(self, **kwargs):
        _Box2D.b2AABB_swiginit(self,_Box2D.new_b2AABB())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2AABB
b2AABB.__IsValid = new_instancemethod(_Box2D.b2AABB___IsValid,None,b2AABB)
b2AABB.__GetCenter = new_instancemethod(_Box2D.b2AABB___GetCenter,None,b2AABB)
b2AABB.__GetExtents = new_instancemethod(_Box2D.b2AABB___GetExtents,None,b2AABB)
b2AABB.__GetPerimeter = new_instancemethod(_Box2D.b2AABB___GetPerimeter,None,b2AABB)
b2AABB.Combine = new_instancemethod(_Box2D.b2AABB_Combine,None,b2AABB)
b2AABB.RayCast = new_instancemethod(_Box2D.b2AABB_RayCast,None,b2AABB)
b2AABB.__contains__ = new_instancemethod(_Box2D.b2AABB___contains__,None,b2AABB)
b2AABB.overlaps = new_instancemethod(_Box2D.b2AABB_overlaps,None,b2AABB)
b2AABB_swigregister = _Box2D.b2AABB_swigregister
b2AABB_swigregister(b2AABB)


def b2CollideCircles(*args, **kwargs):
  """
    b2CollideCircles(b2Manifold manifold, b2CircleShape circleA, b2Transform xfA, 
        b2CircleShape circleB, b2Transform xfB)

    Compute the collision manifold between two circles.
    """
  return _Box2D.b2CollideCircles(*args, **kwargs)

def b2CollidePolygonAndCircle(*args, **kwargs):
  """
    b2CollidePolygonAndCircle(b2Manifold manifold, b2PolygonShape polygonA, b2Transform xfA, 
        b2CircleShape circleB, b2Transform xfB)

    Compute the collision manifold between a polygon and a circle.
    """
  return _Box2D.b2CollidePolygonAndCircle(*args, **kwargs)

def b2CollidePolygons(*args, **kwargs):
  """
    b2CollidePolygons(b2Manifold manifold, b2PolygonShape polygonA, b2Transform xfA, 
        b2PolygonShape polygonB, b2Transform xfB)

    Compute the collision manifold between two polygons.
    """
  return _Box2D.b2CollidePolygons(*args, **kwargs)

def b2CollideEdgeAndCircle(*args, **kwargs):
  """
    b2CollideEdgeAndCircle(b2Manifold manifold, b2EdgeShape polygonA, b2Transform xfA, 
        b2CircleShape circleB, b2Transform xfB)

    Compute the collision manifold between an edge and a circle.
    """
  return _Box2D.b2CollideEdgeAndCircle(*args, **kwargs)

def b2CollideEdgeAndPolygon(*args, **kwargs):
  """
    b2CollideEdgeAndPolygon(b2Manifold manifold, b2EdgeShape edgeA, b2Transform xfA, 
        b2PolygonShape circleB, b2Transform xfB)

    Compute the collision manifold between an edge and a circle.
    """
  return _Box2D.b2CollideEdgeAndPolygon(*args, **kwargs)

def b2ClipSegmentToLine(*args, **kwargs):
  """
    b2ClipSegmentToLine(b2ClipVertex vOut, b2ClipVertex vIn, b2Vec2 normal, 
        float32 offset, int32 vertexIndexA) -> int32

    Clipping for contact manifolds.
    """
  return _Box2D.b2ClipSegmentToLine(*args, **kwargs)
class _b2Vec2Array(object):
    """Proxy of C++ _b2Vec2Array class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, size_t nelements) -> _b2Vec2Array"""
        _Box2D._b2Vec2Array_swiginit(self,_Box2D.new__b2Vec2Array(*args, **kwargs))
    __swig_destroy__ = _Box2D.delete__b2Vec2Array
    def __getitem__(self, *args, **kwargs):
        """__getitem__(self, size_t index) -> b2Vec2"""
        return _Box2D._b2Vec2Array___getitem__(self, *args, **kwargs)

    def __setitem__(self, *args, **kwargs):
        """__setitem__(self, size_t index, b2Vec2 value)"""
        return _Box2D._b2Vec2Array___setitem__(self, *args, **kwargs)

    def cast(self):
        """cast(self) -> b2Vec2"""
        return _Box2D._b2Vec2Array_cast(self)

    def frompointer(*args, **kwargs):
        """frompointer(b2Vec2 t) -> _b2Vec2Array"""
        return _Box2D._b2Vec2Array_frompointer(*args, **kwargs)

    frompointer = staticmethod(frompointer)
_b2Vec2Array.__getitem__ = new_instancemethod(_Box2D._b2Vec2Array___getitem__,None,_b2Vec2Array)
_b2Vec2Array.__setitem__ = new_instancemethod(_Box2D._b2Vec2Array___setitem__,None,_b2Vec2Array)
_b2Vec2Array.cast = new_instancemethod(_Box2D._b2Vec2Array_cast,None,_b2Vec2Array)
_b2Vec2Array_swigregister = _Box2D._b2Vec2Array_swigregister
_b2Vec2Array_swigregister(_b2Vec2Array)

def b2TestOverlap(*args):
  """
    b2TestOverlap(b2Shape shapeA, int32 indexA, b2Shape shapeB, int32 indexB, 
        b2Transform xfA, b2Transform xfB) -> bool
    b2TestOverlap(b2AABB a, b2AABB b) -> bool

    Determine if two generic shapes overlap.
    """
  return _Box2D.b2TestOverlap(*args)

def _b2Vec2Array_frompointer(*args, **kwargs):
  """_b2Vec2Array_frompointer(b2Vec2 t) -> _b2Vec2Array"""
  return _Box2D._b2Vec2Array_frompointer(*args, **kwargs)

e_convertVertices = _Box2D.e_convertVertices
class b2Color(object):
    """Color for debug drawing. Each value has the range [0,1]."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def Set(self, *args, **kwargs):
        """Set(self, float32 ri, float32 gi, float32 bi)"""
        return _Box2D.b2Color_Set(self, *args, **kwargs)

    r = _swig_property(_Box2D.b2Color_r_get, _Box2D.b2Color_r_set)
    g = _swig_property(_Box2D.b2Color_g_get, _Box2D.b2Color_g_set)
    b = _swig_property(_Box2D.b2Color_b_get, _Box2D.b2Color_b_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['b','bytes','g','list','r']) 

    def __init__(self, *args): 
        """
        __init__(self) -> b2Color
        __init__(self, float32 r, float32 g, float32 b) -> b2Color
        __init__(self, b2Color other) -> b2Color

        Color for debug drawing. Each value has the range [0,1].
        """
        _Box2D.b2Color_swiginit(self,_Box2D.new_b2Color(*args))
    def __get_bytes(self):
        """__get_bytes(self) -> PyObject"""
        return _Box2D.b2Color___get_bytes(self)

    __iter__ = lambda self: iter((self.r, self.g, self.b)) 
    __eq__ = lambda self, other: self.__equ(other)
    __ne__ = lambda self,other: not self.__equ(other)
    def __repr__(self):
        return "b2Color(%g,%g,%g)" % (self.r, self.g, self.b)
    def __len__(self):
        return 3
    def __copy__(self):
        return b2Color(self.r, self.g, self.b)
    def copy(self):
        return b2Color(self.r, self.g, self.b)
    def __set_bytes(self, value):
        if len(value) != 3:
            raise ValueError('Expected length 3 list')
        self.r, self.g, self.b = value[0]/255, value[1]/255, value[2]/255
    def __set_tuple(self, value):
        if len(value) != 3:
            raise ValueError('Expected length 3 list')
        self.r, self.g, self.b = value[0], value[1], value[2]
    def __nonzero__(self):
        return self.r!=0.0 or self.g!=0.0 or self.b!=0.0

    list  = property(lambda self: list(self), __set_tuple)
    bytes = property(__get_bytes, __set_bytes)

    def __getitem__(self, *args, **kwargs):
        """__getitem__(self, int i) -> float32"""
        return _Box2D.b2Color___getitem__(self, *args, **kwargs)

    def __setitem__(self, *args, **kwargs):
        """__setitem__(self, int i, float32 value)"""
        return _Box2D.b2Color___setitem__(self, *args, **kwargs)

    def __truediv__(self, *args, **kwargs):
        """__truediv__(self, float32 a) -> b2Color"""
        return _Box2D.b2Color___truediv__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(self, b2Color o) -> b2Color"""
        return _Box2D.b2Color___add__(self, *args, **kwargs)

    def __sub__(self, *args, **kwargs):
        """__sub__(self, b2Color o) -> b2Color"""
        return _Box2D.b2Color___sub__(self, *args, **kwargs)

    def __div__(self, *args, **kwargs):
        """__div__(self, float32 a) -> b2Color"""
        return _Box2D.b2Color___div__(self, *args, **kwargs)

    def __rmul__(self, *args, **kwargs):
        """__rmul__(self, float32 a) -> b2Color"""
        return _Box2D.b2Color___rmul__(self, *args, **kwargs)

    def __mul__(self, *args, **kwargs):
        """__mul__(self, float32 a) -> b2Color"""
        return _Box2D.b2Color___mul__(self, *args, **kwargs)

    def __isub(self, *args, **kwargs):
        """__isub(self, b2Color o)"""
        return _Box2D.b2Color___isub(self, *args, **kwargs)

    def __itruediv(self, *args, **kwargs):
        """__itruediv(self, b2Color o)"""
        return _Box2D.b2Color___itruediv(self, *args, **kwargs)

    def __idiv(self, *args, **kwargs):
        """__idiv(self, b2Color o)"""
        return _Box2D.b2Color___idiv(self, *args, **kwargs)

    def __imul(self, *args, **kwargs):
        """__imul(self, b2Color o)"""
        return _Box2D.b2Color___imul(self, *args, **kwargs)

    def __iadd(self, *args, **kwargs):
        """__iadd(self, b2Color o)"""
        return _Box2D.b2Color___iadd(self, *args, **kwargs)

    def __equ(self, *args, **kwargs):
        """__equ(self, b2Color b) -> bool"""
        return _Box2D.b2Color___equ(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2Color
b2Color.Set = new_instancemethod(_Box2D.b2Color_Set,None,b2Color)
b2Color.__get_bytes = new_instancemethod(_Box2D.b2Color___get_bytes,None,b2Color)
b2Color.__getitem__ = new_instancemethod(_Box2D.b2Color___getitem__,None,b2Color)
b2Color.__setitem__ = new_instancemethod(_Box2D.b2Color___setitem__,None,b2Color)
b2Color.__truediv__ = new_instancemethod(_Box2D.b2Color___truediv__,None,b2Color)
b2Color.__add__ = new_instancemethod(_Box2D.b2Color___add__,None,b2Color)
b2Color.__sub__ = new_instancemethod(_Box2D.b2Color___sub__,None,b2Color)
b2Color.__div__ = new_instancemethod(_Box2D.b2Color___div__,None,b2Color)
b2Color.__rmul__ = new_instancemethod(_Box2D.b2Color___rmul__,None,b2Color)
b2Color.__mul__ = new_instancemethod(_Box2D.b2Color___mul__,None,b2Color)
b2Color.__isub = new_instancemethod(_Box2D.b2Color___isub,None,b2Color)
b2Color.__itruediv = new_instancemethod(_Box2D.b2Color___itruediv,None,b2Color)
b2Color.__idiv = new_instancemethod(_Box2D.b2Color___idiv,None,b2Color)
b2Color.__imul = new_instancemethod(_Box2D.b2Color___imul,None,b2Color)
b2Color.__iadd = new_instancemethod(_Box2D.b2Color___iadd,None,b2Color)
b2Color.__equ = new_instancemethod(_Box2D.b2Color___equ,None,b2Color)
b2Color_swigregister = _Box2D.b2Color_swigregister
b2Color_swigregister(b2Color)

class b2Draw(object):
    """Implement and register this class with a  b2Worldto provide debug drawing of physics entities in your game."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        if self.__class__ == b2Draw:
            _self = None
        else:
            _self = self
        _Box2D.b2Draw_swiginit(self,_Box2D.new_b2Draw(_self, ))
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Draw
    e_shapeBit = _Box2D.b2Draw_e_shapeBit
    e_jointBit = _Box2D.b2Draw_e_jointBit
    e_aabbBit = _Box2D.b2Draw_e_aabbBit
    e_pairBit = _Box2D.b2Draw_e_pairBit
    e_centerOfMassBit = _Box2D.b2Draw_e_centerOfMassBit
    def __SetFlags(self, *args, **kwargs):
        """
        __SetFlags(self, uint32 flags)

        Set the drawing flags.
        """
        return _Box2D.b2Draw___SetFlags(self, *args, **kwargs)

    def __GetFlags(self):
        """
        __GetFlags(self) -> uint32

        Get the drawing flags.
        """
        return _Box2D.b2Draw___GetFlags(self)

    def AppendFlags(self, *args, **kwargs):
        """
        AppendFlags(self, uint32 flags)

        Append flags to the current flags.
        """
        return _Box2D.b2Draw_AppendFlags(self, *args, **kwargs)

    def ClearFlags(self, *args, **kwargs):
        """
        ClearFlags(self, uint32 flags)

        Clear flags from the current flags.
        """
        return _Box2D.b2Draw_ClearFlags(self, *args, **kwargs)

    def DrawPolygon(self, *args, **kwargs):
        """
        DrawPolygon(self, b2Vec2 vertices, int32 vertexCount, b2Color color)

        Draw a closed polygon provided in CCW order.
        """
        return _Box2D.b2Draw_DrawPolygon(self, *args, **kwargs)

    def DrawSolidPolygon(self, *args, **kwargs):
        """
        DrawSolidPolygon(self, b2Vec2 vertices, int32 vertexCount, b2Color color)

        Draw a solid closed polygon provided in CCW order.
        """
        return _Box2D.b2Draw_DrawSolidPolygon(self, *args, **kwargs)

    def DrawCircle(self, *args, **kwargs):
        """
        DrawCircle(self, b2Vec2 center, float32 radius, b2Color color)

        Draw a circle.
        """
        return _Box2D.b2Draw_DrawCircle(self, *args, **kwargs)

    def DrawSolidCircle(self, *args, **kwargs):
        """
        DrawSolidCircle(self, b2Vec2 center, float32 radius, b2Vec2 axis, b2Color color)

        Draw a solid circle.
        """
        return _Box2D.b2Draw_DrawSolidCircle(self, *args, **kwargs)

    def DrawSegment(self, *args, **kwargs):
        """
        DrawSegment(self, b2Vec2 p1, b2Vec2 p2, b2Color color)

        Draw a line segment.
        """
        return _Box2D.b2Draw_DrawSegment(self, *args, **kwargs)

    def DrawTransform(self, *args, **kwargs):
        """
        DrawTransform(self, b2Transform xf)

        Draw a transform. Choose your own length scale.

        Parameters:
        -----------

        xf: 
        a transform.
        """
        return _Box2D.b2Draw_DrawTransform(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['flags']) 

    _flag_entries = [
        ['drawShapes', e_shapeBit],
        ['drawJoints', e_jointBit ],
        ['drawAABBs', e_aabbBit ],
        ['drawPairs', e_pairBit ],
        ['drawCOMs', e_centerOfMassBit ],
        ['convertVertices', e_convertVertices ],
    ]
    def _SetFlags(self, value):
        flags = 0
        for name_, mask in self._flag_entries:
            if name_ in value and value[name_]:
                flags |= mask
        self.__SetFlags(flags)
    def _GetFlags(self):
        flags = self.__GetFlags()
        ret={}
        for name_, mask in self._flag_entries:
            ret[name_]=((flags & mask)==mask)
        return ret
        
    flags=property(_GetFlags, _SetFlags, doc='Sets whether or not shapes, joints, etc. will be drawn.')

    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2Draw(self)
        return weakref_proxy(self)
b2Draw.__SetFlags = new_instancemethod(_Box2D.b2Draw___SetFlags,None,b2Draw)
b2Draw.__GetFlags = new_instancemethod(_Box2D.b2Draw___GetFlags,None,b2Draw)
b2Draw.AppendFlags = new_instancemethod(_Box2D.b2Draw_AppendFlags,None,b2Draw)
b2Draw.ClearFlags = new_instancemethod(_Box2D.b2Draw_ClearFlags,None,b2Draw)
b2Draw.DrawPolygon = new_instancemethod(_Box2D.b2Draw_DrawPolygon,None,b2Draw)
b2Draw.DrawSolidPolygon = new_instancemethod(_Box2D.b2Draw_DrawSolidPolygon,None,b2Draw)
b2Draw.DrawCircle = new_instancemethod(_Box2D.b2Draw_DrawCircle,None,b2Draw)
b2Draw.DrawSolidCircle = new_instancemethod(_Box2D.b2Draw_DrawSolidCircle,None,b2Draw)
b2Draw.DrawSegment = new_instancemethod(_Box2D.b2Draw_DrawSegment,None,b2Draw)
b2Draw.DrawTransform = new_instancemethod(_Box2D.b2Draw_DrawTransform,None,b2Draw)
b2Draw_swigregister = _Box2D.b2Draw_swigregister
b2Draw_swigregister(b2Draw)

class b2DrawExtended(b2Draw):
    """Proxy of C++ b2DrawExtended class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    convertVertices = _swig_property(_Box2D.b2DrawExtended_convertVertices_get, _Box2D.b2DrawExtended_convertVertices_set)
    center = _swig_property(_Box2D.b2DrawExtended_center_get, _Box2D.b2DrawExtended_center_set)
    offset = _swig_property(_Box2D.b2DrawExtended_offset_get, _Box2D.b2DrawExtended_offset_set)
    zoom = _swig_property(_Box2D.b2DrawExtended_zoom_get, _Box2D.b2DrawExtended_zoom_set)
    screenSize = _swig_property(_Box2D.b2DrawExtended_screenSize_get, _Box2D.b2DrawExtended_screenSize_set)
    flipY = _swig_property(_Box2D.b2DrawExtended_flipY_get, _Box2D.b2DrawExtended_flipY_set)
    flipX = _swig_property(_Box2D.b2DrawExtended_flipX_get, _Box2D.b2DrawExtended_flipX_set)
    def __Convert(self, *args, **kwargs):
        """__Convert(self, b2Vec2 verts, int32 vertexCount) -> PyObject"""
        return _Box2D.b2DrawExtended___Convert(self, *args, **kwargs)

    def to_screen(self, *args, **kwargs):
        """to_screen(self, b2Vec2 point) -> PyObject"""
        return _Box2D.b2DrawExtended_to_screen(self, *args, **kwargs)

    def DrawPolygon(self, *args, **kwargs):
        """
        DrawPolygon(self, b2Vec2 conv_vertices, int32 vertexCount, b2Color color)

        Draw a closed polygon provided in CCW order.
        """
        return _Box2D.b2DrawExtended_DrawPolygon(self, *args, **kwargs)

    def DrawSolidPolygon(self, *args, **kwargs):
        """
        DrawSolidPolygon(self, b2Vec2 conv_vertices, int32 vertexCount, b2Color color)

        Draw a solid closed polygon provided in CCW order.
        """
        return _Box2D.b2DrawExtended_DrawSolidPolygon(self, *args, **kwargs)

    def DrawCircle(self, *args, **kwargs):
        """
        DrawCircle(self, b2Vec2 conv_p1, float32 radius, b2Color color)

        Draw a circle.
        """
        return _Box2D.b2DrawExtended_DrawCircle(self, *args, **kwargs)

    def DrawSolidCircle(self, *args, **kwargs):
        """
        DrawSolidCircle(self, b2Vec2 conv_p1, float32 radius, b2Vec2 axis, b2Color color)

        Draw a solid circle.
        """
        return _Box2D.b2DrawExtended_DrawSolidCircle(self, *args, **kwargs)

    def DrawSegment(self, *args, **kwargs):
        """
        DrawSegment(self, b2Vec2 conv_p1, b2Vec2 conv_p2, b2Color color)

        Draw a line segment.
        """
        return _Box2D.b2DrawExtended_DrawSegment(self, *args, **kwargs)

    def DrawTransform(self, *args, **kwargs):
        """
        DrawTransform(self, b2Transform xf)

        Draw a transform. Choose your own length scale.

        Parameters:
        -----------

        xf: 
        a transform.
        """
        return _Box2D.b2DrawExtended_DrawTransform(self, *args, **kwargs)

    def __SetFlags(self, *args, **kwargs):
        """__SetFlags(self, uint32 flags)"""
        return _Box2D.b2DrawExtended___SetFlags(self, *args, **kwargs)

    __swig_destroy__ = _Box2D.delete_b2DrawExtended
    def __init__(self, **kwargs):
        if self.__class__ == b2DrawExtended:
            _self = None
        else:
            _self = self
        _Box2D.b2DrawExtended_swiginit(self,_Box2D.new_b2DrawExtended(_self, ))
        _init_kwargs(self, **kwargs)


    def __repr__(self):
        return _format_repr(self, ['center','convertVertices','flags','flipX','flipY','offset','screenSize','zoom']) 

    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2DrawExtended(self)
        return weakref_proxy(self)
b2DrawExtended.__Convert = new_instancemethod(_Box2D.b2DrawExtended___Convert,None,b2DrawExtended)
b2DrawExtended.to_screen = new_instancemethod(_Box2D.b2DrawExtended_to_screen,None,b2DrawExtended)
b2DrawExtended.DrawPolygon = new_instancemethod(_Box2D.b2DrawExtended_DrawPolygon,None,b2DrawExtended)
b2DrawExtended.DrawSolidPolygon = new_instancemethod(_Box2D.b2DrawExtended_DrawSolidPolygon,None,b2DrawExtended)
b2DrawExtended.DrawCircle = new_instancemethod(_Box2D.b2DrawExtended_DrawCircle,None,b2DrawExtended)
b2DrawExtended.DrawSolidCircle = new_instancemethod(_Box2D.b2DrawExtended_DrawSolidCircle,None,b2DrawExtended)
b2DrawExtended.DrawSegment = new_instancemethod(_Box2D.b2DrawExtended_DrawSegment,None,b2DrawExtended)
b2DrawExtended.DrawTransform = new_instancemethod(_Box2D.b2DrawExtended_DrawTransform,None,b2DrawExtended)
b2DrawExtended.__SetFlags = new_instancemethod(_Box2D.b2DrawExtended___SetFlags,None,b2DrawExtended)
b2DrawExtended_swigregister = _Box2D.b2DrawExtended_swigregister
b2DrawExtended_swigregister(b2DrawExtended)

class b2MassData(object):
    """This holds the mass data computed for a shape."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    mass = _swig_property(_Box2D.b2MassData_mass_get, _Box2D.b2MassData_mass_set)
    center = _swig_property(_Box2D.b2MassData_center_get, _Box2D.b2MassData_center_set)
    I = _swig_property(_Box2D.b2MassData_I_get, _Box2D.b2MassData_I_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['I','center','mass']) 

    def __init__(self, **kwargs):
        _Box2D.b2MassData_swiginit(self,_Box2D.new_b2MassData())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2MassData
b2MassData_swigregister = _Box2D.b2MassData_swigregister
b2MassData_swigregister(b2MassData)
b2_chunkSize = b2Globals.b2_chunkSize
b2_maxBlockSize = b2Globals.b2_maxBlockSize
b2_blockSizes = b2Globals.b2_blockSizes
b2_chunkArrayIncrement = b2Globals.b2_chunkArrayIncrement

class b2Shape(object):
    """A shape is used for collision detection. You can create a shape however you like. Shapes used for simulation in  b2Worldare created automatically when a  b2Fixtureis created. Shapes may encapsulate a one or more child shapes."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    e_unknown = _Box2D.b2Shape_e_unknown
    e_circle = _Box2D.b2Shape_e_circle
    e_edge = _Box2D.b2Shape_e_edge
    e_polygon = _Box2D.b2Shape_e_polygon
    e_loop = _Box2D.b2Shape_e_loop
    e_typeCount = _Box2D.b2Shape_e_typeCount
    __swig_destroy__ = _Box2D.delete_b2Shape
    def __GetType(self):
        """
        __GetType(self) -> Type

        Get the type of this shape. You can use this to down cast to the concrete shape. 
        the shape type.
        """
        return _Box2D.b2Shape___GetType(self)

    def __GetChildCount(self):
        """
        __GetChildCount(self) -> int32

        Get the number of child primitives.
        """
        return _Box2D.b2Shape___GetChildCount(self)

    def TestPoint(self, *args, **kwargs):
        """
        TestPoint(self, b2Transform xf, b2Vec2 p) -> bool

        Test a point for containment in this shape. This only works for convex shapes.

        Parameters:
        -----------

        xf: 
        the shape world transform.

        p: 
        a point in world coordinates.
        """
        return _Box2D.b2Shape_TestPoint(self, *args, **kwargs)

    def RayCast(self, *args, **kwargs):
        """
        RayCast(self, b2RayCastOutput output, b2RayCastInput input, b2Transform transform, 
            int32 childIndex) -> bool

        Cast a ray against a child shape.

        Parameters:
        -----------

        output: 
        the ray-cast results.

        input: 
        the ray-cast input parameters.

        transform: 
        the transform to be applied to the shape.

        childIndex: 
        the child shape index
        """
        return _Box2D.b2Shape_RayCast(self, *args, **kwargs)

    def __ComputeAABB(self, *args, **kwargs):
        """
        __ComputeAABB(self, b2AABB aabb, b2Transform xf, int32 childIndex)

        Given a transform, compute the associated axis aligned bounding box for a child shape.

        Parameters:
        -----------

        aabb: 
        returns the axis aligned box.

        xf: 
        the world transform of the shape.

        childIndex: 
        the child shape
        """
        return _Box2D.b2Shape___ComputeAABB(self, *args, **kwargs)

    def __ComputeMass(self, *args, **kwargs):
        """
        __ComputeMass(self, b2MassData massData, float32 density)

        Compute the mass properties of this shape using its dimensions and density. The inertia tensor is computed about the local origin.

        Parameters:
        -----------

        massData: 
        returns the mass data for this shape.

        density: 
        the density in kilograms per meter squared.
        """
        return _Box2D.b2Shape___ComputeMass(self, *args, **kwargs)

    radius = _swig_property(_Box2D.b2Shape_radius_get, _Box2D.b2Shape_radius_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['childCount','radius','type']) 

    def __hash__(self):
        """__hash__(self) -> long"""
        return _Box2D.b2Shape___hash__(self)

    __eq__ = b2ShapeCompare
    __ne__ = lambda self,other: not b2ShapeCompare(self,other)
    # Read-only
    type = property(__GetType, None)

    @property
    def childCount(self):
        """
        Get the number of child primitives.
        """
        return self.__GetChildCount()

    def getAABB(self, transform, childIndex):
        """
        Given a transform, compute the associated axis aligned bounding box for a child shape.
        """
        if childIndex >= self.childCount:
            raise ValueError('Child index should be at most childCount=%d' % self.childCount)
        aabb=b2AABB()
        self.__ComputeAABB(aabb, transform, childIndex)
        return aabb

    def getMass(self, density):
        """
        Compute the mass properties of this shape using its dimensions and density.
        The inertia tensor is computed about the local origin.
        """
        m=b2MassData()
        self.__ComputeMass(m, density)
        return m


b2Shape.__GetType = new_instancemethod(_Box2D.b2Shape___GetType,None,b2Shape)
b2Shape.__GetChildCount = new_instancemethod(_Box2D.b2Shape___GetChildCount,None,b2Shape)
b2Shape.TestPoint = new_instancemethod(_Box2D.b2Shape_TestPoint,None,b2Shape)
b2Shape.RayCast = new_instancemethod(_Box2D.b2Shape_RayCast,None,b2Shape)
b2Shape.__ComputeAABB = new_instancemethod(_Box2D.b2Shape___ComputeAABB,None,b2Shape)
b2Shape.__ComputeMass = new_instancemethod(_Box2D.b2Shape___ComputeMass,None,b2Shape)
b2Shape.__hash__ = new_instancemethod(_Box2D.b2Shape___hash__,None,b2Shape)
b2Shape_swigregister = _Box2D.b2Shape_swigregister
b2Shape_swigregister(b2Shape)

class b2CircleShape(b2Shape):
    """A circle shape."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2CircleShape_swiginit(self,_Box2D.new_b2CircleShape())
        _init_kwargs(self, **kwargs)


    pos = _swig_property(_Box2D.b2CircleShape_pos_get, _Box2D.b2CircleShape_pos_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['childCount','pos','radius','type']) 

    __swig_destroy__ = _Box2D.delete_b2CircleShape
b2CircleShape_swigregister = _Box2D.b2CircleShape_swigregister
b2CircleShape_swigregister(b2CircleShape)

class b2EdgeShape(b2Shape):
    """A line segment (edge) shape. These can be connected in chains or loops to other edge shapes. The connectivity information is used to ensure correct contact normals."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2EdgeShape_swiginit(self,_Box2D.new_b2EdgeShape())
        _init_kwargs(self, **kwargs)


    def __Set(self, *args, **kwargs):
        """
        __Set(self, b2Vec2 v1, b2Vec2 v2)

        Set this as an isolated edge.
        """
        return _Box2D.b2EdgeShape___Set(self, *args, **kwargs)

    vertex1 = _swig_property(_Box2D.b2EdgeShape_vertex1_get, _Box2D.b2EdgeShape_vertex1_set)
    vertex2 = _swig_property(_Box2D.b2EdgeShape_vertex2_get, _Box2D.b2EdgeShape_vertex2_set)
    vertex0 = _swig_property(_Box2D.b2EdgeShape_vertex0_get, _Box2D.b2EdgeShape_vertex0_set)
    vertex3 = _swig_property(_Box2D.b2EdgeShape_vertex3_get, _Box2D.b2EdgeShape_vertex3_set)
    hasVertex0 = _swig_property(_Box2D.b2EdgeShape_hasVertex0_get, _Box2D.b2EdgeShape_hasVertex0_set)
    hasVertex3 = _swig_property(_Box2D.b2EdgeShape_hasVertex3_get, _Box2D.b2EdgeShape_hasVertex3_set)
    def __repr__(self):
        return _format_repr(self, ['all_vertices','childCount','hasVertex0','hasVertex3','radius','type','vertex0','vertex1','vertex2','vertex3','vertexCount','vertices']) 

    def __repr__(self):
        return "b2EdgeShape(vertices: %s)" % (self.vertices)

    @property
    def all_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x0,y0), (x1,y1), (x2,y2) (x3,y3) ]
        Note that the validity of vertices 0 and 4 depend on whether or not
        hasVertex0 and hasVertex3 are set.
        """
        return [tuple(self.vertex0), tuple(self.vertex1), tuple(self.vertex2), tuple(self.vertex3)]

    def __get_vertices(self):
        """Returns the basic vertices as a list of tuples [ (x1,y1), (x2,y2) ]
        To include the supporting vertices, see 'all_vertices'

        If you want to set vertex3 but not vertex0, pass in None for vertex0.
        """
        return [tuple(self.vertex1), tuple(self.vertex2)]

    def __set_vertices(self, vertices):
        if len(vertices)==2:
            self.vertex1, self.vertex2=vertices
            self.hasVertex0=False
            self.hasVertex3=False
        elif len(vertices)==3:
            self.vertex0, self.vertex1, self.vertex2=vertices
            self.hasVertex0=(vertices[0] != None)
            self.hasVertex3=False
        elif len(vertices)==4:
            self.vertex0, self.vertex1, self.vertex2, self.vertex3=vertices
            self.hasVertex0=(vertices[0] != None)
            self.hasVertex3=True
        else:
            raise ValueError('Expected from 2 to 4 vertices.')

    @property
    def vertexCount(self):
        """
        Returns the number of valid vertices (as in, it counts whether or not 
        hasVertex0 or hasVertex3 are set)
        """
        if self.hasVertex0 and self.hasVertex3:
            return 4
        elif self.hasVertex0 or self.hasVertex3:
            return 3
        else:
            return 2

    def __iter__(self):
        """
        Iterates over the vertices in the Edge
        """
        for v in self.vertices:
            yield v

    vertices=property(__get_vertices, __set_vertices)

    __swig_destroy__ = _Box2D.delete_b2EdgeShape
b2EdgeShape.__Set = new_instancemethod(_Box2D.b2EdgeShape___Set,None,b2EdgeShape)
b2EdgeShape_swigregister = _Box2D.b2EdgeShape_swigregister
b2EdgeShape_swigregister(b2EdgeShape)

class b2LoopShape(b2Shape):
    """A loop shape is a free form sequence of line segments that form a circular list. The loop may cross upon itself, but this is not recommended for smooth collision. The loop has double sided collision, so you can use inside and outside collision. Therefore, you may use any winding order. Since there may be many vertices, they are allocated using b2Alloc."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2LoopShape_swiginit(self,_Box2D.new_b2LoopShape())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2LoopShape
    def __GetChildEdge(self, *args, **kwargs):
        """
        __GetChildEdge(self, b2EdgeShape edge, int32 index)

        Get a child edge.
        """
        return _Box2D.b2LoopShape___GetChildEdge(self, *args, **kwargs)

    def __GetCount(self):
        """
        __GetCount(self) -> int32

        Get the number of vertices.
        """
        return _Box2D.b2LoopShape___GetCount(self)

    def __GetVertex(self, *args, **kwargs):
        """
        __GetVertex(self, int32 index) -> b2Vec2

        Get the vertices (read-only).
        """
        return _Box2D.b2LoopShape___GetVertex(self, *args, **kwargs)

    def __GetVertices(self):
        """
        __GetVertices(self) -> b2Vec2

        Get the vertices (read-only).
        """
        return _Box2D.b2LoopShape___GetVertices(self)

    def __repr__(self):
        return _format_repr(self, ['childCount','edges','radius','type','vertexCount','vertices']) 

    def __get_vertices(self):
        """__get_vertices(self) -> PyObject"""
        return _Box2D.b2LoopShape___get_vertices(self)

    def __repr__(self):
        return "b2LoopShape(vertices: %s)" % (self.vertices)

    def getChildEdge(self, index):
        if childIndex >= self.childCount:
            raise ValueError('Child index should be at most childCount=%d' % self.childCount)

        edge=b2EdgeShape()
        self.__GetChildEdge(edge, index)
        return edge

    @property
    def edges(self):
        return [self.getChildEdge(i) for i in range(self.childCount)]

    @property
    def vertexCount(self):
        return self.__GetCount()

    def __get_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]"""
        return [ (self.__get_vertex(i).x, self.__get_vertex(i).y )
                         for i in range(0, self.vertexCount)]

    def __iter__(self):
        """
        Iterates over the vertices in the Loop
        """
        for v in self.vertices:
            yield v

    def __set_vertices(self, values):
        if not values or not isinstance(values, (list, tuple)) or (len(values) < 2):
            raise ValueError('Expected tuple or list of length >= 2.')

        for i,value in enumerate(values):
            if isinstance(value, (tuple, list)):
                if len(value) != 2:
                    raise ValueError('Expected tuple or list of length 2, got length %d' % len(value))
                for j in value:
                     if not isinstance(j, (int, float)):
                        raise ValueError('Expected int or float values, got %s' % (type(j)))
            elif isinstance(value, b2Vec2):
                pass
            else:
                raise ValueError('Expected tuple, list, or b2Vec2, got %s' % type(value))
            
        vecs=_b2Vec2Array(len(values))
        for i, value in enumerate(values):
            if isinstance(value, b2Vec2):
                vecs[i]=value
            else:
                vecs[i]=b2Vec2(value)
        self.__bypass_create(vecs, len(values))
        
    vertices=property(__get_vertices, __set_vertices)

    def __bypass_create(self, *args, **kwargs):
        """__bypass_create(self, _b2Vec2Array v, int c)"""
        return _Box2D.b2LoopShape___bypass_create(self, *args, **kwargs)

    def __get_vertex(self, *args, **kwargs):
        """__get_vertex(self, uint16 vnum) -> b2Vec2"""
        return _Box2D.b2LoopShape___get_vertex(self, *args, **kwargs)

b2LoopShape.__GetChildEdge = new_instancemethod(_Box2D.b2LoopShape___GetChildEdge,None,b2LoopShape)
b2LoopShape.__GetCount = new_instancemethod(_Box2D.b2LoopShape___GetCount,None,b2LoopShape)
b2LoopShape.__GetVertex = new_instancemethod(_Box2D.b2LoopShape___GetVertex,None,b2LoopShape)
b2LoopShape.__GetVertices = new_instancemethod(_Box2D.b2LoopShape___GetVertices,None,b2LoopShape)
b2LoopShape.__get_vertices = new_instancemethod(_Box2D.b2LoopShape___get_vertices,None,b2LoopShape)
b2LoopShape.__bypass_create = new_instancemethod(_Box2D.b2LoopShape___bypass_create,None,b2LoopShape)
b2LoopShape.__get_vertex = new_instancemethod(_Box2D.b2LoopShape___get_vertex,None,b2LoopShape)
b2LoopShape_swigregister = _Box2D.b2LoopShape_swigregister
b2LoopShape_swigregister(b2LoopShape)

class b2PolygonShape(b2Shape):
    """A convex polygon. It is assumed that the interior of the polygon is to the left of each edge. Polygons have a maximum number of vertices equal to b2_maxPolygonVertices. In most cases you should not need many vertices for a convex polygon."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2PolygonShape_swiginit(self,_Box2D.new_b2PolygonShape())
        _init_kwargs(self, **kwargs)


    def SetAsBox(self, *args):
        """
        SetAsBox(self, float32 hx, float32 hy)
        SetAsBox(self, float32 hx, float32 hy, b2Vec2 center, float32 angle)

        Build vertices to represent an oriented box.

        Parameters:
        -----------

        hx: 
        the half-width.

        hy: 
        the half-height.

        center: 
        the center of the box in local coordinates.

        angle: 
        the rotation of the box in local coordinates.
        """
        return _Box2D.b2PolygonShape_SetAsBox(self, *args)

    centroid = _swig_property(_Box2D.b2PolygonShape_centroid_get, _Box2D.b2PolygonShape_centroid_set)
    vertexCount = _swig_property(_Box2D.b2PolygonShape_vertexCount_get, _Box2D.b2PolygonShape_vertexCount_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['box','centroid','childCount','normals','radius','type','valid','vertexCount','vertices']) 

    def __get_vertices(self):
        """__get_vertices(self) -> PyObject"""
        return _Box2D.b2PolygonShape___get_vertices(self)

    def __get_normals(self):
        """__get_normals(self) -> PyObject"""
        return _Box2D.b2PolygonShape___get_normals(self)

    def __repr__(self):
        return "b2PolygonShape(vertices: %s)" % (self.vertices)
    def __clear_vertices(self):
        self.vertexCount=0
        for i in range(0, b2_maxPolygonVertices):
            self.set_vertex(i, 0, 0)
    def __set_vertices(self, values):
        if not values:
            self.__clear_vertices()
        else:
            if len(values) < 2 or len(values) > b2_maxPolygonVertices:
                raise ValueError('Expected tuple or list of length >= 2 and less than b2_maxPolygonVertices=%d, got length %d.' %
                                     (b2_maxPolygonVertices, len(values)))
            for i,value in enumerate(values):
                if isinstance(value, (tuple, list, b2Vec2)):
                    if len(value) != 2:
                        raise ValueError('Expected tuple or list of length 2, got length %d' % len(value))
                    self.set_vertex(i, *value)
                else:
                    raise ValueError('Expected tuple, list, or b2Vec2, got %s' % type(value))
                self.vertexCount=i+1 # follow along in case of an exception to indicate valid number set
            if self.valid:
                self.__set_vertices_internal() # calculates normals, centroid, etc.

    def __iter__(self):
        """
        Iterates over the vertices in the polygon
        """
        for v in self.vertices:
            yield v

    def __IsValid(self):
        return b2CheckPolygon(self)

    valid = property(__IsValid, None, doc="Checks the polygon to see if it can be properly created. Raises ValueError for invalid shapes.")
    vertices = property(__get_vertices, __set_vertices, doc="All of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]")
    normals = property(__get_normals, None, doc="All of the normals as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]")
    box = property(None, lambda self, value: self.SetAsBox(*value), doc="Property replacement for running SetAsBox (Write-only)")

    def __get_vertex(self, *args, **kwargs):
        """__get_vertex(self, uint16 vnum) -> b2Vec2"""
        return _Box2D.b2PolygonShape___get_vertex(self, *args, **kwargs)

    def __get_normal(self, *args, **kwargs):
        """__get_normal(self, uint16 vnum) -> b2Vec2"""
        return _Box2D.b2PolygonShape___get_normal(self, *args, **kwargs)

    def set_vertex(self, *args):
        """
        set_vertex(self, uint16 vnum, b2Vec2 value)
        set_vertex(self, uint16 vnum, float32 x, float32 y)
        """
        return _Box2D.b2PolygonShape_set_vertex(self, *args)

    def __set_vertices_internal(self, *args):
        """
        __set_vertices_internal(self, b2Vec2 vertices, int32 vertexCount)
        __set_vertices_internal(self)
        """
        return _Box2D.b2PolygonShape___set_vertices_internal(self, *args)

    __swig_destroy__ = _Box2D.delete_b2PolygonShape
b2PolygonShape.SetAsBox = new_instancemethod(_Box2D.b2PolygonShape_SetAsBox,None,b2PolygonShape)
b2PolygonShape.__get_vertices = new_instancemethod(_Box2D.b2PolygonShape___get_vertices,None,b2PolygonShape)
b2PolygonShape.__get_normals = new_instancemethod(_Box2D.b2PolygonShape___get_normals,None,b2PolygonShape)
b2PolygonShape.__get_vertex = new_instancemethod(_Box2D.b2PolygonShape___get_vertex,None,b2PolygonShape)
b2PolygonShape.__get_normal = new_instancemethod(_Box2D.b2PolygonShape___get_normal,None,b2PolygonShape)
b2PolygonShape.set_vertex = new_instancemethod(_Box2D.b2PolygonShape_set_vertex,None,b2PolygonShape)
b2PolygonShape.__set_vertices_internal = new_instancemethod(_Box2D.b2PolygonShape___set_vertices_internal,None,b2PolygonShape)
b2PolygonShape_swigregister = _Box2D.b2PolygonShape_swigregister
b2PolygonShape_swigregister(b2PolygonShape)

b2_nullNode = _Box2D.b2_nullNode
B2_USE_DYNAMIC_TREE = _Box2D.B2_USE_DYNAMIC_TREE
B2_USE_BRUTE_FORCE = _Box2D.B2_USE_BRUTE_FORCE
class b2TreeNode(object):
    """Proxy of C++ b2TreeNode class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def IsLeaf(self):
        """IsLeaf(self) -> bool"""
        return _Box2D.b2TreeNode_IsLeaf(self)

    aabb = _swig_property(_Box2D.b2TreeNode_aabb_get, _Box2D.b2TreeNode_aabb_set)
    child1 = _swig_property(_Box2D.b2TreeNode_child1_get, _Box2D.b2TreeNode_child1_set)
    child2 = _swig_property(_Box2D.b2TreeNode_child2_get, _Box2D.b2TreeNode_child2_set)
    height = _swig_property(_Box2D.b2TreeNode_height_get, _Box2D.b2TreeNode_height_set)
    def __init__(self): 
        """__init__(self) -> b2TreeNode"""
        _Box2D.b2TreeNode_swiginit(self,_Box2D.new_b2TreeNode())
    __swig_destroy__ = _Box2D.delete_b2TreeNode
b2TreeNode.IsLeaf = new_instancemethod(_Box2D.b2TreeNode_IsLeaf,None,b2TreeNode)
b2TreeNode_swigregister = _Box2D.b2TreeNode_swigregister
b2TreeNode_swigregister(b2TreeNode)

class b2Pair(object):
    """Proxy of C++ b2Pair class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    proxyIdA = _swig_property(_Box2D.b2Pair_proxyIdA_get, _Box2D.b2Pair_proxyIdA_set)
    proxyIdB = _swig_property(_Box2D.b2Pair_proxyIdB_get, _Box2D.b2Pair_proxyIdB_set)
    next = _swig_property(_Box2D.b2Pair_next_get, _Box2D.b2Pair_next_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['proxyIdA','proxyIdB']) 

    def __init__(self, **kwargs):
        _Box2D.b2Pair_swiginit(self,_Box2D.new_b2Pair())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Pair
b2Pair_swigregister = _Box2D.b2Pair_swigregister
b2Pair_swigregister(b2Pair)

class b2BroadPhase(object):
    """The broad-phase is used for computing pairs and performing volume queries and ray casts. This broad-phase does not persist pairs. Instead, this reports potentially new pairs. It is up to the client to consume the new pairs and to track subsequent overlap."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_nullProxy = _Box2D.b2BroadPhase_e_nullProxy
    def __init__(self): 
        """
        __init__(self) -> b2BroadPhase

        The broad-phase is used for computing pairs and performing volume queries and ray casts. This broad-phase does not persist pairs. Instead, this reports potentially new pairs. It is up to the client to consume the new pairs and to track subsequent overlap.
        """
        _Box2D.b2BroadPhase_swiginit(self,_Box2D.new_b2BroadPhase())
    __swig_destroy__ = _Box2D.delete_b2BroadPhase
    def CreateProxy(self, *args, **kwargs):
        """
        CreateProxy(self, b2AABB aabb, void $ignore) -> int32

        Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs is called.
        """
        return _Box2D.b2BroadPhase_CreateProxy(self, *args, **kwargs)

    def DestroyProxy(self, *args, **kwargs):
        """
        DestroyProxy(self, int32 proxyId)

        Destroy a proxy. It is up to the client to remove any pairs.
        """
        return _Box2D.b2BroadPhase_DestroyProxy(self, *args, **kwargs)

    def MoveProxy(self, *args, **kwargs):
        """
        MoveProxy(self, int32 proxyId, b2AABB aabb, b2Vec2 displacement)

        Call MoveProxy as many times as you like, then when you are done call UpdatePairs to finalized the proxy pairs (for your time step).
        """
        return _Box2D.b2BroadPhase_MoveProxy(self, *args, **kwargs)

    def TouchProxy(self, *args, **kwargs):
        """
        TouchProxy(self, int32 proxyId)

        Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.
        """
        return _Box2D.b2BroadPhase_TouchProxy(self, *args, **kwargs)

    def GetFatAABB(self, *args, **kwargs):
        """
        GetFatAABB(self, int32 proxyId) -> b2AABB

        Get the fat AABB for a proxy.
        """
        return _Box2D.b2BroadPhase_GetFatAABB(self, *args, **kwargs)

    def TestOverlap(self, *args, **kwargs):
        """
        TestOverlap(self, int32 proxyIdA, int32 proxyIdB) -> bool

        Test overlap of fat AABBs.
        """
        return _Box2D.b2BroadPhase_TestOverlap(self, *args, **kwargs)

    def __GetProxyCount(self):
        """
        __GetProxyCount(self) -> int32

        Get the number of proxies.
        """
        return _Box2D.b2BroadPhase___GetProxyCount(self)

    def __GetTreeHeight(self):
        """__GetTreeHeight(self) -> int32"""
        return _Box2D.b2BroadPhase___GetTreeHeight(self)

    def __GetTreeBalance(self):
        """__GetTreeBalance(self) -> int32"""
        return _Box2D.b2BroadPhase___GetTreeBalance(self)

    def __GetTreeQuality(self):
        """__GetTreeQuality(self) -> float32"""
        return _Box2D.b2BroadPhase___GetTreeQuality(self)

    def __repr__(self):
        return _format_repr(self, ['proxyCount']) 

    proxyCount=property(__GetProxyCount, None)
    treeHeight=property(__GetTreeHeight, None)
    treeBalance=property(__GetTreeBalance, None)
    treeQuality=property(__GetTreeQuality, None)

b2BroadPhase.CreateProxy = new_instancemethod(_Box2D.b2BroadPhase_CreateProxy,None,b2BroadPhase)
b2BroadPhase.DestroyProxy = new_instancemethod(_Box2D.b2BroadPhase_DestroyProxy,None,b2BroadPhase)
b2BroadPhase.MoveProxy = new_instancemethod(_Box2D.b2BroadPhase_MoveProxy,None,b2BroadPhase)
b2BroadPhase.TouchProxy = new_instancemethod(_Box2D.b2BroadPhase_TouchProxy,None,b2BroadPhase)
b2BroadPhase.GetFatAABB = new_instancemethod(_Box2D.b2BroadPhase_GetFatAABB,None,b2BroadPhase)
b2BroadPhase.TestOverlap = new_instancemethod(_Box2D.b2BroadPhase_TestOverlap,None,b2BroadPhase)
b2BroadPhase.__GetProxyCount = new_instancemethod(_Box2D.b2BroadPhase___GetProxyCount,None,b2BroadPhase)
b2BroadPhase.__GetTreeHeight = new_instancemethod(_Box2D.b2BroadPhase___GetTreeHeight,None,b2BroadPhase)
b2BroadPhase.__GetTreeBalance = new_instancemethod(_Box2D.b2BroadPhase___GetTreeBalance,None,b2BroadPhase)
b2BroadPhase.__GetTreeQuality = new_instancemethod(_Box2D.b2BroadPhase___GetTreeQuality,None,b2BroadPhase)
b2BroadPhase_swigregister = _Box2D.b2BroadPhase_swigregister
b2BroadPhase_swigregister(b2BroadPhase)


def b2PairLessThan(*args, **kwargs):
  """
    b2PairLessThan(b2Pair pair1, b2Pair pair2) -> bool

    This is used to sort pairs.
    """
  return _Box2D.b2PairLessThan(*args, **kwargs)
class b2DistanceProxy(object):
    """A distance proxy is used by the GJK algorithm. It encapsulates any shape."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2DistanceProxy_swiginit(self,_Box2D.new_b2DistanceProxy())
        _init_kwargs(self, **kwargs)


    def __Set(self, *args, **kwargs):
        """
        __Set(self, b2Shape shape, int32 index)

        Initialize the proxy using the given shape. The shape must remain in scope while the proxy is in use.
        """
        return _Box2D.b2DistanceProxy___Set(self, *args, **kwargs)

    def GetSupport(self, *args, **kwargs):
        """
        GetSupport(self, b2Vec2 d) -> int32

        Get the supporting vertex index in the given direction.
        """
        return _Box2D.b2DistanceProxy_GetSupport(self, *args, **kwargs)

    def GetSupportVertex(self, *args, **kwargs):
        """
        GetSupportVertex(self, b2Vec2 d) -> b2Vec2

        Get the supporting vertex in the given direction.
        """
        return _Box2D.b2DistanceProxy_GetSupportVertex(self, *args, **kwargs)

    def __get_vertex_count(self):
        """
        __get_vertex_count(self) -> int32

        Get the vertex count.
        """
        return _Box2D.b2DistanceProxy___get_vertex_count(self)

    def __get_vertex(self, *args, **kwargs):
        """
        __get_vertex(self, int32 index) -> b2Vec2

        Get a vertex by index. Used by b2Distance.
        """
        return _Box2D.b2DistanceProxy___get_vertex(self, *args, **kwargs)

    m_buffer = _swig_property(_Box2D.b2DistanceProxy_m_buffer_get, _Box2D.b2DistanceProxy_m_buffer_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['m_buffer','shape','vertices']) 

    def __get_vertices(self):
        """Returns all of the vertices as a list of tuples [ (x1,y1), (x2,y2) ... (xN,yN) ]"""
        return [ (self.__get_vertex(i).x, self.__get_vertex(i).y )
                         for i in range(0, self.__get_vertex_count())]

    shape = property(None, __Set, doc='The shape to be used. (read-only)')
    vertices = property(__get_vertices, None)

    __swig_destroy__ = _Box2D.delete_b2DistanceProxy
b2DistanceProxy.__Set = new_instancemethod(_Box2D.b2DistanceProxy___Set,None,b2DistanceProxy)
b2DistanceProxy.GetSupport = new_instancemethod(_Box2D.b2DistanceProxy_GetSupport,None,b2DistanceProxy)
b2DistanceProxy.GetSupportVertex = new_instancemethod(_Box2D.b2DistanceProxy_GetSupportVertex,None,b2DistanceProxy)
b2DistanceProxy.__get_vertex_count = new_instancemethod(_Box2D.b2DistanceProxy___get_vertex_count,None,b2DistanceProxy)
b2DistanceProxy.__get_vertex = new_instancemethod(_Box2D.b2DistanceProxy___get_vertex,None,b2DistanceProxy)
b2DistanceProxy_swigregister = _Box2D.b2DistanceProxy_swigregister
b2DistanceProxy_swigregister(b2DistanceProxy)

class b2DistanceInput(object):
    """Input for b2Distance. You have to option to use the shape radii in the computation. Even"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    proxyA = _swig_property(_Box2D.b2DistanceInput_proxyA_get, _Box2D.b2DistanceInput_proxyA_set)
    proxyB = _swig_property(_Box2D.b2DistanceInput_proxyB_get, _Box2D.b2DistanceInput_proxyB_set)
    transformA = _swig_property(_Box2D.b2DistanceInput_transformA_get, _Box2D.b2DistanceInput_transformA_set)
    transformB = _swig_property(_Box2D.b2DistanceInput_transformB_get, _Box2D.b2DistanceInput_transformB_set)
    useRadii = _swig_property(_Box2D.b2DistanceInput_useRadii_get, _Box2D.b2DistanceInput_useRadii_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['proxyA','proxyB','transformA','transformB','useRadii']) 

    def __init__(self, **kwargs):
        _Box2D.b2DistanceInput_swiginit(self,_Box2D.new_b2DistanceInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2DistanceInput
b2DistanceInput_swigregister = _Box2D.b2DistanceInput_swigregister
b2DistanceInput_swigregister(b2DistanceInput)

class b2DistanceOutput(object):
    """Output for b2Distance."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    pointA = _swig_property(_Box2D.b2DistanceOutput_pointA_get, _Box2D.b2DistanceOutput_pointA_set)
    pointB = _swig_property(_Box2D.b2DistanceOutput_pointB_get, _Box2D.b2DistanceOutput_pointB_set)
    distance = _swig_property(_Box2D.b2DistanceOutput_distance_get, _Box2D.b2DistanceOutput_distance_set)
    iterations = _swig_property(_Box2D.b2DistanceOutput_iterations_get, _Box2D.b2DistanceOutput_iterations_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['distance','iterations','pointA','pointB']) 

    def __init__(self, **kwargs):
        _Box2D.b2DistanceOutput_swiginit(self,_Box2D.new_b2DistanceOutput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2DistanceOutput
b2DistanceOutput_swigregister = _Box2D.b2DistanceOutput_swigregister
b2DistanceOutput_swigregister(b2DistanceOutput)

class b2TOIInput(object):
    """Input parameters for b2TimeOfImpact."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    proxyA = _swig_property(_Box2D.b2TOIInput_proxyA_get, _Box2D.b2TOIInput_proxyA_set)
    proxyB = _swig_property(_Box2D.b2TOIInput_proxyB_get, _Box2D.b2TOIInput_proxyB_set)
    sweepA = _swig_property(_Box2D.b2TOIInput_sweepA_get, _Box2D.b2TOIInput_sweepA_set)
    sweepB = _swig_property(_Box2D.b2TOIInput_sweepB_get, _Box2D.b2TOIInput_sweepB_set)
    tMax = _swig_property(_Box2D.b2TOIInput_tMax_get, _Box2D.b2TOIInput_tMax_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['proxyA','proxyB','sweepA','sweepB','tMax']) 

    def __init__(self, **kwargs):
        _Box2D.b2TOIInput_swiginit(self,_Box2D.new_b2TOIInput())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2TOIInput
b2TOIInput_swigregister = _Box2D.b2TOIInput_swigregister
b2TOIInput_swigregister(b2TOIInput)

class b2TOIOutput(object):
    """Proxy of C++ b2TOIOutput class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    e_unknown = _Box2D.b2TOIOutput_e_unknown
    e_failed = _Box2D.b2TOIOutput_e_failed
    e_overlapped = _Box2D.b2TOIOutput_e_overlapped
    e_touching = _Box2D.b2TOIOutput_e_touching
    e_separated = _Box2D.b2TOIOutput_e_separated
    state = _swig_property(_Box2D.b2TOIOutput_state_get, _Box2D.b2TOIOutput_state_set)
    t = _swig_property(_Box2D.b2TOIOutput_t_get, _Box2D.b2TOIOutput_t_set)
    def __repr__(self):
        return _format_repr(self, ['state','t']) 

    def __init__(self): 
        """__init__(self) -> b2TOIOutput"""
        _Box2D.b2TOIOutput_swiginit(self,_Box2D.new_b2TOIOutput())
    __swig_destroy__ = _Box2D.delete_b2TOIOutput
b2TOIOutput_swigregister = _Box2D.b2TOIOutput_swigregister
b2TOIOutput_swigregister(b2TOIOutput)

b2_staticBody = _Box2D.b2_staticBody
b2_kinematicBody = _Box2D.b2_kinematicBody
b2_dynamicBody = _Box2D.b2_dynamicBody
class b2BodyDef(object):
    """A body definition holds all the data needed to construct a rigid body. You can safely re-use body definitions. Shapes are added to a body after construction."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2BodyDef_swiginit(self,_Box2D.new_b2BodyDef())
        _init_kwargs(self, **kwargs)


    type = _swig_property(_Box2D.b2BodyDef_type_get, _Box2D.b2BodyDef_type_set)
    position = _swig_property(_Box2D.b2BodyDef_position_get, _Box2D.b2BodyDef_position_set)
    angle = _swig_property(_Box2D.b2BodyDef_angle_get, _Box2D.b2BodyDef_angle_set)
    linearVelocity = _swig_property(_Box2D.b2BodyDef_linearVelocity_get, _Box2D.b2BodyDef_linearVelocity_set)
    angularVelocity = _swig_property(_Box2D.b2BodyDef_angularVelocity_get, _Box2D.b2BodyDef_angularVelocity_set)
    linearDamping = _swig_property(_Box2D.b2BodyDef_linearDamping_get, _Box2D.b2BodyDef_linearDamping_set)
    angularDamping = _swig_property(_Box2D.b2BodyDef_angularDamping_get, _Box2D.b2BodyDef_angularDamping_set)
    allowSleep = _swig_property(_Box2D.b2BodyDef_allowSleep_get, _Box2D.b2BodyDef_allowSleep_set)
    awake = _swig_property(_Box2D.b2BodyDef_awake_get, _Box2D.b2BodyDef_awake_set)
    fixedRotation = _swig_property(_Box2D.b2BodyDef_fixedRotation_get, _Box2D.b2BodyDef_fixedRotation_set)
    bullet = _swig_property(_Box2D.b2BodyDef_bullet_get, _Box2D.b2BodyDef_bullet_set)
    active = _swig_property(_Box2D.b2BodyDef_active_get, _Box2D.b2BodyDef_active_set)
    gravityScale = _swig_property(_Box2D.b2BodyDef_gravityScale_get, _Box2D.b2BodyDef_gravityScale_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','allowSleep','angle','angularDamping','angularVelocity','awake','bullet','fixedRotation','fixtures','inertiaScale','linearDamping','linearVelocity','position','shapeFixture','shapes','type','userData']) 

    def __GetUserData(self):
        """__GetUserData(self) -> PyObject"""
        return _Box2D.b2BodyDef___GetUserData(self)

    def __SetUserData(self, *args, **kwargs):
        """__SetUserData(self, PyObject data)"""
        return _Box2D.b2BodyDef___SetUserData(self, *args, **kwargs)

    def ClearUserData(self):
        """ClearUserData(self)"""
        return _Box2D.b2BodyDef_ClearUserData(self)

    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()

    fixtures = None
    shapes = None
    shapeFixture = None

    __swig_destroy__ = _Box2D.delete_b2BodyDef
b2BodyDef.__GetUserData = new_instancemethod(_Box2D.b2BodyDef___GetUserData,None,b2BodyDef)
b2BodyDef.__SetUserData = new_instancemethod(_Box2D.b2BodyDef___SetUserData,None,b2BodyDef)
b2BodyDef.ClearUserData = new_instancemethod(_Box2D.b2BodyDef_ClearUserData,None,b2BodyDef)
b2BodyDef_swigregister = _Box2D.b2BodyDef_swigregister
b2BodyDef_swigregister(b2BodyDef)

class b2Body(object):
    """A rigid body. These are created via  b2World::CreateBody."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __SetTransform(self, *args, **kwargs):
        """
        __SetTransform(self, b2Vec2 position, float32 angle)

        Set the position of the body's origin and rotation. This breaks any contacts and wakes the other bodies. Manipulating a body's transform may cause non-physical behavior.

        Parameters:
        -----------

        position: 
        the world position of the body's local origin.

        angle: 
        the world rotation in radians.
        """
        return _Box2D.b2Body___SetTransform(self, *args, **kwargs)

    def __GetTransform(self):
        """
        __GetTransform(self) -> b2Transform

        Get the body transform for the body's origin. 
        the world transform of the body's origin.
        """
        return _Box2D.b2Body___GetTransform(self)

    def __GetPosition(self):
        """
        __GetPosition(self) -> b2Vec2

        Get the world body origin position. 
        the world position of the body's origin.
        """
        return _Box2D.b2Body___GetPosition(self)

    def __GetAngle(self):
        """
        __GetAngle(self) -> float32

        Get the angle in radians. 
        the current world rotation angle in radians.
        """
        return _Box2D.b2Body___GetAngle(self)

    def __GetWorldCenter(self):
        """
        __GetWorldCenter(self) -> b2Vec2

        Get the world position of the center of mass.
        """
        return _Box2D.b2Body___GetWorldCenter(self)

    def __GetLocalCenter(self):
        """
        __GetLocalCenter(self) -> b2Vec2

        Get the local position of the center of mass.
        """
        return _Box2D.b2Body___GetLocalCenter(self)

    def __SetLinearVelocity(self, *args, **kwargs):
        """
        __SetLinearVelocity(self, b2Vec2 v)

        Set the linear velocity of the center of mass.

        Parameters:
        -----------

        v: 
        the new linear velocity of the center of mass.
        """
        return _Box2D.b2Body___SetLinearVelocity(self, *args, **kwargs)

    def __GetLinearVelocity(self):
        """
        __GetLinearVelocity(self) -> b2Vec2

        Get the linear velocity of the center of mass. 
        the linear velocity of the center of mass.
        """
        return _Box2D.b2Body___GetLinearVelocity(self)

    def __SetAngularVelocity(self, *args, **kwargs):
        """
        __SetAngularVelocity(self, float32 omega)

        Set the angular velocity.

        Parameters:
        -----------

        omega: 
        the new angular velocity in radians/second.
        """
        return _Box2D.b2Body___SetAngularVelocity(self, *args, **kwargs)

    def __GetAngularVelocity(self):
        """
        __GetAngularVelocity(self) -> float32

        Get the angular velocity. 
        the angular velocity in radians/second.
        """
        return _Box2D.b2Body___GetAngularVelocity(self)

    def ApplyForce(self, *args, **kwargs):
        """
        ApplyForce(self, b2Vec2 force, b2Vec2 point)

        Apply a force at a world point. If the force is not applied at the center of mass, it will generate a torque and affect the angular velocity. This wakes up the body.

        Parameters:
        -----------

        force: 
        the world force vector, usually in Newtons (N).

        point: 
        the world position of the point of application.
        """
        return _Box2D.b2Body_ApplyForce(self, *args, **kwargs)

    def ApplyTorque(self, *args, **kwargs):
        """
        ApplyTorque(self, float32 torque)

        Apply a torque. This affects the angular velocity without affecting the linear velocity of the center of mass. This wakes up the body.

        Parameters:
        -----------

        torque: 
        about the z-axis (out of the screen), usually in N-m.
        """
        return _Box2D.b2Body_ApplyTorque(self, *args, **kwargs)

    def ApplyLinearImpulse(self, *args, **kwargs):
        """
        ApplyLinearImpulse(self, b2Vec2 impulse, b2Vec2 point)

        Apply an impulse at a point. This immediately modifies the velocity. It also modifies the angular velocity if the point of application is not at the center of mass. This wakes up the body.

        Parameters:
        -----------

        impulse: 
        the world impulse vector, usually in N-seconds or kg-m/s.

        point: 
        the world position of the point of application.
        """
        return _Box2D.b2Body_ApplyLinearImpulse(self, *args, **kwargs)

    def ApplyAngularImpulse(self, *args, **kwargs):
        """
        ApplyAngularImpulse(self, float32 impulse)

        Apply an angular impulse.

        Parameters:
        -----------

        impulse: 
        the angular impulse in units of kg*m*m/s
        """
        return _Box2D.b2Body_ApplyAngularImpulse(self, *args, **kwargs)

    def __GetMass(self):
        """
        __GetMass(self) -> float32

        Get the total mass of the body. 
        the mass, usually in kilograms (kg).
        """
        return _Box2D.b2Body___GetMass(self)

    def __GetInertia(self):
        """
        __GetInertia(self) -> float32

        Get the rotational inertia of the body about the local origin. 
        the rotational inertia, usually in kg-m^2.
        """
        return _Box2D.b2Body___GetInertia(self)

    def GetMassData(self, *args, **kwargs):
        """
        GetMassData(self, b2MassData data)

        Get the mass data of the body. 
        a struct containing the mass, inertia and center of the body.
        """
        return _Box2D.b2Body_GetMassData(self, *args, **kwargs)

    def __SetMassData(self, *args, **kwargs):
        """
        __SetMassData(self, b2MassData data)

        Set the mass properties to override the mass properties of the fixtures. Note that this changes the center of mass position. Note that creating or destroying fixtures can also alter the mass. This function has no effect if the body isn't dynamic.

        Parameters:
        -----------

        massData: 
        the mass properties.
        """
        return _Box2D.b2Body___SetMassData(self, *args, **kwargs)

    def ResetMassData(self):
        """
        ResetMassData(self)

        This resets the mass properties to the sum of the mass properties of the fixtures. This normally does not need to be called unless you called SetMassData to override the mass and you later want to reset the mass.
        """
        return _Box2D.b2Body_ResetMassData(self)

    def GetWorldPoint(self, *args, **kwargs):
        """
        GetWorldPoint(self, b2Vec2 localPoint) -> b2Vec2

        Get the world coordinates of a point given the local coordinates.

        Parameters:
        -----------

        localPoint: 
        a point on the body measured relative the the body's origin. 
        the same point expressed in world coordinates.
        """
        return _Box2D.b2Body_GetWorldPoint(self, *args, **kwargs)

    def GetWorldVector(self, *args, **kwargs):
        """
        GetWorldVector(self, b2Vec2 localVector) -> b2Vec2

        Get the world coordinates of a vector given the local coordinates.

        Parameters:
        -----------

        localVector: 
        a vector fixed in the body. 
        the same vector expressed in world coordinates.
        """
        return _Box2D.b2Body_GetWorldVector(self, *args, **kwargs)

    def GetLocalPoint(self, *args, **kwargs):
        """
        GetLocalPoint(self, b2Vec2 worldPoint) -> b2Vec2

        Gets a local point relative to the body's origin given a world point.

        Parameters:
        -----------

        a: 
        point in world coordinates. 
        the corresponding local point relative to the body's origin.
        """
        return _Box2D.b2Body_GetLocalPoint(self, *args, **kwargs)

    def GetLocalVector(self, *args, **kwargs):
        """
        GetLocalVector(self, b2Vec2 worldVector) -> b2Vec2

        Gets a local vector given a world vector.

        Parameters:
        -----------

        a: 
        vector in world coordinates. 
        the corresponding local vector.
        """
        return _Box2D.b2Body_GetLocalVector(self, *args, **kwargs)

    def GetLinearVelocityFromWorldPoint(self, *args, **kwargs):
        """
        GetLinearVelocityFromWorldPoint(self, b2Vec2 worldPoint) -> b2Vec2

        Get the world linear velocity of a world point attached to this body.

        Parameters:
        -----------

        a: 
        point in world coordinates. 
        the world velocity of a point.
        """
        return _Box2D.b2Body_GetLinearVelocityFromWorldPoint(self, *args, **kwargs)

    def GetLinearVelocityFromLocalPoint(self, *args, **kwargs):
        """
        GetLinearVelocityFromLocalPoint(self, b2Vec2 localPoint) -> b2Vec2

        Get the world velocity of a local point.

        Parameters:
        -----------

        a: 
        point in local coordinates. 
        the world velocity of a point.
        """
        return _Box2D.b2Body_GetLinearVelocityFromLocalPoint(self, *args, **kwargs)

    def __GetLinearDamping(self):
        """
        __GetLinearDamping(self) -> float32

        Get the linear damping of the body.
        """
        return _Box2D.b2Body___GetLinearDamping(self)

    def __SetLinearDamping(self, *args, **kwargs):
        """
        __SetLinearDamping(self, float32 linearDamping)

        Set the linear damping of the body.
        """
        return _Box2D.b2Body___SetLinearDamping(self, *args, **kwargs)

    def __GetAngularDamping(self):
        """
        __GetAngularDamping(self) -> float32

        Get the angular damping of the body.
        """
        return _Box2D.b2Body___GetAngularDamping(self)

    def __SetAngularDamping(self, *args, **kwargs):
        """
        __SetAngularDamping(self, float32 angularDamping)

        Set the angular damping of the body.
        """
        return _Box2D.b2Body___SetAngularDamping(self, *args, **kwargs)

    def __GetGravityScale(self):
        """__GetGravityScale(self) -> float32"""
        return _Box2D.b2Body___GetGravityScale(self)

    def __SetGravityScale(self, *args, **kwargs):
        """__SetGravityScale(self, float32 scale)"""
        return _Box2D.b2Body___SetGravityScale(self, *args, **kwargs)

    def __SetType(self, *args, **kwargs):
        """
        __SetType(self, b2BodyType type)

        Set the type of this body. This may alter the mass and velocity.
        """
        return _Box2D.b2Body___SetType(self, *args, **kwargs)

    def __GetType(self):
        """
        __GetType(self) -> b2BodyType

        Get the type of this body.
        """
        return _Box2D.b2Body___GetType(self)

    def __SetBullet(self, *args, **kwargs):
        """
        __SetBullet(self, bool flag)

        Should this body be treated like a bullet for continuous collision detection?
        """
        return _Box2D.b2Body___SetBullet(self, *args, **kwargs)

    def __IsBullet(self):
        """
        __IsBullet(self) -> bool

        Is this body treated like a bullet for continuous collision detection?
        """
        return _Box2D.b2Body___IsBullet(self)

    def __SetSleepingAllowed(self, *args, **kwargs):
        """
        __SetSleepingAllowed(self, bool flag)

        You can disable sleeping on this body. If you disable sleeping, the body will be woken.
        """
        return _Box2D.b2Body___SetSleepingAllowed(self, *args, **kwargs)

    def __IsSleepingAllowed(self):
        """
        __IsSleepingAllowed(self) -> bool

        Is this body allowed to sleep.
        """
        return _Box2D.b2Body___IsSleepingAllowed(self)

    def __SetAwake(self, *args, **kwargs):
        """
        __SetAwake(self, bool flag)

        Set the sleep state of the body. A sleeping body has very low CPU cost.

        Parameters:
        -----------

        flag: 
        set to true to put body to sleep, false to wake it.
        """
        return _Box2D.b2Body___SetAwake(self, *args, **kwargs)

    def __IsAwake(self):
        """
        __IsAwake(self) -> bool

        Get the sleeping state of this body. 
        true if the body is sleeping.
        """
        return _Box2D.b2Body___IsAwake(self)

    def __SetActive(self, *args, **kwargs):
        """
        __SetActive(self, bool flag)

        Set the active state of the body. An inactive body is not simulated and cannot be collided with or woken up. If you pass a flag of true, all fixtures will be added to the broad-phase. If you pass a flag of false, all fixtures will be removed from the broad-phase and all contacts will be destroyed. Fixtures and joints are otherwise unaffected. You may continue to create/destroy fixtures and joints on inactive bodies. Fixtures on an inactive body are implicitly inactive and will not participate in collisions, ray-casts, or queries. Joints connected to an inactive body are implicitly inactive. An inactive body is still owned by a  b2Worldobject and remains in the body list.
        """
        return _Box2D.b2Body___SetActive(self, *args, **kwargs)

    def __IsActive(self):
        """
        __IsActive(self) -> bool

        Get the active state of the body.
        """
        return _Box2D.b2Body___IsActive(self)

    def __SetFixedRotation(self, *args, **kwargs):
        """
        __SetFixedRotation(self, bool flag)

        Set this body to have fixed rotation. This causes the mass to be reset.
        """
        return _Box2D.b2Body___SetFixedRotation(self, *args, **kwargs)

    def __IsFixedRotation(self):
        """
        __IsFixedRotation(self) -> bool

        Does this body have fixed rotation?
        """
        return _Box2D.b2Body___IsFixedRotation(self)

    def __GetFixtureList_internal(self, *args):
        """
        __GetFixtureList_internal(self) -> b2Fixture
        __GetFixtureList_internal(self) -> b2Fixture

        Get the list of all fixtures attached to this body.
        """
        return _Box2D.b2Body___GetFixtureList_internal(self, *args)

    def __GetJointList_internal(self, *args):
        """
        __GetJointList_internal(self) -> b2JointEdge
        __GetJointList_internal(self) -> b2JointEdge

        Get the list of all joints attached to this body.
        """
        return _Box2D.b2Body___GetJointList_internal(self, *args)

    def __GetContactList_internal(self, *args):
        """
        __GetContactList_internal(self) -> b2ContactEdge
        __GetContactList_internal(self) -> b2ContactEdge

        Get the list of all contacts attached to this body. 
        WARNING: 
        this list changes during the time step and you may miss some collisions if you don't use  b2ContactListener.
        """
        return _Box2D.b2Body___GetContactList_internal(self, *args)

    def __GetNext(self, *args):
        """
        __GetNext(self) -> b2Body
        __GetNext(self) -> b2Body

        Get the next body in the world's body list.
        """
        return _Box2D.b2Body___GetNext(self, *args)

    def __GetWorld(self, *args):
        """
        __GetWorld(self) -> b2World
        __GetWorld(self) -> b2World

        Get the parent world of this body.
        """
        return _Box2D.b2Body___GetWorld(self, *args)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','angle','angularDamping','angularVelocity','awake','bullet','contacts','fixedRotation','fixtures','inertia','joints','linearDamping','linearVelocity','localCenter','mass','massData','position','sleepingAllowed','transform','type','userData','worldCenter']) 

    def DestroyFixture(self, *args, **kwargs):
        """
        DestroyFixture(self, b2Fixture fixture)

        Destroy a fixture. This removes the fixture from the broad-phase and destroys all contacts associated with this fixture. This will automatically adjust the mass of the body if the body is dynamic and the fixture has positive density. All fixtures attached to a body are implicitly destroyed when the body is destroyed.

        Parameters:
        -----------

        fixture: 
        the fixture to be removed.

        WARNING: 
        This function is locked during callbacks.
        """
        return _Box2D.b2Body_DestroyFixture(self, *args, **kwargs)

    def __CreateFixture(self, *args):
        """
        __CreateFixture(self, b2Shape shape, float32 density) -> b2Fixture
        __CreateFixture(self, b2FixtureDef defn) -> b2Fixture
        """
        return _Box2D.b2Body___CreateFixture(self, *args)

    def __GetUserData(self):
        """__GetUserData(self) -> PyObject"""
        return _Box2D.b2Body___GetUserData(self)

    def __SetUserData(self, *args, **kwargs):
        """__SetUserData(self, PyObject data)"""
        return _Box2D.b2Body___SetUserData(self, *args, **kwargs)

    def ClearUserData(self):
        """ClearUserData(self)"""
        return _Box2D.b2Body_ClearUserData(self)

    userData = property(__GetUserData, __SetUserData)

    def __hash__(self):
        """__hash__(self) -> long"""
        return _Box2D.b2Body___hash__(self)

    __eq__ = b2BodyCompare
    __ne__ = lambda self,other: not b2BodyCompare(self,other)
    def __GetMassData(self):
        """
        Get a b2MassData object that represents this b2Body

        NOTE: To just get the mass, use body.mass
        """
        ret = b2MassData()
        ret.center=self.localCenter
        ret.I    = self.inertia
        ret.mass = self.mass
        return ret

    def __SetInertia(self, inertia):
        """
        Set the body's inertia
        """
        md = self.massData
        md.I = inertia
        self.massData=md

    def __SetMass(self, mass):
        """
        Set the body's mass
        """
        md = self.massData
        md.mass = mass
        self.massData=md

    def __SetLocalCenter(self, lcenter):
        """
        Set the body's local center
        """
        md = self.massData
        md.center = lcenter
        self.massData=md

    def __iter__(self):
        """
        Iterates over the fixtures in the body
        """
        for fixture in self.fixtures:
            yield fixture

    def __CreateShapeFixture(self, type_, **kwargs):
        """
        Internal function to handle creating circles, polygons, etc.
        without first creating a fixture. type_ is b2Shape.
        """
        shape=type_()
        fixture=b2FixtureDef(shape=shape)
        
        for key, value in list(kwargs.items()):
            # Note that these hasattrs use the types to get around
            # the fact that some properties are write-only (like 'box' in
            # polygon shapes), and as such do not show up with 'hasattr'.
            if hasattr(type_, key):
                to_set=shape
            elif hasattr(b2FixtureDef, key):
                to_set=fixture
            else:
                raise AttributeError('Property %s not found in either %s or b2FixtureDef' % (key, type_.__name__))

            try:
                setattr(to_set, key, value)
            except Exception as ex:
                raise ex.__class__('Failed on kwargs, class="%s" key="%s": %s' \
                            % (to_set.__class__.__name__, key, ex))

        return self.CreateFixture(fixture)

    def CreatePolygonFixture(self, **kwargs):
        """
        Create a polygon shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the polygon
        or the fixture to this function. For example:
        CreatePolygonFixture(box=(1, 1), friction=0.2, density=1.0)
        where 'box' is a property from the polygon shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2PolygonShape, **kwargs)

    def CreateCircleFixture(self, **kwargs):
        """
        Create a circle shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the circle
        or the fixture to this function. For example:
        CreateCircleFixture(radius=0.2, friction=0.2, density=1.0)
        where 'radius' is a property from the circle shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2CircleShape, **kwargs)

    def CreateEdgeFixture(self, **kwargs):
        """
        Create a edge shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the edge
        or the fixture to this function. For example:
        CreateEdgeFixture(vertices=[(0,0),(1,0)], friction=0.2, density=1.0)
        where 'vertices' is a property from the edge shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2EdgeShape, **kwargs)

    def CreateLoopFixture(self, **kwargs):
        """
        Create a loop shape without an explicit fixture definition.

        Takes kwargs; you can pass in properties for either the loop
        or the fixture to this function. For example:
        CreateLoopFixture(vertices=[...], friction=0.2, density=1.0)
        where 'vertices' is a property from the loop shape, and 
        'friction' and 'density' are from the fixture definition.
        """
        return self.__CreateShapeFixture(b2LoopShape, **kwargs)

    def CreateFixturesFromShapes(self, shapes=None, shapeFixture=None):
        """
        Create fixture(s) on the body from one or more shapes, and optionally a single
        fixture definition.

        Takes kwargs; examples of valid combinations are as follows:
        CreateFixturesFromShapes(shapes=b2CircleShape(radius=0.2))
        CreateFixturesFromShapes(shapes=b2CircleShape(radius=0.2), shapeFixture=b2FixtureDef(friction=0.2))
        CreateFixturesFromShapes(shapes=[b2CircleShape(radius=0.2), b2PolygonShape(box=[1,2])])
        """
        if shapes==None:
            raise TypeError('At least one shape required')

        if shapeFixture==None:
            shapeFixture=b2FixtureDef()
            oldShape=None
        else:
            oldShape = shapeFixture.shape

        ret=None
        if isinstance(shapes, (list, tuple)):
            ret=[]
            for shape in shapes:
                shapeFixture.shape=shape
                ret.append(self.__CreateFixture(shapeFixture))
        else:
            shapeFixture.shape=shapes
            ret=self.__CreateFixture(shapeFixture)

        shapeFixture.shape=oldShape
        return ret

    def CreateFixture(self, *args, **kwargs):
        """
        Create a fixtures on the body.

        Takes kwargs; examples of valid combinations are as follows:
        CreateFixture(b2FixtureDef(shape=s, restitution=0.2, ...))
        CreateFixture(shape=s, restitution=0.2, ...)
        
        """
        if len(args) > 1:
            raise TypeError('Takes only one argument or kwargs. See help(b2Body.CreateFixture)')
        elif len(args)==1:
            if isinstance(args[0], b2FixtureDef):
                defn = args[0]
                return self.__CreateFixture(defn)
            else:
                raise TypeError('Expected b2FixtureDef argument or kwargs')
        else: # no arguments, just kwargs
            return self.__CreateFixture(b2FixtureDef(**kwargs))

    def CreateEdgeChain(self, edge_list):
        """
        Creates a body a set of connected edge chains.
        Expects edge_list to be a list of vertices, length >= 2.
        """
        prev=None
        if len(edge_list) < 2:
            raise ValueError('Edge list length >= 2')

        shape=b2EdgeShape(vertices=[list(i) for i in edge_list[0:2]])
        self.CreateFixturesFromShapes(shape)

        prev = edge_list[1]
        for edge in edge_list[1:]:
            if len(edge) != 2:
                raise ValueError('Vertex length != 2, "%s"' % list(edge))
            shape.vertices = [list(prev), list(edge)]
            self.CreateFixturesFromShapes(shape)
            prev=edge

    # Read-write properties
    sleepingAllowed = property(__IsSleepingAllowed, __SetSleepingAllowed)
    angularVelocity = property(__GetAngularVelocity, __SetAngularVelocity)
    linearVelocity = property(__GetLinearVelocity, __SetLinearVelocity)
    awake = property(__IsAwake, __SetAwake)
    angularDamping = property(__GetAngularDamping, __SetAngularDamping)
    fixedRotation = property(__IsFixedRotation, __SetFixedRotation)
    linearDamping = property(__GetLinearDamping, __SetLinearDamping)
    bullet = property(__IsBullet, __SetBullet)
    type = property(__GetType, __SetType)
    active = property(__IsActive, __SetActive)
    angle = property(__GetAngle, lambda self, angle: self.__SetTransform(self.position, angle))
    transform = property(__GetTransform, lambda self, value: self.__SetTransform(*value))
    massData = property(__GetMassData, __SetMassData)
    mass = property(__GetMass, __SetMass)
    localCenter = property(__GetLocalCenter, __SetLocalCenter)
    inertia = property(__GetInertia, __SetInertia)
    position = property(__GetPosition, lambda self, pos: self.__SetTransform(pos, self.angle))
    gravityScale = property(__GetGravityScale, __SetGravityScale)

    # Read-only
    joints = property(lambda self: _list_from_linked_list(self.__GetJointList_internal()), None, 
                        doc="""All joints connected to the body as a list. 
                        NOTE: This re-creates the list on every call. See also joints_gen.""")
    contacts = property(lambda self: _list_from_linked_list(self.__GetContactList_internal()), None,
                        doc="""All contacts related to the body as a list. 
                        NOTE: This re-creates the list on every call. See also contacts_gen.""")
    fixtures = property(lambda self: _list_from_linked_list(self.__GetFixtureList_internal()), None,
                        doc="""All fixtures contained in this body as a list. 
                        NOTE: This re-creates the list on every call. See also fixtures_gen.""")
    joints_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetJointList_internal())), None,
                        doc="""Indexable generator of the connected joints to this body.
                        NOTE: When not using the whole list, this may be preferable to using 'joints'.""")
    contacts_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetContactList_internal())), None,
                        doc="""Indexable generator of the related contacts.
                        NOTE: When not using the whole list, this may be preferable to using 'contacts'.""")
    fixtures_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetFixtureList_internal())), None,
                        doc="""Indexable generator of the contained fixtures.
                        NOTE: When not using the whole list, this may be preferable to using 'fixtures'.""")
    next = property(__GetNext, None)
    worldCenter = property(__GetWorldCenter, None)
    world = property(__GetWorld, None)


b2Body.__SetTransform = new_instancemethod(_Box2D.b2Body___SetTransform,None,b2Body)
b2Body.__GetTransform = new_instancemethod(_Box2D.b2Body___GetTransform,None,b2Body)
b2Body.__GetPosition = new_instancemethod(_Box2D.b2Body___GetPosition,None,b2Body)
b2Body.__GetAngle = new_instancemethod(_Box2D.b2Body___GetAngle,None,b2Body)
b2Body.__GetWorldCenter = new_instancemethod(_Box2D.b2Body___GetWorldCenter,None,b2Body)
b2Body.__GetLocalCenter = new_instancemethod(_Box2D.b2Body___GetLocalCenter,None,b2Body)
b2Body.__SetLinearVelocity = new_instancemethod(_Box2D.b2Body___SetLinearVelocity,None,b2Body)
b2Body.__GetLinearVelocity = new_instancemethod(_Box2D.b2Body___GetLinearVelocity,None,b2Body)
b2Body.__SetAngularVelocity = new_instancemethod(_Box2D.b2Body___SetAngularVelocity,None,b2Body)
b2Body.__GetAngularVelocity = new_instancemethod(_Box2D.b2Body___GetAngularVelocity,None,b2Body)
b2Body.ApplyForce = new_instancemethod(_Box2D.b2Body_ApplyForce,None,b2Body)
b2Body.ApplyTorque = new_instancemethod(_Box2D.b2Body_ApplyTorque,None,b2Body)
b2Body.ApplyLinearImpulse = new_instancemethod(_Box2D.b2Body_ApplyLinearImpulse,None,b2Body)
b2Body.ApplyAngularImpulse = new_instancemethod(_Box2D.b2Body_ApplyAngularImpulse,None,b2Body)
b2Body.__GetMass = new_instancemethod(_Box2D.b2Body___GetMass,None,b2Body)
b2Body.__GetInertia = new_instancemethod(_Box2D.b2Body___GetInertia,None,b2Body)
b2Body.GetMassData = new_instancemethod(_Box2D.b2Body_GetMassData,None,b2Body)
b2Body.__SetMassData = new_instancemethod(_Box2D.b2Body___SetMassData,None,b2Body)
b2Body.ResetMassData = new_instancemethod(_Box2D.b2Body_ResetMassData,None,b2Body)
b2Body.GetWorldPoint = new_instancemethod(_Box2D.b2Body_GetWorldPoint,None,b2Body)
b2Body.GetWorldVector = new_instancemethod(_Box2D.b2Body_GetWorldVector,None,b2Body)
b2Body.GetLocalPoint = new_instancemethod(_Box2D.b2Body_GetLocalPoint,None,b2Body)
b2Body.GetLocalVector = new_instancemethod(_Box2D.b2Body_GetLocalVector,None,b2Body)
b2Body.GetLinearVelocityFromWorldPoint = new_instancemethod(_Box2D.b2Body_GetLinearVelocityFromWorldPoint,None,b2Body)
b2Body.GetLinearVelocityFromLocalPoint = new_instancemethod(_Box2D.b2Body_GetLinearVelocityFromLocalPoint,None,b2Body)
b2Body.__GetLinearDamping = new_instancemethod(_Box2D.b2Body___GetLinearDamping,None,b2Body)
b2Body.__SetLinearDamping = new_instancemethod(_Box2D.b2Body___SetLinearDamping,None,b2Body)
b2Body.__GetAngularDamping = new_instancemethod(_Box2D.b2Body___GetAngularDamping,None,b2Body)
b2Body.__SetAngularDamping = new_instancemethod(_Box2D.b2Body___SetAngularDamping,None,b2Body)
b2Body.__GetGravityScale = new_instancemethod(_Box2D.b2Body___GetGravityScale,None,b2Body)
b2Body.__SetGravityScale = new_instancemethod(_Box2D.b2Body___SetGravityScale,None,b2Body)
b2Body.__SetType = new_instancemethod(_Box2D.b2Body___SetType,None,b2Body)
b2Body.__GetType = new_instancemethod(_Box2D.b2Body___GetType,None,b2Body)
b2Body.__SetBullet = new_instancemethod(_Box2D.b2Body___SetBullet,None,b2Body)
b2Body.__IsBullet = new_instancemethod(_Box2D.b2Body___IsBullet,None,b2Body)
b2Body.__SetSleepingAllowed = new_instancemethod(_Box2D.b2Body___SetSleepingAllowed,None,b2Body)
b2Body.__IsSleepingAllowed = new_instancemethod(_Box2D.b2Body___IsSleepingAllowed,None,b2Body)
b2Body.__SetAwake = new_instancemethod(_Box2D.b2Body___SetAwake,None,b2Body)
b2Body.__IsAwake = new_instancemethod(_Box2D.b2Body___IsAwake,None,b2Body)
b2Body.__SetActive = new_instancemethod(_Box2D.b2Body___SetActive,None,b2Body)
b2Body.__IsActive = new_instancemethod(_Box2D.b2Body___IsActive,None,b2Body)
b2Body.__SetFixedRotation = new_instancemethod(_Box2D.b2Body___SetFixedRotation,None,b2Body)
b2Body.__IsFixedRotation = new_instancemethod(_Box2D.b2Body___IsFixedRotation,None,b2Body)
b2Body.__GetFixtureList_internal = new_instancemethod(_Box2D.b2Body___GetFixtureList_internal,None,b2Body)
b2Body.__GetJointList_internal = new_instancemethod(_Box2D.b2Body___GetJointList_internal,None,b2Body)
b2Body.__GetContactList_internal = new_instancemethod(_Box2D.b2Body___GetContactList_internal,None,b2Body)
b2Body.__GetNext = new_instancemethod(_Box2D.b2Body___GetNext,None,b2Body)
b2Body.__GetWorld = new_instancemethod(_Box2D.b2Body___GetWorld,None,b2Body)
b2Body.DestroyFixture = new_instancemethod(_Box2D.b2Body_DestroyFixture,None,b2Body)
b2Body.__CreateFixture = new_instancemethod(_Box2D.b2Body___CreateFixture,None,b2Body)
b2Body.__GetUserData = new_instancemethod(_Box2D.b2Body___GetUserData,None,b2Body)
b2Body.__SetUserData = new_instancemethod(_Box2D.b2Body___SetUserData,None,b2Body)
b2Body.ClearUserData = new_instancemethod(_Box2D.b2Body_ClearUserData,None,b2Body)
b2Body.__hash__ = new_instancemethod(_Box2D.b2Body___hash__,None,b2Body)
b2Body_swigregister = _Box2D.b2Body_swigregister
b2Body_swigregister(b2Body)

class b2Filter(object):
    """This holds contact filtering data."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    categoryBits = _swig_property(_Box2D.b2Filter_categoryBits_get, _Box2D.b2Filter_categoryBits_set)
    maskBits = _swig_property(_Box2D.b2Filter_maskBits_get, _Box2D.b2Filter_maskBits_set)
    groupIndex = _swig_property(_Box2D.b2Filter_groupIndex_get, _Box2D.b2Filter_groupIndex_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['categoryBits','groupIndex','maskBits']) 

    def __init__(self, **kwargs):
        _Box2D.b2Filter_swiginit(self,_Box2D.new_b2Filter())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Filter
b2Filter_swigregister = _Box2D.b2Filter_swigregister
b2Filter_swigregister(b2Filter)

class b2FixtureDef(object):
    """A fixture definition is used to create a fixture. This class defines an abstract fixture definition. You can reuse fixture definitions safely."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2FixtureDef_swiginit(self,_Box2D.new_b2FixtureDef())
        _init_kwargs(self, **kwargs)


    shape = _swig_property(_Box2D.b2FixtureDef_shape_get, _Box2D.b2FixtureDef_shape_set)
    friction = _swig_property(_Box2D.b2FixtureDef_friction_get, _Box2D.b2FixtureDef_friction_set)
    restitution = _swig_property(_Box2D.b2FixtureDef_restitution_get, _Box2D.b2FixtureDef_restitution_set)
    density = _swig_property(_Box2D.b2FixtureDef_density_get, _Box2D.b2FixtureDef_density_set)
    isSensor = _swig_property(_Box2D.b2FixtureDef_isSensor_get, _Box2D.b2FixtureDef_isSensor_set)
    filter = _swig_property(_Box2D.b2FixtureDef_filter_get, _Box2D.b2FixtureDef_filter_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['categoryBits','density','filter','friction','groupIndex','isSensor','maskBits','restitution','shape','userData']) 

    def __GetUserData(self):
        """__GetUserData(self) -> PyObject"""
        return _Box2D.b2FixtureDef___GetUserData(self)

    def __SetUserData(self, *args, **kwargs):
        """__SetUserData(self, PyObject data)"""
        return _Box2D.b2FixtureDef___SetUserData(self, *args, **kwargs)

    def ClearUserData(self):
        """ClearUserData(self)"""
        return _Box2D.b2FixtureDef_ClearUserData(self)

    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()

    def __SetCategoryBits(self, value):
        self.filter.categoryBits=value
    def __SetGroupIndex(self, value):
        self.filter.groupIndex=value
    def __SetMaskBits(self, value):
        self.filter.maskBits=value

    categoryBits=property(lambda self: self.filter.categoryBits, __SetCategoryBits)
    groupIndex=property(lambda self: self.filter.groupIndex, __SetGroupIndex)
    maskBits=property(lambda self: self.filter.maskBits, __SetMaskBits)

    __swig_destroy__ = _Box2D.delete_b2FixtureDef
b2FixtureDef.__GetUserData = new_instancemethod(_Box2D.b2FixtureDef___GetUserData,None,b2FixtureDef)
b2FixtureDef.__SetUserData = new_instancemethod(_Box2D.b2FixtureDef___SetUserData,None,b2FixtureDef)
b2FixtureDef.ClearUserData = new_instancemethod(_Box2D.b2FixtureDef_ClearUserData,None,b2FixtureDef)
b2FixtureDef_swigregister = _Box2D.b2FixtureDef_swigregister
b2FixtureDef_swigregister(b2FixtureDef)

class b2FixtureProxy(object):
    """This proxy is used internally to connect fixtures to the broad-phase."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    aabb = _swig_property(_Box2D.b2FixtureProxy_aabb_get, _Box2D.b2FixtureProxy_aabb_set)
    fixture = _swig_property(_Box2D.b2FixtureProxy_fixture_get, _Box2D.b2FixtureProxy_fixture_set)
    childIndex = _swig_property(_Box2D.b2FixtureProxy_childIndex_get, _Box2D.b2FixtureProxy_childIndex_set)
    proxyId = _swig_property(_Box2D.b2FixtureProxy_proxyId_get, _Box2D.b2FixtureProxy_proxyId_set)
    def __repr__(self):
        return _format_repr(self, ['aabb','childIndex','fixture','proxyId']) 

    def __init__(self): 
        """__init__(self) -> b2FixtureProxy"""
        _Box2D.b2FixtureProxy_swiginit(self,_Box2D.new_b2FixtureProxy())
    __swig_destroy__ = _Box2D.delete_b2FixtureProxy
b2FixtureProxy_swigregister = _Box2D.b2FixtureProxy_swigregister
b2FixtureProxy_swigregister(b2FixtureProxy)

class b2Fixture(object):
    """
    A fixture is used to attach a shape to a body for collision detection. A fixture inherits its transform from its parent. Fixtures hold additional non-geometric data such as friction, collision filters, etc. Fixtures are created via  b2Body::CreateFixture. 
    WARNING: 
    you cannot reuse fixtures.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __GetType(self):
        """
        __GetType(self) -> Type

        Get the type of the child shape. You can use this to down cast to the concrete shape. 
        the shape type.
        """
        return _Box2D.b2Fixture___GetType(self)

    def __GetShape(self, *args):
        """
        __GetShape(self) -> b2Shape
        __GetShape(self) -> b2Shape

        Get the child shape. You can modify the child shape, however you should not change the number of vertices because this will crash some collision caching mechanisms. Manipulating the shape may lead to non-physical behavior.
        """
        return _Box2D.b2Fixture___GetShape(self, *args)

    def __SetSensor(self, *args, **kwargs):
        """
        __SetSensor(self, bool sensor)

        Set if this fixture is a sensor.
        """
        return _Box2D.b2Fixture___SetSensor(self, *args, **kwargs)

    def __IsSensor(self):
        """
        __IsSensor(self) -> bool

        Is this fixture a sensor (non-solid)? 
        the true if the shape is a sensor.
        """
        return _Box2D.b2Fixture___IsSensor(self)

    def __SetFilterData(self, *args, **kwargs):
        """
        __SetFilterData(self, b2Filter filter)

        Set the contact filtering data. This will not update contacts until the next time step when either parent body is active and awake. This automatically calls Refilter.
        """
        return _Box2D.b2Fixture___SetFilterData(self, *args, **kwargs)

    def __GetFilterData(self):
        """
        __GetFilterData(self) -> b2Filter

        Get the contact filtering data.
        """
        return _Box2D.b2Fixture___GetFilterData(self)

    def Refilter(self):
        """
        Refilter(self)

        Call this if you want to establish collision that was previously disabled by  b2ContactFilter::ShouldCollide.
        """
        return _Box2D.b2Fixture_Refilter(self)

    def __GetBody(self, *args):
        """
        __GetBody(self) -> b2Body
        __GetBody(self) -> b2Body

        Get the parent body of this fixture. This is NULL if the fixture is not attached. 
        the parent body.
        """
        return _Box2D.b2Fixture___GetBody(self, *args)

    def __GetNext(self, *args):
        """
        __GetNext(self) -> b2Fixture
        __GetNext(self) -> b2Fixture

        Get the next fixture in the parent body's fixture list. 
        the next shape.
        """
        return _Box2D.b2Fixture___GetNext(self, *args)

    def TestPoint(self, *args, **kwargs):
        """
        TestPoint(self, b2Vec2 p) -> bool

        Test a point for containment in this fixture.

        Parameters:
        -----------

        p: 
        a point in world coordinates.
        """
        return _Box2D.b2Fixture_TestPoint(self, *args, **kwargs)

    def RayCast(self, *args, **kwargs):
        """
        RayCast(self, b2RayCastOutput output, b2RayCastInput input, int32 childIndex) -> bool

        Cast a ray against this shape.

        Parameters:
        -----------

        output: 
        the ray-cast results.

        input: 
        the ray-cast input parameters.
        """
        return _Box2D.b2Fixture_RayCast(self, *args, **kwargs)

    def __GetMassData(self, *args, **kwargs):
        """
        __GetMassData(self, b2MassData massData)

        Get the mass data for this fixture. The mass data is based on the density and the shape. The rotational inertia is about the shape's origin. This operation may be expensive.
        """
        return _Box2D.b2Fixture___GetMassData(self, *args, **kwargs)

    def __SetDensity(self, *args, **kwargs):
        """
        __SetDensity(self, float32 density)

        Set the density of this fixture. This will _not_ automatically adjust the mass of the body. You must call  b2Body::ResetMassDatato update the body's mass.
        """
        return _Box2D.b2Fixture___SetDensity(self, *args, **kwargs)

    def __GetDensity(self):
        """
        __GetDensity(self) -> float32

        Get the density of this fixture.
        """
        return _Box2D.b2Fixture___GetDensity(self)

    def __GetFriction(self):
        """
        __GetFriction(self) -> float32

        Get the coefficient of friction.
        """
        return _Box2D.b2Fixture___GetFriction(self)

    def __SetFriction(self, *args, **kwargs):
        """
        __SetFriction(self, float32 friction)

        Set the coefficient of friction. This will immediately update the mixed friction on all associated contacts.
        """
        return _Box2D.b2Fixture___SetFriction(self, *args, **kwargs)

    def __GetRestitution(self):
        """
        __GetRestitution(self) -> float32

        Get the coefficient of restitution.
        """
        return _Box2D.b2Fixture___GetRestitution(self)

    def __SetRestitution(self, *args, **kwargs):
        """
        __SetRestitution(self, float32 restitution)

        Set the coefficient of restitution. This will immediately update the mixed restitution on all associated contacts.
        """
        return _Box2D.b2Fixture___SetRestitution(self, *args, **kwargs)

    def GetAABB(self, *args, **kwargs):
        """
        GetAABB(self, int32 childIndex) -> b2AABB

        Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a more accurate AABB, compute it using the shape and the body transform.
        """
        return _Box2D.b2Fixture_GetAABB(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['body','density','filterData','friction','massData','restitution','sensor','shape','type','userData']) 

    def __GetUserData(self):
        """__GetUserData(self) -> PyObject"""
        return _Box2D.b2Fixture___GetUserData(self)

    def __SetUserData(self, *args, **kwargs):
        """__SetUserData(self, PyObject data)"""
        return _Box2D.b2Fixture___SetUserData(self, *args, **kwargs)

    def ClearUserData(self):
        """ClearUserData(self)"""
        return _Box2D.b2Fixture_ClearUserData(self)

    userData = property(__GetUserData, __SetUserData)

    def __hash__(self):
        """__hash__(self) -> long"""
        return _Box2D.b2Fixture___hash__(self)

    __swig_destroy__ = _Box2D.delete_b2Fixture
    __eq__ = b2FixtureCompare
    __ne__ = lambda self,other: not b2FixtureCompare(self,other)

    # Read-write properties
    friction = property(__GetFriction, __SetFriction)
    restitution = property(__GetRestitution, __SetRestitution)
    filterData = property(__GetFilterData, __SetFilterData)
    sensor = property(__IsSensor, __SetSensor)
    density = property(__GetDensity, __SetDensity)

    # Read-only
    next = property(__GetNext, None)
    type = property(__GetType, None)
    shape = property(__GetShape, None)
    body = property(__GetBody, None)

    @property
    def massData(self):
        md=b2MassData()
        self.__GetMassData(md)
        return md

b2Fixture.__GetType = new_instancemethod(_Box2D.b2Fixture___GetType,None,b2Fixture)
b2Fixture.__GetShape = new_instancemethod(_Box2D.b2Fixture___GetShape,None,b2Fixture)
b2Fixture.__SetSensor = new_instancemethod(_Box2D.b2Fixture___SetSensor,None,b2Fixture)
b2Fixture.__IsSensor = new_instancemethod(_Box2D.b2Fixture___IsSensor,None,b2Fixture)
b2Fixture.__SetFilterData = new_instancemethod(_Box2D.b2Fixture___SetFilterData,None,b2Fixture)
b2Fixture.__GetFilterData = new_instancemethod(_Box2D.b2Fixture___GetFilterData,None,b2Fixture)
b2Fixture.Refilter = new_instancemethod(_Box2D.b2Fixture_Refilter,None,b2Fixture)
b2Fixture.__GetBody = new_instancemethod(_Box2D.b2Fixture___GetBody,None,b2Fixture)
b2Fixture.__GetNext = new_instancemethod(_Box2D.b2Fixture___GetNext,None,b2Fixture)
b2Fixture.TestPoint = new_instancemethod(_Box2D.b2Fixture_TestPoint,None,b2Fixture)
b2Fixture.RayCast = new_instancemethod(_Box2D.b2Fixture_RayCast,None,b2Fixture)
b2Fixture.__GetMassData = new_instancemethod(_Box2D.b2Fixture___GetMassData,None,b2Fixture)
b2Fixture.__SetDensity = new_instancemethod(_Box2D.b2Fixture___SetDensity,None,b2Fixture)
b2Fixture.__GetDensity = new_instancemethod(_Box2D.b2Fixture___GetDensity,None,b2Fixture)
b2Fixture.__GetFriction = new_instancemethod(_Box2D.b2Fixture___GetFriction,None,b2Fixture)
b2Fixture.__SetFriction = new_instancemethod(_Box2D.b2Fixture___SetFriction,None,b2Fixture)
b2Fixture.__GetRestitution = new_instancemethod(_Box2D.b2Fixture___GetRestitution,None,b2Fixture)
b2Fixture.__SetRestitution = new_instancemethod(_Box2D.b2Fixture___SetRestitution,None,b2Fixture)
b2Fixture.GetAABB = new_instancemethod(_Box2D.b2Fixture_GetAABB,None,b2Fixture)
b2Fixture.__GetUserData = new_instancemethod(_Box2D.b2Fixture___GetUserData,None,b2Fixture)
b2Fixture.__SetUserData = new_instancemethod(_Box2D.b2Fixture___SetUserData,None,b2Fixture)
b2Fixture.ClearUserData = new_instancemethod(_Box2D.b2Fixture_ClearUserData,None,b2Fixture)
b2Fixture.__hash__ = new_instancemethod(_Box2D.b2Fixture___hash__,None,b2Fixture)
b2Fixture_swigregister = _Box2D.b2Fixture_swigregister
b2Fixture_swigregister(b2Fixture)

class b2DestructionListener(object):
    """Joints and fixtures are destroyed when their associated body is destroyed. Implement this listener so that you may nullify references to these joints and shapes."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2DestructionListener
    def SayGoodbye(self, *args):
        """
        SayGoodbye(self, b2Joint joint)
        SayGoodbye(self, b2Fixture fixture)

        Called when any fixture is about to be destroyed due to the destruction of its parent body.
        """
        return _Box2D.b2DestructionListener_SayGoodbye(self, *args)

    __dir__ = _dir_filter

    def __repr__(self):
        return "b2DestructionListener()"

    def __init__(self, **kwargs):
        if self.__class__ == b2DestructionListener:
            _self = None
        else:
            _self = self
        _Box2D.b2DestructionListener_swiginit(self,_Box2D.new_b2DestructionListener(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2DestructionListener(self)
        return weakref_proxy(self)
b2DestructionListener.SayGoodbye = new_instancemethod(_Box2D.b2DestructionListener_SayGoodbye,None,b2DestructionListener)
b2DestructionListener_swigregister = _Box2D.b2DestructionListener_swigregister
b2DestructionListener_swigregister(b2DestructionListener)

class b2ContactFilter(object):
    """Implement this class to provide collision filtering. In other words, you can implement this class if you want finer control over contact creation."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2ContactFilter
    def ShouldCollide(self, *args, **kwargs):
        """
        ShouldCollide(self, b2Fixture fixtureA, b2Fixture fixtureB) -> bool

        Return true if contact calculations should be performed between these two shapes. 
        WARNING: 
        for performance reasons this is only called when the AABBs begin to overlap.
        """
        return _Box2D.b2ContactFilter_ShouldCollide(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return "b2ContactFilter()"

    def __init__(self, **kwargs):
        if self.__class__ == b2ContactFilter:
            _self = None
        else:
            _self = self
        _Box2D.b2ContactFilter_swiginit(self,_Box2D.new_b2ContactFilter(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2ContactFilter(self)
        return weakref_proxy(self)
b2ContactFilter.ShouldCollide = new_instancemethod(_Box2D.b2ContactFilter_ShouldCollide,None,b2ContactFilter)
b2ContactFilter_swigregister = _Box2D.b2ContactFilter_swigregister
b2ContactFilter_swigregister(b2ContactFilter)

class b2ContactImpulse(object):
    """Contact impulses for reporting. Impulses are used instead of forces because sub-step forces may approach infinity for rigid body collisions. These match up one-to-one with the contact points in  b2Manifold."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['normalImpulses','tangentImpulses']) 

    def __get_normal_impulses(self):
        """__get_normal_impulses(self) -> PyObject"""
        return _Box2D.b2ContactImpulse___get_normal_impulses(self)

    def __get_tangent_impulses(self):
        """__get_tangent_impulses(self) -> PyObject"""
        return _Box2D.b2ContactImpulse___get_tangent_impulses(self)

    normalImpulses = property(__get_normal_impulses, None)
    tangentImpulses = property(__get_tangent_impulses, None)

    def __init__(self, **kwargs):
        _Box2D.b2ContactImpulse_swiginit(self,_Box2D.new_b2ContactImpulse())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactImpulse
b2ContactImpulse.__get_normal_impulses = new_instancemethod(_Box2D.b2ContactImpulse___get_normal_impulses,None,b2ContactImpulse)
b2ContactImpulse.__get_tangent_impulses = new_instancemethod(_Box2D.b2ContactImpulse___get_tangent_impulses,None,b2ContactImpulse)
b2ContactImpulse_swigregister = _Box2D.b2ContactImpulse_swigregister
b2ContactImpulse_swigregister(b2ContactImpulse)

class b2ContactListener(object):
    """
    Implement this class to get contact information. You can use these results for things like sounds and game logic. You can also get contact results by traversing the contact lists after the time step. However, you might miss some contacts because continuous physics leads to sub-stepping. Additionally you may receive multiple callbacks for the same contact in a single time step. You should strive to make your callbacks efficient because there may be many callbacks per time step. 
    WARNING: 
    You cannot create/destroy Box2D entities inside these callbacks.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2ContactListener
    def BeginContact(self, *args, **kwargs):
        """
        BeginContact(self, b2Contact contact)

        Called when two fixtures begin to touch.
        """
        return _Box2D.b2ContactListener_BeginContact(self, *args, **kwargs)

    def EndContact(self, *args, **kwargs):
        """
        EndContact(self, b2Contact contact)

        Called when two fixtures cease to touch.
        """
        return _Box2D.b2ContactListener_EndContact(self, *args, **kwargs)

    def PreSolve(self, *args, **kwargs):
        """
        PreSolve(self, b2Contact contact, b2Manifold oldManifold)

        This is called after a contact is updated. This allows you to inspect a contact before it goes to the solver. If you are careful, you can modify the contact manifold (e.g. disable contact). A copy of the old manifold is provided so that you can detect changes. Note: this is called only for awake bodies. Note: this is called even when the number of contact points is zero. Note: this is not called for sensors. Note: if you set the number of contact points to zero, you will not get an EndContact callback. However, you may get a BeginContact callback the next step.
        """
        return _Box2D.b2ContactListener_PreSolve(self, *args, **kwargs)

    def PostSolve(self, *args, **kwargs):
        """
        PostSolve(self, b2Contact contact, b2ContactImpulse impulse)

        This lets you inspect a contact after the solver is finished. This is useful for inspecting impulses. Note: the contact manifold does not include time of impact impulses, which can be arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly in a separate data structure. Note: this is only called for contacts that are touching, solid, and awake.
        """
        return _Box2D.b2ContactListener_PostSolve(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return "b2ContactListener()"

    def __init__(self, **kwargs):
        if self.__class__ == b2ContactListener:
            _self = None
        else:
            _self = self
        _Box2D.b2ContactListener_swiginit(self,_Box2D.new_b2ContactListener(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2ContactListener(self)
        return weakref_proxy(self)
b2ContactListener.BeginContact = new_instancemethod(_Box2D.b2ContactListener_BeginContact,None,b2ContactListener)
b2ContactListener.EndContact = new_instancemethod(_Box2D.b2ContactListener_EndContact,None,b2ContactListener)
b2ContactListener.PreSolve = new_instancemethod(_Box2D.b2ContactListener_PreSolve,None,b2ContactListener)
b2ContactListener.PostSolve = new_instancemethod(_Box2D.b2ContactListener_PostSolve,None,b2ContactListener)
b2ContactListener_swigregister = _Box2D.b2ContactListener_swigregister
b2ContactListener_swigregister(b2ContactListener)

class b2QueryCallback(object):
    """Callback class for AABB queries. See b2World::Query"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2QueryCallback
    def ReportFixture(self, *args, **kwargs):
        """
        ReportFixture(self, b2Fixture fixture) -> bool

        Called for each fixture found in the query AABB. 
        false to terminate the query.
        """
        return _Box2D.b2QueryCallback_ReportFixture(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return "b2QueryCallback()"

    def __init__(self, **kwargs):
        if self.__class__ == b2QueryCallback:
            _self = None
        else:
            _self = self
        _Box2D.b2QueryCallback_swiginit(self,_Box2D.new_b2QueryCallback(_self, ))
        _init_kwargs(self, **kwargs)


    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2QueryCallback(self)
        return weakref_proxy(self)
b2QueryCallback.ReportFixture = new_instancemethod(_Box2D.b2QueryCallback_ReportFixture,None,b2QueryCallback)
b2QueryCallback_swigregister = _Box2D.b2QueryCallback_swigregister
b2QueryCallback_swigregister(b2QueryCallback)

class b2RayCastCallback(object):
    """Callback class for ray casts. See  b2World::RayCast"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _Box2D.delete_b2RayCastCallback
    def ReportFixture(self, *args, **kwargs):
        """
        ReportFixture(self, b2Fixture fixture, b2Vec2 point, b2Vec2 normal, float32 fraction) -> float32

        Called for each fixture found in the query. You control how the ray cast proceeds by returning a float: return -1: ignore this fixture and continue return 0: terminate the ray cast return fraction: clip the ray to this point return 1: don't clip the ray and continue

        Parameters:
        -----------

        fixture: 
        the fixture hit by the ray

        point: 
        the point of initial intersection

        normal: 
        the normal vector at the point of intersection 
        -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue
        """
        return _Box2D.b2RayCastCallback_ReportFixture(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return "b2RayCastCallback()"

    def __init__(self): 
        """__init__(self) -> b2RayCastCallback"""
        if self.__class__ == b2RayCastCallback:
            _self = None
        else:
            _self = self
        _Box2D.b2RayCastCallback_swiginit(self,_Box2D.new_b2RayCastCallback(_self, ))
    def __disown__(self):
        self.this.disown()
        _Box2D.disown_b2RayCastCallback(self)
        return weakref_proxy(self)
b2RayCastCallback.ReportFixture = new_instancemethod(_Box2D.b2RayCastCallback_ReportFixture,None,b2RayCastCallback)
b2RayCastCallback_swigregister = _Box2D.b2RayCastCallback_swigregister
b2RayCastCallback_swigregister(b2RayCastCallback)

class b2ContactManager(object):
    """Proxy of C++ b2ContactManager class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(self) -> b2ContactManager"""
        _Box2D.b2ContactManager_swiginit(self,_Box2D.new_b2ContactManager())
    def AddPair(self, *args, **kwargs):
        """AddPair(self, void proxyUserDataA, void proxyUserDataB)"""
        return _Box2D.b2ContactManager_AddPair(self, *args, **kwargs)

    def FindNewContacts(self):
        """FindNewContacts(self)"""
        return _Box2D.b2ContactManager_FindNewContacts(self)

    def Destroy(self, *args, **kwargs):
        """Destroy(self, b2Contact c)"""
        return _Box2D.b2ContactManager_Destroy(self, *args, **kwargs)

    def Collide(self):
        """Collide(self)"""
        return _Box2D.b2ContactManager_Collide(self)

    broadPhase = _swig_property(_Box2D.b2ContactManager_broadPhase_get, _Box2D.b2ContactManager_broadPhase_set)
    contactList = _swig_property(_Box2D.b2ContactManager_contactList_get, _Box2D.b2ContactManager_contactList_set)
    contactCount = _swig_property(_Box2D.b2ContactManager_contactCount_get, _Box2D.b2ContactManager_contactCount_set)
    contactFilter = _swig_property(_Box2D.b2ContactManager_contactFilter_get, _Box2D.b2ContactManager_contactFilter_set)
    contactListener = _swig_property(_Box2D.b2ContactManager_contactListener_get, _Box2D.b2ContactManager_contactListener_set)
    allocator = _swig_property(_Box2D.b2ContactManager_allocator_get, _Box2D.b2ContactManager_allocator_set)
    def __repr__(self):
        return _format_repr(self, ['allocator','broadPhase','contactCount','contactFilter','contactList','contactListener']) 

    __swig_destroy__ = _Box2D.delete_b2ContactManager
b2ContactManager.AddPair = new_instancemethod(_Box2D.b2ContactManager_AddPair,None,b2ContactManager)
b2ContactManager.FindNewContacts = new_instancemethod(_Box2D.b2ContactManager_FindNewContacts,None,b2ContactManager)
b2ContactManager.Destroy = new_instancemethod(_Box2D.b2ContactManager_Destroy,None,b2ContactManager)
b2ContactManager.Collide = new_instancemethod(_Box2D.b2ContactManager_Collide,None,b2ContactManager)
b2ContactManager_swigregister = _Box2D.b2ContactManager_swigregister
b2ContactManager_swigregister(b2ContactManager)
b2_stackSize = b2Globals.b2_stackSize
b2_maxStackEntries = b2Globals.b2_maxStackEntries

class b2Profile(object):
    """Proxy of C++ b2Profile class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    step = _swig_property(_Box2D.b2Profile_step_get, _Box2D.b2Profile_step_set)
    collide = _swig_property(_Box2D.b2Profile_collide_get, _Box2D.b2Profile_collide_set)
    solve = _swig_property(_Box2D.b2Profile_solve_get, _Box2D.b2Profile_solve_set)
    solveTOI = _swig_property(_Box2D.b2Profile_solveTOI_get, _Box2D.b2Profile_solveTOI_set)
    def __init__(self): 
        """__init__(self) -> b2Profile"""
        _Box2D.b2Profile_swiginit(self,_Box2D.new_b2Profile())
    __swig_destroy__ = _Box2D.delete_b2Profile
b2Profile_swigregister = _Box2D.b2Profile_swigregister
b2Profile_swigregister(b2Profile)

class b2World(object):
    """The world class manages all physics entities, dynamic simulation, and asynchronous queries. The world also contains efficient memory management facilities."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, *args, **kwargs) -> b2World
        Arguments:
        * gravity (default (0, -10))
        * doSleep (default True)
        Additional kwargs like contactListener will be passed after the world is created.

        Examples:
         b2World()
         b2World( (0,-10), True)
         b2World( gravity=(0,-10), doSleep=True)
         b2World(contactListener=myListener)

        """
        if len(args) not in (0, 1, 2):
            raise ValueError("Only 'gravity, doSleep' can be passed as normal parameters.")

        if len(args) >= 1:
            gravity=args[0]
        elif 'gravity' in kwargs:
            gravity=kwargs['gravity']
            del kwargs['gravity']
        else:
            gravity=(0,-10)

        if len(args) == 2:
            doSleep=args[1]
        elif 'doSleep' in kwargs:
            doSleep=kwargs['doSleep']
            del kwargs['doSleep']
        else:
            doSleep=True
        
        _Box2D.b2World_swiginit(self,_Box2D.new_b2World(gravity, doSleep))

        for key, value in list(kwargs.items()):
            try:
                setattr(self, key, value)
            except Exception as ex:
                raise ex.__class__('Failed on kwargs, class="%s" key="%s": %s' \
                            % (self.__class__.__name__, key, ex))



    __swig_destroy__ = _Box2D.delete_b2World
    def __SetDestructionListener_internal(self, *args, **kwargs):
        """
        __SetDestructionListener_internal(self, b2DestructionListener listener)

        Register a destruction listener. The listener is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetDestructionListener_internal(self, *args, **kwargs)

    def __SetContactFilter_internal(self, *args, **kwargs):
        """
        __SetContactFilter_internal(self, b2ContactFilter filter)

        Register a contact filter to provide specific control over collision. Otherwise the default filter is used (b2_defaultFilter). The listener is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetContactFilter_internal(self, *args, **kwargs)

    def __SetContactListener_internal(self, *args, **kwargs):
        """
        __SetContactListener_internal(self, b2ContactListener listener)

        Register a contact event listener. The listener is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetContactListener_internal(self, *args, **kwargs)

    def __SetDebugDraw_internal(self, *args, **kwargs):
        """
        __SetDebugDraw_internal(self, b2Draw debugDraw)

        Register a routine for debug drawing. The debug draw functions are called inside with  b2World::DrawDebugDatamethod. The debug draw object is owned by you and must remain in scope.
        """
        return _Box2D.b2World___SetDebugDraw_internal(self, *args, **kwargs)

    def Step(self, *args, **kwargs):
        """
        Step(self, float32 timeStep, int32 velocityIterations, int32 positionIterations)

        Take a time step. This performs collision detection, integration, and constraint solution.

        Parameters:
        -----------

        timeStep: 
        the amount of time to simulate, this should not vary.

        velocityIterations: 
        for the velocity constraint solver.

        positionIterations: 
        for the position constraint solver.
        """
        return _Box2D.b2World_Step(self, *args, **kwargs)

    def ClearForces(self):
        """
        ClearForces(self)

        Manually clear the force buffer on all bodies. By default, forces are cleared automatically after each call to Step. The default behavior is modified by calling SetAutoClearForces. The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain a fixed sized time step under a variable frame-rate. When you perform sub-stepping you will disable auto clearing of forces and instead call ClearForces after all sub-steps are complete in one pass of your game loop. 
        See: 
         SetAutoClearForces
        """
        return _Box2D.b2World_ClearForces(self)

    def DrawDebugData(self):
        """
        DrawDebugData(self)

        Call this to draw shapes and other debug draw data.
        """
        return _Box2D.b2World_DrawDebugData(self)

    def QueryAABB(self, *args, **kwargs):
        """
        QueryAABB(self, b2QueryCallback callback, b2AABB aabb)

        Query the world for all fixtures that potentially overlap the provided AABB.

        Parameters:
        -----------

        callback: 
        a user implemented callback class.

        aabb: 
        the query box.
        """
        return _Box2D.b2World_QueryAABB(self, *args, **kwargs)

    def RayCast(self, *args, **kwargs):
        """
        RayCast(self, b2RayCastCallback callback, b2Vec2 point1, b2Vec2 point2)

        Ray-cast the world for all fixtures in the path of the ray. Your callback controls whether you get the closest point, any point, or n-points. The ray-cast ignores shapes that contain the starting point.

        Parameters:
        -----------

        callback: 
        a user implemented callback class.

        point1: 
        the ray starting point

        point2: 
        the ray ending point
        """
        return _Box2D.b2World_RayCast(self, *args, **kwargs)

    def __GetBodyList_internal(self, *args):
        """
        __GetBodyList_internal(self) -> b2Body
        __GetBodyList_internal(self) -> b2Body

        Get the world body list. With the returned body, use  b2Body::GetNextto get the next body in the world list. A NULL body indicates the end of the list. 
        the head of the world body list.
        """
        return _Box2D.b2World___GetBodyList_internal(self, *args)

    def __GetJointList_internal(self, *args):
        """
        __GetJointList_internal(self) -> b2Joint
        __GetJointList_internal(self) -> b2Joint

        Get the world joint list. With the returned joint, use  b2Joint::GetNextto get the next joint in the world list. A NULL joint indicates the end of the list. 
        the head of the world joint list.
        """
        return _Box2D.b2World___GetJointList_internal(self, *args)

    def __GetContactList_internal(self, *args):
        """
        __GetContactList_internal(self) -> b2Contact
        __GetContactList_internal(self) -> b2Contact

        Get the world contact list. With the returned contact, use  b2Contact::GetNextto get the next contact in the world list. A NULL contact indicates the end of the list. 
        the head of the world contact list.

        WARNING: 
        contacts are
        """
        return _Box2D.b2World___GetContactList_internal(self, *args)

    def __SetWarmStarting_internal(self, *args, **kwargs):
        """
        __SetWarmStarting_internal(self, bool flag)

        Enable/disable warm starting. For testing.
        """
        return _Box2D.b2World___SetWarmStarting_internal(self, *args, **kwargs)

    def __SetContinuousPhysics_internal(self, *args, **kwargs):
        """
        __SetContinuousPhysics_internal(self, bool flag)

        Enable/disable continuous physics. For testing.
        """
        return _Box2D.b2World___SetContinuousPhysics_internal(self, *args, **kwargs)

    def __SetSubStepping_internal(self, *args, **kwargs):
        """
        __SetSubStepping_internal(self, bool flag)

        Enable/disable single stepped continuous physics. For testing.
        """
        return _Box2D.b2World___SetSubStepping_internal(self, *args, **kwargs)

    def __GetProxyCount(self):
        """
        __GetProxyCount(self) -> int32

        Get the number of broad-phase proxies.
        """
        return _Box2D.b2World___GetProxyCount(self)

    def __GetBodyCount(self):
        """
        __GetBodyCount(self) -> int32

        Get the number of bodies.
        """
        return _Box2D.b2World___GetBodyCount(self)

    def __GetJointCount(self):
        """
        __GetJointCount(self) -> int32

        Get the number of joints.
        """
        return _Box2D.b2World___GetJointCount(self)

    def __GetContactCount(self):
        """
        __GetContactCount(self) -> int32

        Get the number of contacts (each may have 0 or more contact points).
        """
        return _Box2D.b2World___GetContactCount(self)

    def GetTreeHeight(self):
        """GetTreeHeight(self) -> int32"""
        return _Box2D.b2World_GetTreeHeight(self)

    def GetTreeBalance(self):
        """GetTreeBalance(self) -> int32"""
        return _Box2D.b2World_GetTreeBalance(self)

    def GetTreeQuality(self):
        """GetTreeQuality(self) -> float32"""
        return _Box2D.b2World_GetTreeQuality(self)

    def __SetGravity(self, *args, **kwargs):
        """
        __SetGravity(self, b2Vec2 gravity)

        Change the global gravity vector.
        """
        return _Box2D.b2World___SetGravity(self, *args, **kwargs)

    def __GetGravity(self):
        """
        __GetGravity(self) -> b2Vec2

        Get the global gravity vector.
        """
        return _Box2D.b2World___GetGravity(self)

    def __IsLocked(self):
        """
        __IsLocked(self) -> bool

        Is the world locked (in the middle of a time step).
        """
        return _Box2D.b2World___IsLocked(self)

    def __SetAutoClearForces(self, *args, **kwargs):
        """
        __SetAutoClearForces(self, bool flag)

        Set flag to control automatic clearing of forces after each time step.
        """
        return _Box2D.b2World___SetAutoClearForces(self, *args, **kwargs)

    def __GetAutoClearForces(self):
        """
        __GetAutoClearForces(self) -> bool

        Get the flag that controls automatic clearing of forces after each time step.
        """
        return _Box2D.b2World___GetAutoClearForces(self)

    def __GetContactManager(self):
        """
        __GetContactManager(self) -> b2ContactManager

        Get the contact manager for testing.
        """
        return _Box2D.b2World___GetContactManager(self)

    def GetProfile(self):
        """GetProfile(self) -> b2Profile"""
        return _Box2D.b2World_GetProfile(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['autoClearForces','bodies','bodyCount','contactCount','contactFilter','contactListener','contactManager','contacts','continuousPhysics','destructionListener','gravity','jointCount','joints','locked','proxyCount','renderer','subStepping','warmStarting']) 

    def __CreateBody(self, *args, **kwargs):
        """__CreateBody(self, b2BodyDef defn) -> b2Body"""
        return _Box2D.b2World___CreateBody(self, *args, **kwargs)

    def __CreateJoint(self, *args, **kwargs):
        """__CreateJoint(self, b2JointDef defn) -> b2Joint"""
        return _Box2D.b2World___CreateJoint(self, *args, **kwargs)

    def DestroyBody(self, *args, **kwargs):
        """
        DestroyBody(self, b2Body body)

        Destroy a rigid body given a definition. No reference to the definition is retained. This function is locked during callbacks. 
        WARNING: 
        This automatically deletes all associated shapes and joints. 
        This function is locked during callbacks.
        """
        return _Box2D.b2World_DestroyBody(self, *args, **kwargs)

    def DestroyJoint(self, *args, **kwargs):
        """
        DestroyJoint(self, b2Joint joint)

        Destroy a joint. This may cause the connected bodies to begin colliding. 
        WARNING: 
        This function is locked during callbacks.
        """
        return _Box2D.b2World_DestroyJoint(self, *args, **kwargs)

    def __iter__(self):
        """
        Iterates over the bodies in the world
        """
        for body in self.bodies:
            yield body

    def CreateDynamicBody(self, **kwargs):
        """
        Create a single dynamic body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_dynamicBody
        return self.CreateBody(**kwargs)

    def CreateKinematicBody(self, **kwargs):
        """
        Create a single kinematic body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_kinematicBody
        return self.CreateBody(**kwargs)

    def CreateStaticBody(self, **kwargs):
        """
        Create a single static body in the world.

        Accepts only kwargs to a b2BodyDef. For more information, see
        CreateBody and b2BodyDef.
        """
        kwargs['type'] = b2_staticBody
        return self.CreateBody(**kwargs)

    def CreateBody(self, *args, **kwargs):
        """
        Create a body in the world.
        Takes a single b2BodyDef argument, or kwargs to pass to a temporary b2BodyDef.
        world.CreateBody(position=(1,2), angle=1) 
        is short for:
        world.CreateBody(b2BodyDef(position=(1,2), angle=1))

        If the definition (or kwargs) sets 'fixtures', they will be created on the 
        newly created body. A single fixture is also accepted.

        CreateBody(..., fixtures=[])
        
        This is short for:
            body = CreateBody(...)
            for fixture in []:
                body.CreateFixture(fixture)

         'shapes' and 'shapeFixture' are also accepted:
         CreateBody(..., shapes=[], shapeFixture=b2FixtureDef())
        
        This is short for:
            body = CreateBody(...)
            body.CreateFixturesFromShapes(shapes=[], shapeFixture=b2FixtureDef())
        """
        if len(args) > 1:
            raise TypeError('Takes only one argument, or kwargs to b2BodyDef')
        elif len(args)==1:
            if isinstance(args[0], b2BodyDef):
                defn = args[0]
            else:
                raise TypeError('Takes only one argument, or kwargs to b2BodyDef')
        else:
            defn =b2BodyDef(**kwargs) 

        body=self.__CreateBody(defn)
            
        if defn.fixtures:
            if isinstance(defn.fixtures, (list, tuple)):
                for fixture in defn.fixtures:
                    body.CreateFixture(fixture)
            else:
                body.CreateFixture(defn.fixtures)
        if defn.shapes:
            body.CreateFixturesFromShapes(shapes=defn.shapes, shapeFixture=defn.shapeFixture)

        if 'massData' in kwargs:
            body.massData=kwargs['massData']
        if 'localCenter' in kwargs:
            body.localCenter=kwargs['localCenter']
        if 'inertia' in kwargs:
            body.inertia=kwargs['inertia']
        if 'mass' in kwargs:
            body.mass=kwargs['mass']

        return body

    def CreateDistanceJoint(self, **kwargs):
        """
        Create a single b2DistanceJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2DistanceJointDef(**kwargs))

    def CreateRopeJoint(self, **kwargs):
        """
        Create a single b2RopeJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2RopeJointDef(**kwargs))

    def CreateFrictionJoint(self, **kwargs):
        """
        Create a single b2FrictionJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2FrictionJointDef(**kwargs))

    def CreateGearJoint(self, **kwargs):
        """
        Create a single b2GearJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either joint1 or joint2 is left unset.
        """
        if 'joint1' not in kwargs or 'joint2' not in kwargs:
            raise ValueError('Gear joint requires that both joint1 and joint2 be set')
        return self.__CreateJoint(b2GearJointDef(**kwargs))

    def CreateWheelJoint(self, **kwargs):
        """
        Create a single b2WheelJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2WheelJointDef(**kwargs))

    def CreateMouseJoint(self, **kwargs):
        """
        Create a single b2MouseJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2MouseJointDef(**kwargs))

    def CreatePrismaticJoint(self, **kwargs):
        """
        Create a single b2PrismaticJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2PrismaticJointDef(**kwargs))

    def CreatePulleyJoint(self, **kwargs):
        """
        Create a single b2PulleyJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2PulleyJointDef(**kwargs))

    def CreateRevoluteJoint(self, **kwargs):
        """
        Create a single b2RevoluteJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2RevoluteJointDef(**kwargs))

    def CreateWeldJoint(self, **kwargs):
        """
        Create a single b2WeldJoint. Only accepts kwargs to the joint definition.

        Raises ValueError if either bodyA or bodyB is left unset.
        """
        if 'bodyA' not in kwargs or 'bodyB' not in kwargs:
            raise ValueError('Requires at least bodyA and bodyB be set')
        return self.__CreateJoint(b2WeldJointDef(**kwargs))

    def CreateJoint(self, *args, **kwargs):
        """
        Create a joint in the world.
        Takes a single b2JointDef argument, or kwargs to pass to a temporary b2JointDef.

        All of these are exactly equivalent:
        world.CreateJoint(type=b2RevoluteJoint, bodyA=body, bodyB=body2)
        world.CreateJoint(type=b2RevoluteJointDef, bodyA=body, bodyB=body2)
        world.CreateJoint(b2RevoluteJointDef(bodyA=body, bodyB=body2))
        """
        if len(args) > 1:
            raise TypeError('Takes only one argument, or kwargs to b2JointDef')
        elif len(args)==1 and isinstance(args[0], b2JointDef):
            defn = args[0]
        else:
            if not kwargs or 'type' not in kwargs:
                raise TypeError('Expected type kwarg of b2Joint or b2JointDef')

            type_ = kwargs['type']
            if issubclass(type_, b2JointDef):
                class_type = type_
            elif issubclass(type_, b2Joint):  # a b2Joint passed in, so get the b2JointDef
                class_type = globals()[type_.__name__ + 'Def']
            else:
                raise TypeError('Expected type kwarg of b2Joint or b2JointDef')

            del kwargs['type']
            defn =class_type(**kwargs) 

        if isinstance(defn, b2GearJointDef):
            if not defn.joint1 or not defn.joint2:
                raise ValueError('Gear joint requires that both joint1 and joint2 be set')
        else:
            if not defn.bodyA or not defn.bodyB:
                raise ValueError('Body or bodies not set (bodyA, bodyB)')

        return self.__CreateJoint(defn)

    # The logic behind these functions is that they increase the refcount
    # of the listeners as you set them, so it is no longer necessary to keep
    # a copy on your own. Upon destruction of the object, it should be cleared
    # also clearing the refcount of the function.
    # Now using it also to buffer previously write-only values in the shadowed
    # class to make them read-write.
    def __GetData(self, name):
        if name in list(self.__data.keys()):
            return self.__data[name]
        else:
            return None
    def __SetData(self, name, value, fcn):
        self.__data[name] = value
        fcn(value)

    # Read-write properties
    gravity   = property(__GetGravity, __SetGravity)
    autoClearForces = property(__GetAutoClearForces, __SetAutoClearForces)
    __data = {} # holds the listeners so they can be properly destroyed, and buffer other data
    destructionListener = property(lambda self: self.__GetData('destruction'), 
                                   lambda self, fcn: self.__SetData('destruction', fcn, self.__SetDestructionListener_internal))
    contactListener= property(lambda self: self.__GetData('contact'), 
                              lambda self, fcn: self.__SetData('contact', fcn, self.__SetContactListener_internal))
    contactFilter= property(lambda self: self.__GetData('contactfilter'),
                            lambda self, fcn: self.__SetData('contactfilter', fcn, self.__SetContactFilter_internal))
    renderer= property(lambda self: self.__GetData('renderer'),
                        lambda self, fcn: self.__SetData('renderer', fcn, self.__SetDebugDraw_internal))
    continuousPhysics = property(lambda self: self.__GetData('continuousphysics'), 
                                 lambda self, fcn: self.__SetData('continuousphysics', fcn, self.__SetContinuousPhysics_internal))
    warmStarting = property(lambda self: self.__GetData('warmstarting'), 
                            lambda self, fcn: self.__SetData('warmstarting', fcn, self.__SetWarmStarting_internal))
    subStepping = property(lambda self: self.__GetData('subStepping'), 
                           lambda self, fcn: self.__SetData('subStepping', fcn, self.__SetSubStepping_internal))

    # Read-only 
    contactManager= property(__GetContactManager, None)
    contactCount  = property(__GetContactCount, None)
    bodyCount     = property(__GetBodyCount, None)
    jointCount    = property(__GetJointCount, None)
    proxyCount    = property(__GetProxyCount, None)
    joints  = property(lambda self: _list_from_linked_list(self.__GetJointList_internal()), None,
                        doc="""All joints in the world.  NOTE: This re-creates the list on every call. See also joints_gen.""")
    bodies  = property(lambda self: _list_from_linked_list(self.__GetBodyList_internal()), None,
                        doc="""All bodies in the world.  NOTE: This re-creates the list on every call. See also bodies_gen.""")
    contacts= property(lambda self: _list_from_linked_list(self.__GetContactList_internal()), None,
                        doc="""All contacts in the world.  NOTE: This re-creates the list on every call. See also contacts_gen.""")
    joints_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetJointList_internal())), None,
                        doc="""Indexable generator of the connected joints to this body.
                        NOTE: When not using the whole list, this may be preferable to using 'joints'.""")
    bodies_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetBodyList_internal())), None,
                        doc="""Indexable generator of all bodies.
                        NOTE: When not using the whole list, this may be preferable to using 'bodies'.""")
    contacts_gen = property(lambda self: _indexable_generator(_generator_from_linked_list(self.__GetContactList_internal())), None,
                        doc="""Indexable generator of all contacts.
                        NOTE: When not using the whole list, this may be preferable to using 'contacts'.""")
    locked  = property(__IsLocked, None)


b2World.__SetDestructionListener_internal = new_instancemethod(_Box2D.b2World___SetDestructionListener_internal,None,b2World)
b2World.__SetContactFilter_internal = new_instancemethod(_Box2D.b2World___SetContactFilter_internal,None,b2World)
b2World.__SetContactListener_internal = new_instancemethod(_Box2D.b2World___SetContactListener_internal,None,b2World)
b2World.__SetDebugDraw_internal = new_instancemethod(_Box2D.b2World___SetDebugDraw_internal,None,b2World)
b2World.Step = new_instancemethod(_Box2D.b2World_Step,None,b2World)
b2World.ClearForces = new_instancemethod(_Box2D.b2World_ClearForces,None,b2World)
b2World.DrawDebugData = new_instancemethod(_Box2D.b2World_DrawDebugData,None,b2World)
b2World.QueryAABB = new_instancemethod(_Box2D.b2World_QueryAABB,None,b2World)
b2World.RayCast = new_instancemethod(_Box2D.b2World_RayCast,None,b2World)
b2World.__GetBodyList_internal = new_instancemethod(_Box2D.b2World___GetBodyList_internal,None,b2World)
b2World.__GetJointList_internal = new_instancemethod(_Box2D.b2World___GetJointList_internal,None,b2World)
b2World.__GetContactList_internal = new_instancemethod(_Box2D.b2World___GetContactList_internal,None,b2World)
b2World.__SetWarmStarting_internal = new_instancemethod(_Box2D.b2World___SetWarmStarting_internal,None,b2World)
b2World.__SetContinuousPhysics_internal = new_instancemethod(_Box2D.b2World___SetContinuousPhysics_internal,None,b2World)
b2World.__SetSubStepping_internal = new_instancemethod(_Box2D.b2World___SetSubStepping_internal,None,b2World)
b2World.__GetProxyCount = new_instancemethod(_Box2D.b2World___GetProxyCount,None,b2World)
b2World.__GetBodyCount = new_instancemethod(_Box2D.b2World___GetBodyCount,None,b2World)
b2World.__GetJointCount = new_instancemethod(_Box2D.b2World___GetJointCount,None,b2World)
b2World.__GetContactCount = new_instancemethod(_Box2D.b2World___GetContactCount,None,b2World)
b2World.GetTreeHeight = new_instancemethod(_Box2D.b2World_GetTreeHeight,None,b2World)
b2World.GetTreeBalance = new_instancemethod(_Box2D.b2World_GetTreeBalance,None,b2World)
b2World.GetTreeQuality = new_instancemethod(_Box2D.b2World_GetTreeQuality,None,b2World)
b2World.__SetGravity = new_instancemethod(_Box2D.b2World___SetGravity,None,b2World)
b2World.__GetGravity = new_instancemethod(_Box2D.b2World___GetGravity,None,b2World)
b2World.__IsLocked = new_instancemethod(_Box2D.b2World___IsLocked,None,b2World)
b2World.__SetAutoClearForces = new_instancemethod(_Box2D.b2World___SetAutoClearForces,None,b2World)
b2World.__GetAutoClearForces = new_instancemethod(_Box2D.b2World___GetAutoClearForces,None,b2World)
b2World.__GetContactManager = new_instancemethod(_Box2D.b2World___GetContactManager,None,b2World)
b2World.GetProfile = new_instancemethod(_Box2D.b2World_GetProfile,None,b2World)
b2World.__CreateBody = new_instancemethod(_Box2D.b2World___CreateBody,None,b2World)
b2World.__CreateJoint = new_instancemethod(_Box2D.b2World___CreateJoint,None,b2World)
b2World.DestroyBody = new_instancemethod(_Box2D.b2World_DestroyBody,None,b2World)
b2World.DestroyJoint = new_instancemethod(_Box2D.b2World_DestroyJoint,None,b2World)
b2World_swigregister = _Box2D.b2World_swigregister
b2World_swigregister(b2World)


def b2MixFriction(*args, **kwargs):
  """
    b2MixFriction(float32 friction1, float32 friction2) -> float32

    Friction mixing law. Feel free to customize this.
    """
  return _Box2D.b2MixFriction(*args, **kwargs)

def b2MixRestitution(*args, **kwargs):
  """
    b2MixRestitution(float32 restitution1, float32 restitution2) -> float32

    Restitution mixing law. Feel free to customize this.
    """
  return _Box2D.b2MixRestitution(*args, **kwargs)
class b2ContactEdge(object):
    """A contact edge is used to connect bodies and contacts together in a contact graph where each body is a node and each contact is an edge. A contact edge belongs to a doubly linked list maintained in each attached body. Each contact has two contact nodes, one for each attached body."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    other = _swig_property(_Box2D.b2ContactEdge_other_get, _Box2D.b2ContactEdge_other_set)
    contact = _swig_property(_Box2D.b2ContactEdge_contact_get, _Box2D.b2ContactEdge_contact_set)
    prev = _swig_property(_Box2D.b2ContactEdge_prev_get, _Box2D.b2ContactEdge_prev_set)
    next = _swig_property(_Box2D.b2ContactEdge_next_get, _Box2D.b2ContactEdge_next_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['contact','other']) 

    def __init__(self, **kwargs):
        _Box2D.b2ContactEdge_swiginit(self,_Box2D.new_b2ContactEdge())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2ContactEdge
b2ContactEdge_swigregister = _Box2D.b2ContactEdge_swigregister
b2ContactEdge_swigregister(b2ContactEdge)

class b2Contact(object):
    """The class manages contact between two shapes. A contact exists for each overlapping AABB in the broad-phase (except if filtered). Therefore a contact object may exist that has no contact points."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __GetManifold(self, *args):
        """
        __GetManifold(self) -> b2Manifold
        __GetManifold(self) -> b2Manifold

        Get the contact manifold. Do not modify the manifold unless you understand the internals of Box2D.
        """
        return _Box2D.b2Contact___GetManifold(self, *args)

    def __GetWorldManifold_internal(self, *args, **kwargs):
        """
        __GetWorldManifold_internal(self, b2WorldManifold worldManifold)

        Get the world manifold.
        """
        return _Box2D.b2Contact___GetWorldManifold_internal(self, *args, **kwargs)

    def __IsTouching(self):
        """
        __IsTouching(self) -> bool

        Is this contact touching?
        """
        return _Box2D.b2Contact___IsTouching(self)

    def __SetEnabled(self, *args, **kwargs):
        """
        __SetEnabled(self, bool flag)

        Enable/disable this contact. This can be used inside the pre-solve contact listener. The contact is only disabled for the current time step (or sub-step in continuous collisions).
        """
        return _Box2D.b2Contact___SetEnabled(self, *args, **kwargs)

    def __IsEnabled(self):
        """
        __IsEnabled(self) -> bool

        Has this contact been disabled?
        """
        return _Box2D.b2Contact___IsEnabled(self)

    def __GetNext(self, *args):
        """
        __GetNext(self) -> b2Contact
        __GetNext(self) -> b2Contact

        Get the next contact in the world's contact list.
        """
        return _Box2D.b2Contact___GetNext(self, *args)

    def __GetFixtureA(self, *args):
        """
        __GetFixtureA(self) -> b2Fixture
        __GetFixtureA(self) -> b2Fixture

        Get fixture A in this contact.
        """
        return _Box2D.b2Contact___GetFixtureA(self, *args)

    def __GetChildIndexA(self):
        """
        __GetChildIndexA(self) -> int32

        Get the child primitive index for fixture A.
        """
        return _Box2D.b2Contact___GetChildIndexA(self)

    def __GetFixtureB(self, *args):
        """
        __GetFixtureB(self) -> b2Fixture
        __GetFixtureB(self) -> b2Fixture

        Get fixture B in this contact.
        """
        return _Box2D.b2Contact___GetFixtureB(self, *args)

    def __GetChildIndexB(self):
        """
        __GetChildIndexB(self) -> int32

        Get the child primitive index for fixture B.
        """
        return _Box2D.b2Contact___GetChildIndexB(self)

    def __SetFriction(self, *args, **kwargs):
        """
        __SetFriction(self, float32 friction)

        Override the default friction mixture. You can call this in  b2ContactListener::PreSolve. This value persists until set or reset.
        """
        return _Box2D.b2Contact___SetFriction(self, *args, **kwargs)

    def __GetFriction(self):
        """
        __GetFriction(self) -> float32

        Get the friction.
        """
        return _Box2D.b2Contact___GetFriction(self)

    def ResetFriction(self):
        """
        ResetFriction(self)

        Reset the friction mixture to the default value.
        """
        return _Box2D.b2Contact_ResetFriction(self)

    def __SetRestitution(self, *args, **kwargs):
        """
        __SetRestitution(self, float32 restitution)

        Override the default restitution mixture. You can call this in  b2ContactListener::PreSolve. The value persists until you set or reset.
        """
        return _Box2D.b2Contact___SetRestitution(self, *args, **kwargs)

    def __GetRestitution(self):
        """
        __GetRestitution(self) -> float32

        Get the restitution.
        """
        return _Box2D.b2Contact___GetRestitution(self)

    def ResetRestitution(self):
        """
        ResetRestitution(self)

        Reset the restitution to the default value.
        """
        return _Box2D.b2Contact_ResetRestitution(self)

    def Evaluate(self, *args, **kwargs):
        """
        Evaluate(self, b2Manifold manifold, b2Transform xfA, b2Transform xfB)

        Evaluate this contact with your own manifold and transforms.
        """
        return _Box2D.b2Contact_Evaluate(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['childIndexA','childIndexB','enabled','fixtureA','fixtureB','manifold','touching','worldManifold']) 

    def __GetWorldManifold(self):
        ret=b2WorldManifold()
        self.__GetWorldManifold_internal(ret)
        return ret

    # Read-write properties
    enabled = property(__IsEnabled, __SetEnabled)

    # Read-only
    next = property(__GetNext, None)
    fixtureB = property(__GetFixtureB, None)
    fixtureA = property(__GetFixtureA, None)
    manifold = property(__GetManifold, None)
    childIndexA = property(__GetChildIndexA, None)
    childIndexB = property(__GetChildIndexB, None)
    worldManifold = property(__GetWorldManifold, None)
    touching = property(__IsTouching, None)
    friction = property(__GetFriction, __SetFriction)
    restitution = property(__GetRestitution, __SetRestitution)

b2Contact.__GetManifold = new_instancemethod(_Box2D.b2Contact___GetManifold,None,b2Contact)
b2Contact.__GetWorldManifold_internal = new_instancemethod(_Box2D.b2Contact___GetWorldManifold_internal,None,b2Contact)
b2Contact.__IsTouching = new_instancemethod(_Box2D.b2Contact___IsTouching,None,b2Contact)
b2Contact.__SetEnabled = new_instancemethod(_Box2D.b2Contact___SetEnabled,None,b2Contact)
b2Contact.__IsEnabled = new_instancemethod(_Box2D.b2Contact___IsEnabled,None,b2Contact)
b2Contact.__GetNext = new_instancemethod(_Box2D.b2Contact___GetNext,None,b2Contact)
b2Contact.__GetFixtureA = new_instancemethod(_Box2D.b2Contact___GetFixtureA,None,b2Contact)
b2Contact.__GetChildIndexA = new_instancemethod(_Box2D.b2Contact___GetChildIndexA,None,b2Contact)
b2Contact.__GetFixtureB = new_instancemethod(_Box2D.b2Contact___GetFixtureB,None,b2Contact)
b2Contact.__GetChildIndexB = new_instancemethod(_Box2D.b2Contact___GetChildIndexB,None,b2Contact)
b2Contact.__SetFriction = new_instancemethod(_Box2D.b2Contact___SetFriction,None,b2Contact)
b2Contact.__GetFriction = new_instancemethod(_Box2D.b2Contact___GetFriction,None,b2Contact)
b2Contact.ResetFriction = new_instancemethod(_Box2D.b2Contact_ResetFriction,None,b2Contact)
b2Contact.__SetRestitution = new_instancemethod(_Box2D.b2Contact___SetRestitution,None,b2Contact)
b2Contact.__GetRestitution = new_instancemethod(_Box2D.b2Contact___GetRestitution,None,b2Contact)
b2Contact.ResetRestitution = new_instancemethod(_Box2D.b2Contact_ResetRestitution,None,b2Contact)
b2Contact.Evaluate = new_instancemethod(_Box2D.b2Contact_Evaluate,None,b2Contact)
b2Contact_swigregister = _Box2D.b2Contact_swigregister
b2Contact_swigregister(b2Contact)

e_wheelJoint = _Box2D.e_wheelJoint
e_ropeJoint = _Box2D.e_ropeJoint
class b2Jacobian(object):
    """Proxy of C++ b2Jacobian class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    linearA = _swig_property(_Box2D.b2Jacobian_linearA_get, _Box2D.b2Jacobian_linearA_set)
    angularA = _swig_property(_Box2D.b2Jacobian_angularA_get, _Box2D.b2Jacobian_angularA_set)
    linearB = _swig_property(_Box2D.b2Jacobian_linearB_get, _Box2D.b2Jacobian_linearB_set)
    angularB = _swig_property(_Box2D.b2Jacobian_angularB_get, _Box2D.b2Jacobian_angularB_set)
    def SetZero(self):
        """SetZero(self)"""
        return _Box2D.b2Jacobian_SetZero(self)

    def Set(self, *args, **kwargs):
        """Set(self, b2Vec2 x1, float32 a1, b2Vec2 x2, float32 a2)"""
        return _Box2D.b2Jacobian_Set(self, *args, **kwargs)

    def Compute(self, *args, **kwargs):
        """Compute(self, b2Vec2 x1, float32 a1, b2Vec2 x2, float32 a2) -> float32"""
        return _Box2D.b2Jacobian_Compute(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['angularA','angularB','linearA','linearB']) 

    def __init__(self, **kwargs):
        _Box2D.b2Jacobian_swiginit(self,_Box2D.new_b2Jacobian())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2Jacobian
b2Jacobian.SetZero = new_instancemethod(_Box2D.b2Jacobian_SetZero,None,b2Jacobian)
b2Jacobian.Set = new_instancemethod(_Box2D.b2Jacobian_Set,None,b2Jacobian)
b2Jacobian.Compute = new_instancemethod(_Box2D.b2Jacobian_Compute,None,b2Jacobian)
b2Jacobian_swigregister = _Box2D.b2Jacobian_swigregister
b2Jacobian_swigregister(b2Jacobian)

class b2JointEdge(object):
    """A joint edge is used to connect bodies and joints together in a joint graph where each body is a node and each joint is an edge. A joint edge belongs to a doubly linked list maintained in each attached body. Each joint has two joint nodes, one for each attached body."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    other = _swig_property(_Box2D.b2JointEdge_other_get, _Box2D.b2JointEdge_other_set)
    joint = _swig_property(_Box2D.b2JointEdge_joint_get, _Box2D.b2JointEdge_joint_set)
    prev = _swig_property(_Box2D.b2JointEdge_prev_get, _Box2D.b2JointEdge_prev_set)
    next = _swig_property(_Box2D.b2JointEdge_next_get, _Box2D.b2JointEdge_next_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['joint','other']) 

    def __init__(self, **kwargs):
        _Box2D.b2JointEdge_swiginit(self,_Box2D.new_b2JointEdge())
        _init_kwargs(self, **kwargs)


    __swig_destroy__ = _Box2D.delete_b2JointEdge
b2JointEdge_swigregister = _Box2D.b2JointEdge_swigregister
b2JointEdge_swigregister(b2JointEdge)

class b2JointDef(object):
    """Joint definitions are used to construct joints."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2JointDef_swiginit(self,_Box2D.new_b2JointDef())
        _init_kwargs(self, **kwargs)


    type = _swig_property(_Box2D.b2JointDef_type_get, _Box2D.b2JointDef_type_set)
    bodyA = _swig_property(_Box2D.b2JointDef_bodyA_get, _Box2D.b2JointDef_bodyA_set)
    bodyB = _swig_property(_Box2D.b2JointDef_bodyB_get, _Box2D.b2JointDef_bodyB_set)
    collideConnected = _swig_property(_Box2D.b2JointDef_collideConnected_get, _Box2D.b2JointDef_collideConnected_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['bodyA','bodyB','collideConnected','type','userData']) 

    def __GetUserData(self):
        """__GetUserData(self) -> PyObject"""
        return _Box2D.b2JointDef___GetUserData(self)

    def __SetUserData(self, *args, **kwargs):
        """__SetUserData(self, PyObject data)"""
        return _Box2D.b2JointDef___SetUserData(self, *args, **kwargs)

    def ClearUserData(self):
        """ClearUserData(self)"""
        return _Box2D.b2JointDef_ClearUserData(self)

    userData = property(__GetUserData, __SetUserData)
    def __del__(self):
        self.ClearUserData()

    def to_kwargs(self):
        """
        Returns a dictionary representing this joint definition
        """
        skip_props = ['anchor', 'anchorA', 'anchorB', 'axis']
        type_=type(self)
        variables=[var for var in dir(self) 
            if isinstance(getattr(type_, var), property)
               and var not in skip_props]

        return dict([(variable, getattr(self, variable)) for variable in variables])

    __swig_destroy__ = _Box2D.delete_b2JointDef
b2JointDef.__GetUserData = new_instancemethod(_Box2D.b2JointDef___GetUserData,None,b2JointDef)
b2JointDef.__SetUserData = new_instancemethod(_Box2D.b2JointDef___SetUserData,None,b2JointDef)
b2JointDef.ClearUserData = new_instancemethod(_Box2D.b2JointDef_ClearUserData,None,b2JointDef)
b2JointDef_swigregister = _Box2D.b2JointDef_swigregister
b2JointDef_swigregister(b2JointDef)

class b2Joint(object):
    """The base joint class. Joints are used to constraint two bodies together in various fashions. Some joints also feature limits and motors."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def __GetType(self):
        """
        __GetType(self) -> b2JointType

        Get the type of the concrete joint.
        """
        return _Box2D.b2Joint___GetType(self)

    def __GetBodyA(self):
        """
        __GetBodyA(self) -> b2Body

        Get the first body attached to this joint.
        """
        return _Box2D.b2Joint___GetBodyA(self)

    def __GetBodyB(self):
        """
        __GetBodyB(self) -> b2Body

        Get the second body attached to this joint.
        """
        return _Box2D.b2Joint___GetBodyB(self)

    def __GetAnchorA(self):
        """
        __GetAnchorA(self) -> b2Vec2

        Get the anchor point on bodyA in world coordinates.
        """
        return _Box2D.b2Joint___GetAnchorA(self)

    def __GetAnchorB(self):
        """
        __GetAnchorB(self) -> b2Vec2

        Get the anchor point on bodyB in world coordinates.
        """
        return _Box2D.b2Joint___GetAnchorB(self)

    def GetReactionForce(self, *args, **kwargs):
        """
        GetReactionForce(self, float32 inv_dt) -> b2Vec2

        Get the reaction force on body2 at the joint anchor in Newtons.
        """
        return _Box2D.b2Joint_GetReactionForce(self, *args, **kwargs)

    def GetReactionTorque(self, *args, **kwargs):
        """
        GetReactionTorque(self, float32 inv_dt) -> float32

        Get the reaction torque on body2 in N*m.
        """
        return _Box2D.b2Joint_GetReactionTorque(self, *args, **kwargs)

    def __GetNext(self, *args):
        """
        __GetNext(self) -> b2Joint
        __GetNext(self) -> b2Joint

        Get the next joint the world joint list.
        """
        return _Box2D.b2Joint___GetNext(self, *args)

    def __IsActive(self):
        """
        __IsActive(self) -> bool

        Short-cut function to determine if either body is inactive.
        """
        return _Box2D.b2Joint___IsActive(self)

    def __GetCollideConnected(self):
        """__GetCollideConnected(self) -> bool"""
        return _Box2D.b2Joint___GetCollideConnected(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','type','userData']) 

    def __GetUserData(self):
        """__GetUserData(self) -> PyObject"""
        return _Box2D.b2Joint___GetUserData(self)

    def __SetUserData(self, *args, **kwargs):
        """__SetUserData(self, PyObject data)"""
        return _Box2D.b2Joint___SetUserData(self, *args, **kwargs)

    def ClearUserData(self):
        """ClearUserData(self)"""
        return _Box2D.b2Joint_ClearUserData(self)

    userData = property(__GetUserData, __SetUserData)

    def __hash__(self):
        """__hash__(self) -> long"""
        return _Box2D.b2Joint___hash__(self)

    __eq__ = b2JointCompare
    __ne__ = lambda self,other: not b2JointCompare(self,other)

    # Read-only
    next = property(__GetNext, None)
    bodyA = property(__GetBodyA, None)
    bodyB = property(__GetBodyB, None)
    type = property(__GetType, None)
    active = property(__IsActive, None)
    anchorB = property(__GetAnchorB, None)
    anchorA = property(__GetAnchorA, None)
    collideConnected = property(__GetCollideConnected, None)


b2Joint.__GetType = new_instancemethod(_Box2D.b2Joint___GetType,None,b2Joint)
b2Joint.__GetBodyA = new_instancemethod(_Box2D.b2Joint___GetBodyA,None,b2Joint)
b2Joint.__GetBodyB = new_instancemethod(_Box2D.b2Joint___GetBodyB,None,b2Joint)
b2Joint.__GetAnchorA = new_instancemethod(_Box2D.b2Joint___GetAnchorA,None,b2Joint)
b2Joint.__GetAnchorB = new_instancemethod(_Box2D.b2Joint___GetAnchorB,None,b2Joint)
b2Joint.GetReactionForce = new_instancemethod(_Box2D.b2Joint_GetReactionForce,None,b2Joint)
b2Joint.GetReactionTorque = new_instancemethod(_Box2D.b2Joint_GetReactionTorque,None,b2Joint)
b2Joint.__GetNext = new_instancemethod(_Box2D.b2Joint___GetNext,None,b2Joint)
b2Joint.__IsActive = new_instancemethod(_Box2D.b2Joint___IsActive,None,b2Joint)
b2Joint.__GetCollideConnected = new_instancemethod(_Box2D.b2Joint___GetCollideConnected,None,b2Joint)
b2Joint.__GetUserData = new_instancemethod(_Box2D.b2Joint___GetUserData,None,b2Joint)
b2Joint.__SetUserData = new_instancemethod(_Box2D.b2Joint___SetUserData,None,b2Joint)
b2Joint.ClearUserData = new_instancemethod(_Box2D.b2Joint_ClearUserData,None,b2Joint)
b2Joint.__hash__ = new_instancemethod(_Box2D.b2Joint___hash__,None,b2Joint)
b2Joint_swigregister = _Box2D.b2Joint_swigregister
b2Joint_swigregister(b2Joint)

class b2DistanceJointDef(b2JointDef):
    """
    Distance joint definition. This requires defining an anchor point on both bodies and the non-zero length of the distance joint. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. This helps when saving and loading a game. 
    WARNING: 
    Do not use a zero or short length.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2DistanceJointDef_swiginit(self,_Box2D.new_b2DistanceJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if 'localAnchorA' in kwargs and 'localAnchorB' in kwargs and 'length' not in kwargs:
            self.__update_length()


    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Body bodyA, b2Body bodyB, b2Vec2 anchorA, b2Vec2 anchorB)

        Initialize the bodies, anchors, and length using the world anchors.
        """
        return _Box2D.b2DistanceJointDef_Initialize(self, *args, **kwargs)

    localAnchorA = _swig_property(_Box2D.b2DistanceJointDef_localAnchorA_get, _Box2D.b2DistanceJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2DistanceJointDef_localAnchorB_get, _Box2D.b2DistanceJointDef_localAnchorB_set)
    length = _swig_property(_Box2D.b2DistanceJointDef_length_get, _Box2D.b2DistanceJointDef_length_set)
    frequencyHz = _swig_property(_Box2D.b2DistanceJointDef_frequencyHz_get, _Box2D.b2DistanceJointDef_frequencyHz_set)
    dampingRatio = _swig_property(_Box2D.b2DistanceJointDef_dampingRatio_get, _Box2D.b2DistanceJointDef_dampingRatio_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchorA','anchorB','bodyA','bodyB','collideConnected','dampingRatio','frequencyHz','length','localAnchorA','localAnchorB','type','userData']) 

    def __update_length(self):
        if self.bodyA and self.bodyB:
            d = self.anchorB - self.anchorA
            self.length = d.length
    def __set_anchorA(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.__update_length()
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
        self.__update_length()
    def __get_anchorA(self):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise Exception('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2DistanceJointDef
b2DistanceJointDef.Initialize = new_instancemethod(_Box2D.b2DistanceJointDef_Initialize,None,b2DistanceJointDef)
b2DistanceJointDef_swigregister = _Box2D.b2DistanceJointDef_swigregister
b2DistanceJointDef_swigregister(b2DistanceJointDef)

class b2DistanceJoint(b2Joint):
    """A distance joint constrains two points on two bodies to remain at a fixed distance from each other. You can view this as a massless, rigid rod."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __SetLength(self, *args, **kwargs):
        """
        __SetLength(self, float32 length)

        Set/get the natural length. Manipulating the length can lead to non-physical behavior when the frequency is zero.
        """
        return _Box2D.b2DistanceJoint___SetLength(self, *args, **kwargs)

    def __GetLength(self):
        """__GetLength(self) -> float32"""
        return _Box2D.b2DistanceJoint___GetLength(self)

    def __SetFrequency(self, *args, **kwargs):
        """__SetFrequency(self, float32 hz)"""
        return _Box2D.b2DistanceJoint___SetFrequency(self, *args, **kwargs)

    def __GetFrequency(self):
        """__GetFrequency(self) -> float32"""
        return _Box2D.b2DistanceJoint___GetFrequency(self)

    def __SetDampingRatio(self, *args, **kwargs):
        """__SetDampingRatio(self, float32 ratio)"""
        return _Box2D.b2DistanceJoint___SetDampingRatio(self, *args, **kwargs)

    def __GetDampingRatio(self):
        """__GetDampingRatio(self) -> float32"""
        return _Box2D.b2DistanceJoint___GetDampingRatio(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','dampingRatio','frequency','length','type','userData']) 

    # Read-write properties
    length = property(__GetLength, __SetLength)
    frequency = property(__GetFrequency, __SetFrequency)
    dampingRatio = property(__GetDampingRatio, __SetDampingRatio)


    __swig_destroy__ = _Box2D.delete_b2DistanceJoint
b2DistanceJoint.__SetLength = new_instancemethod(_Box2D.b2DistanceJoint___SetLength,None,b2DistanceJoint)
b2DistanceJoint.__GetLength = new_instancemethod(_Box2D.b2DistanceJoint___GetLength,None,b2DistanceJoint)
b2DistanceJoint.__SetFrequency = new_instancemethod(_Box2D.b2DistanceJoint___SetFrequency,None,b2DistanceJoint)
b2DistanceJoint.__GetFrequency = new_instancemethod(_Box2D.b2DistanceJoint___GetFrequency,None,b2DistanceJoint)
b2DistanceJoint.__SetDampingRatio = new_instancemethod(_Box2D.b2DistanceJoint___SetDampingRatio,None,b2DistanceJoint)
b2DistanceJoint.__GetDampingRatio = new_instancemethod(_Box2D.b2DistanceJoint___GetDampingRatio,None,b2DistanceJoint)
b2DistanceJoint_swigregister = _Box2D.b2DistanceJoint_swigregister
b2DistanceJoint_swigregister(b2DistanceJoint)

class b2FrictionJointDef(b2JointDef):
    """Friction joint definition."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2FrictionJointDef_swiginit(self,_Box2D.new_b2FrictionJointDef())
        _init_jointdef_kwargs(self, **kwargs)


    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor)

        Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
        """
        return _Box2D.b2FrictionJointDef_Initialize(self, *args, **kwargs)

    localAnchorA = _swig_property(_Box2D.b2FrictionJointDef_localAnchorA_get, _Box2D.b2FrictionJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2FrictionJointDef_localAnchorB_get, _Box2D.b2FrictionJointDef_localAnchorB_set)
    maxForce = _swig_property(_Box2D.b2FrictionJointDef_maxForce_get, _Box2D.b2FrictionJointDef_maxForce_set)
    maxTorque = _swig_property(_Box2D.b2FrictionJointDef_maxTorque_get, _Box2D.b2FrictionJointDef_maxTorque_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchor','bodyA','bodyB','collideConnected','localAnchorA','localAnchorB','maxForce','maxTorque','type','userData']) 

    def __set_anchor(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise Exception('Neither body was set; unable to get world point.')

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2FrictionJointDef
b2FrictionJointDef.Initialize = new_instancemethod(_Box2D.b2FrictionJointDef_Initialize,None,b2FrictionJointDef)
b2FrictionJointDef_swigregister = _Box2D.b2FrictionJointDef_swigregister
b2FrictionJointDef_swigregister(b2FrictionJointDef)

class b2FrictionJoint(b2Joint):
    """Friction joint. This is used for top-down friction. It provides 2D translational friction and angular friction."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __SetMaxForce(self, *args, **kwargs):
        """
        __SetMaxForce(self, float32 force)

        Set the maximum friction force in N.
        """
        return _Box2D.b2FrictionJoint___SetMaxForce(self, *args, **kwargs)

    def __GetMaxForce(self):
        """
        __GetMaxForce(self) -> float32

        Get the maximum friction force in N.
        """
        return _Box2D.b2FrictionJoint___GetMaxForce(self)

    def __SetMaxTorque(self, *args, **kwargs):
        """
        __SetMaxTorque(self, float32 torque)

        Set the maximum friction torque in N*m.
        """
        return _Box2D.b2FrictionJoint___SetMaxTorque(self, *args, **kwargs)

    def __GetMaxTorque(self):
        """
        __GetMaxTorque(self) -> float32

        Get the maximum friction torque in N*m.
        """
        return _Box2D.b2FrictionJoint___GetMaxTorque(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','maxForce','maxTorque','type','userData']) 

    # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    maxTorque = property(__GetMaxTorque, __SetMaxTorque)

    __swig_destroy__ = _Box2D.delete_b2FrictionJoint
b2FrictionJoint.__SetMaxForce = new_instancemethod(_Box2D.b2FrictionJoint___SetMaxForce,None,b2FrictionJoint)
b2FrictionJoint.__GetMaxForce = new_instancemethod(_Box2D.b2FrictionJoint___GetMaxForce,None,b2FrictionJoint)
b2FrictionJoint.__SetMaxTorque = new_instancemethod(_Box2D.b2FrictionJoint___SetMaxTorque,None,b2FrictionJoint)
b2FrictionJoint.__GetMaxTorque = new_instancemethod(_Box2D.b2FrictionJoint___GetMaxTorque,None,b2FrictionJoint)
b2FrictionJoint_swigregister = _Box2D.b2FrictionJoint_swigregister
b2FrictionJoint_swigregister(b2FrictionJoint)

class b2GearJointDef(b2JointDef):
    """Gear joint definition. This definition requires two existing revolute or prismatic joints (any combination will work). The provided joints must attach a dynamic body to a static body."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2GearJointDef_swiginit(self,_Box2D.new_b2GearJointDef())
        _init_kwargs(self, **kwargs)


    joint1 = _swig_property(_Box2D.b2GearJointDef_joint1_get, _Box2D.b2GearJointDef_joint1_set)
    joint2 = _swig_property(_Box2D.b2GearJointDef_joint2_get, _Box2D.b2GearJointDef_joint2_set)
    ratio = _swig_property(_Box2D.b2GearJointDef_ratio_get, _Box2D.b2GearJointDef_ratio_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['bodyA','bodyB','collideConnected','joint1','joint2','ratio','type','userData']) 

    __swig_destroy__ = _Box2D.delete_b2GearJointDef
b2GearJointDef_swigregister = _Box2D.b2GearJointDef_swigregister
b2GearJointDef_swigregister(b2GearJointDef)

class b2GearJoint(b2Joint):
    """
    A gear joint is used to connect two joints together. Either joint can be a revolute or prismatic joint. You specify a gear ratio to bind the motions together: coordinate1 + ratio * coordinate2 = constant The ratio can be negative or positive. If one joint is a revolute joint and the other joint is a prismatic joint, then the ratio will have units of length or units of 1/length. 
    WARNING: 
    The revolute and prismatic joints must be attached to fixed bodies (which must be body1 on those joints).
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __SetRatio(self, *args, **kwargs):
        """
        __SetRatio(self, float32 ratio)

        Set/Get the gear ratio.
        """
        return _Box2D.b2GearJoint___SetRatio(self, *args, **kwargs)

    def __GetRatio(self):
        """__GetRatio(self) -> float32"""
        return _Box2D.b2GearJoint___GetRatio(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','ratio','type','userData']) 

    # Read-write properties
    ratio = property(__GetRatio, __SetRatio)


    __swig_destroy__ = _Box2D.delete_b2GearJoint
b2GearJoint.__SetRatio = new_instancemethod(_Box2D.b2GearJoint___SetRatio,None,b2GearJoint)
b2GearJoint.__GetRatio = new_instancemethod(_Box2D.b2GearJoint___GetRatio,None,b2GearJoint)
b2GearJoint_swigregister = _Box2D.b2GearJoint_swigregister
b2GearJoint_swigregister(b2GearJoint)

class b2WheelJointDef(b2JointDef):
    """Line joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2WheelJointDef_swiginit(self,_Box2D.new_b2WheelJointDef())
        _init_jointdef_kwargs(self, **kwargs)


    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor, b2Vec2 axis)

        Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
        """
        return _Box2D.b2WheelJointDef_Initialize(self, *args, **kwargs)

    localAnchorA = _swig_property(_Box2D.b2WheelJointDef_localAnchorA_get, _Box2D.b2WheelJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2WheelJointDef_localAnchorB_get, _Box2D.b2WheelJointDef_localAnchorB_set)
    localAxisA = _swig_property(_Box2D.b2WheelJointDef_localAxisA_get, _Box2D.b2WheelJointDef_localAxisA_set)
    enableMotor = _swig_property(_Box2D.b2WheelJointDef_enableMotor_get, _Box2D.b2WheelJointDef_enableMotor_set)
    maxMotorTorque = _swig_property(_Box2D.b2WheelJointDef_maxMotorTorque_get, _Box2D.b2WheelJointDef_maxMotorTorque_set)
    motorSpeed = _swig_property(_Box2D.b2WheelJointDef_motorSpeed_get, _Box2D.b2WheelJointDef_motorSpeed_set)
    frequencyHz = _swig_property(_Box2D.b2WheelJointDef_frequencyHz_get, _Box2D.b2WheelJointDef_frequencyHz_set)
    dampingRatio = _swig_property(_Box2D.b2WheelJointDef_dampingRatio_get, _Box2D.b2WheelJointDef_dampingRatio_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchor','axis','bodyA','bodyB','collideConnected','dampingRatio','enableMotor','frequencyHz','localAnchorA','localAnchorB','localAxisA','maxMotorTorque','motorSpeed','type','userData']) 

    def __set_anchor(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise Exception('Neither body was set; unable to get world point.')
    def __set_axis(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        self.localAxisA=self.bodyA.GetLocalVector(value)
    def __get_axis(self):
        if self.bodyA:
            return self.bodyA.GetWorldVector(self.localAxisA)
        raise Exception('Body A unset; unable to get world vector.')

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")
    axis = property(__get_axis, __set_axis, 
            doc="""The world translation axis on bodyA.
                Getting the property depends on bodyA and localAxisA.
                Setting the property requires that bodyA be set.""")

    __swig_destroy__ = _Box2D.delete_b2WheelJointDef
b2WheelJointDef.Initialize = new_instancemethod(_Box2D.b2WheelJointDef_Initialize,None,b2WheelJointDef)
b2WheelJointDef_swigregister = _Box2D.b2WheelJointDef_swigregister
b2WheelJointDef_swigregister(b2WheelJointDef)

class b2WheelJoint(b2Joint):
    """A line joint. This joint provides two degrees of freedom: translation along an axis fixed in body1 and rotation in the plane. You can use a joint limit to restrict the range of motion and a joint motor to drive the rotation or to model rotational friction. This joint is designed for vehicle suspensions."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __GetJointTranslation(self):
        """
        __GetJointTranslation(self) -> float32

        Get the current joint translation, usually in meters.
        """
        return _Box2D.b2WheelJoint___GetJointTranslation(self)

    def __GetJointSpeed(self):
        """
        __GetJointSpeed(self) -> float32

        Get the current joint translation speed, usually in meters per second.
        """
        return _Box2D.b2WheelJoint___GetJointSpeed(self)

    def __IsMotorEnabled(self):
        """
        __IsMotorEnabled(self) -> bool

        Is the joint motor enabled?
        """
        return _Box2D.b2WheelJoint___IsMotorEnabled(self)

    def __EnableMotor(self, *args, **kwargs):
        """
        __EnableMotor(self, bool flag)

        Enable/disable the joint motor.
        """
        return _Box2D.b2WheelJoint___EnableMotor(self, *args, **kwargs)

    def __SetMotorSpeed(self, *args, **kwargs):
        """
        __SetMotorSpeed(self, float32 speed)

        Set the motor speed, usually in radians per second.
        """
        return _Box2D.b2WheelJoint___SetMotorSpeed(self, *args, **kwargs)

    def __GetMotorSpeed(self):
        """
        __GetMotorSpeed(self) -> float32

        Get the motor speed, usually in radians per second.
        """
        return _Box2D.b2WheelJoint___GetMotorSpeed(self)

    def __SetMaxMotorTorque(self, *args, **kwargs):
        """
        __SetMaxMotorTorque(self, float32 torque)

        Set/Get the maximum motor force, usually in N-m.
        """
        return _Box2D.b2WheelJoint___SetMaxMotorTorque(self, *args, **kwargs)

    def __GetMaxMotorTorque(self):
        """__GetMaxMotorTorque(self) -> float32"""
        return _Box2D.b2WheelJoint___GetMaxMotorTorque(self)

    def GetMotorTorque(self, *args, **kwargs):
        """
        GetMotorTorque(self, float32 inv_dt) -> float32

        Get the current motor torque given the inverse time step, usually in N-m.
        """
        return _Box2D.b2WheelJoint_GetMotorTorque(self, *args, **kwargs)

    def __SetSpringFrequencyHz(self, *args, **kwargs):
        """
        __SetSpringFrequencyHz(self, float32 hz)

        Set/Get the spring frequency in hertz. Setting the frequency to zero disables the spring.
        """
        return _Box2D.b2WheelJoint___SetSpringFrequencyHz(self, *args, **kwargs)

    def __GetSpringFrequencyHz(self):
        """__GetSpringFrequencyHz(self) -> float32"""
        return _Box2D.b2WheelJoint___GetSpringFrequencyHz(self)

    def __SetSpringDampingRatio(self, *args, **kwargs):
        """
        __SetSpringDampingRatio(self, float32 ratio)

        Set/Get the spring damping ratio.
        """
        return _Box2D.b2WheelJoint___SetSpringDampingRatio(self, *args, **kwargs)

    def __GetSpringDampingRatio(self):
        """__GetSpringDampingRatio(self) -> float32"""
        return _Box2D.b2WheelJoint___GetSpringDampingRatio(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','maxMotorTorque','motorEnabled','motorSpeed','speed','springDampingRatio','springFrequencyHz','translation','type','userData']) 

    # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    maxMotorTorque = property(__GetMaxMotorTorque, __SetMaxMotorTorque)
    springFrequencyHz = property(__GetSpringFrequencyHz , __SetSpringFrequencyHz)
    springDampingRatio = property(__GetSpringDampingRatio , __SetSpringDampingRatio)

    # Read-only
    speed = property(__GetJointSpeed, None)
    translation = property(__GetJointTranslation, None)


    __swig_destroy__ = _Box2D.delete_b2WheelJoint
b2WheelJoint.__GetJointTranslation = new_instancemethod(_Box2D.b2WheelJoint___GetJointTranslation,None,b2WheelJoint)
b2WheelJoint.__GetJointSpeed = new_instancemethod(_Box2D.b2WheelJoint___GetJointSpeed,None,b2WheelJoint)
b2WheelJoint.__IsMotorEnabled = new_instancemethod(_Box2D.b2WheelJoint___IsMotorEnabled,None,b2WheelJoint)
b2WheelJoint.__EnableMotor = new_instancemethod(_Box2D.b2WheelJoint___EnableMotor,None,b2WheelJoint)
b2WheelJoint.__SetMotorSpeed = new_instancemethod(_Box2D.b2WheelJoint___SetMotorSpeed,None,b2WheelJoint)
b2WheelJoint.__GetMotorSpeed = new_instancemethod(_Box2D.b2WheelJoint___GetMotorSpeed,None,b2WheelJoint)
b2WheelJoint.__SetMaxMotorTorque = new_instancemethod(_Box2D.b2WheelJoint___SetMaxMotorTorque,None,b2WheelJoint)
b2WheelJoint.__GetMaxMotorTorque = new_instancemethod(_Box2D.b2WheelJoint___GetMaxMotorTorque,None,b2WheelJoint)
b2WheelJoint.GetMotorTorque = new_instancemethod(_Box2D.b2WheelJoint_GetMotorTorque,None,b2WheelJoint)
b2WheelJoint.__SetSpringFrequencyHz = new_instancemethod(_Box2D.b2WheelJoint___SetSpringFrequencyHz,None,b2WheelJoint)
b2WheelJoint.__GetSpringFrequencyHz = new_instancemethod(_Box2D.b2WheelJoint___GetSpringFrequencyHz,None,b2WheelJoint)
b2WheelJoint.__SetSpringDampingRatio = new_instancemethod(_Box2D.b2WheelJoint___SetSpringDampingRatio,None,b2WheelJoint)
b2WheelJoint.__GetSpringDampingRatio = new_instancemethod(_Box2D.b2WheelJoint___GetSpringDampingRatio,None,b2WheelJoint)
b2WheelJoint_swigregister = _Box2D.b2WheelJoint_swigregister
b2WheelJoint_swigregister(b2WheelJoint)

class b2MouseJointDef(b2JointDef):
    """Mouse joint definition. This requires a world target point, tuning parameters, and the time step."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2MouseJointDef_swiginit(self,_Box2D.new_b2MouseJointDef())
        _init_kwargs(self, **kwargs)


    target = _swig_property(_Box2D.b2MouseJointDef_target_get, _Box2D.b2MouseJointDef_target_set)
    maxForce = _swig_property(_Box2D.b2MouseJointDef_maxForce_get, _Box2D.b2MouseJointDef_maxForce_set)
    frequencyHz = _swig_property(_Box2D.b2MouseJointDef_frequencyHz_get, _Box2D.b2MouseJointDef_frequencyHz_set)
    dampingRatio = _swig_property(_Box2D.b2MouseJointDef_dampingRatio_get, _Box2D.b2MouseJointDef_dampingRatio_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['bodyA','bodyB','collideConnected','dampingRatio','frequencyHz','maxForce','target','type','userData']) 

    __swig_destroy__ = _Box2D.delete_b2MouseJointDef
b2MouseJointDef_swigregister = _Box2D.b2MouseJointDef_swigregister
b2MouseJointDef_swigregister(b2MouseJointDef)

class b2MouseJoint(b2Joint):
    """A mouse joint is used to make a point on a body track a specified world point. This a soft constraint with a maximum force. This allows the constraint to stretch and without applying huge forces. NOTE: this joint is not documented in the manual because it was developed to be used in the testbed. If you want to learn how to use the mouse joint, look at the testbed."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __SetTarget(self, *args, **kwargs):
        """
        __SetTarget(self, b2Vec2 target)

        Use this to update the target point.
        """
        return _Box2D.b2MouseJoint___SetTarget(self, *args, **kwargs)

    def __GetTarget(self):
        """__GetTarget(self) -> b2Vec2"""
        return _Box2D.b2MouseJoint___GetTarget(self)

    def __SetMaxForce(self, *args, **kwargs):
        """
        __SetMaxForce(self, float32 force)

        Set/get the maximum force in Newtons.
        """
        return _Box2D.b2MouseJoint___SetMaxForce(self, *args, **kwargs)

    def __GetMaxForce(self):
        """__GetMaxForce(self) -> float32"""
        return _Box2D.b2MouseJoint___GetMaxForce(self)

    def __SetFrequency(self, *args, **kwargs):
        """
        __SetFrequency(self, float32 hz)

        Set/get the frequency in Hertz.
        """
        return _Box2D.b2MouseJoint___SetFrequency(self, *args, **kwargs)

    def __GetFrequency(self):
        """__GetFrequency(self) -> float32"""
        return _Box2D.b2MouseJoint___GetFrequency(self)

    def __SetDampingRatio(self, *args, **kwargs):
        """
        __SetDampingRatio(self, float32 ratio)

        Set/get the damping ratio (dimensionless).
        """
        return _Box2D.b2MouseJoint___SetDampingRatio(self, *args, **kwargs)

    def __GetDampingRatio(self):
        """__GetDampingRatio(self) -> float32"""
        return _Box2D.b2MouseJoint___GetDampingRatio(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','dampingRatio','frequency','maxForce','target','type','userData']) 

    # Read-write properties
    maxForce = property(__GetMaxForce, __SetMaxForce)
    frequency = property(__GetFrequency, __SetFrequency)
    dampingRatio = property(__GetDampingRatio, __SetDampingRatio)
    target = property(__GetTarget, __SetTarget)


    __swig_destroy__ = _Box2D.delete_b2MouseJoint
b2MouseJoint.__SetTarget = new_instancemethod(_Box2D.b2MouseJoint___SetTarget,None,b2MouseJoint)
b2MouseJoint.__GetTarget = new_instancemethod(_Box2D.b2MouseJoint___GetTarget,None,b2MouseJoint)
b2MouseJoint.__SetMaxForce = new_instancemethod(_Box2D.b2MouseJoint___SetMaxForce,None,b2MouseJoint)
b2MouseJoint.__GetMaxForce = new_instancemethod(_Box2D.b2MouseJoint___GetMaxForce,None,b2MouseJoint)
b2MouseJoint.__SetFrequency = new_instancemethod(_Box2D.b2MouseJoint___SetFrequency,None,b2MouseJoint)
b2MouseJoint.__GetFrequency = new_instancemethod(_Box2D.b2MouseJoint___GetFrequency,None,b2MouseJoint)
b2MouseJoint.__SetDampingRatio = new_instancemethod(_Box2D.b2MouseJoint___SetDampingRatio,None,b2MouseJoint)
b2MouseJoint.__GetDampingRatio = new_instancemethod(_Box2D.b2MouseJoint___GetDampingRatio,None,b2MouseJoint)
b2MouseJoint_swigregister = _Box2D.b2MouseJoint_swigregister
b2MouseJoint_swigregister(b2MouseJoint)

class b2PrismaticJointDef(b2JointDef):
    """
    Prismatic joint definition. This requires defining a line of motion using an axis and an anchor point. The definition uses local anchor points and a local axis so that the initial configuration can violate the constraint slightly. The joint translation is zero when the local anchor points coincide in world space. Using local anchors and a local axis helps when saving and loading a game. 
    WARNING: 
    at least one body should by dynamic with a non-fixed rotation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2PrismaticJointDef_swiginit(self,_Box2D.new_b2PrismaticJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle


    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor, b2Vec2 axis)

        Initialize the bodies, anchors, axis, and reference angle using the world anchor and world axis.
        """
        return _Box2D.b2PrismaticJointDef_Initialize(self, *args, **kwargs)

    localAnchorA = _swig_property(_Box2D.b2PrismaticJointDef_localAnchorA_get, _Box2D.b2PrismaticJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2PrismaticJointDef_localAnchorB_get, _Box2D.b2PrismaticJointDef_localAnchorB_set)
    localAxis1 = _swig_property(_Box2D.b2PrismaticJointDef_localAxis1_get, _Box2D.b2PrismaticJointDef_localAxis1_set)
    referenceAngle = _swig_property(_Box2D.b2PrismaticJointDef_referenceAngle_get, _Box2D.b2PrismaticJointDef_referenceAngle_set)
    enableLimit = _swig_property(_Box2D.b2PrismaticJointDef_enableLimit_get, _Box2D.b2PrismaticJointDef_enableLimit_set)
    lowerTranslation = _swig_property(_Box2D.b2PrismaticJointDef_lowerTranslation_get, _Box2D.b2PrismaticJointDef_lowerTranslation_set)
    upperTranslation = _swig_property(_Box2D.b2PrismaticJointDef_upperTranslation_get, _Box2D.b2PrismaticJointDef_upperTranslation_set)
    enableMotor = _swig_property(_Box2D.b2PrismaticJointDef_enableMotor_get, _Box2D.b2PrismaticJointDef_enableMotor_set)
    maxMotorForce = _swig_property(_Box2D.b2PrismaticJointDef_maxMotorForce_get, _Box2D.b2PrismaticJointDef_maxMotorForce_set)
    motorSpeed = _swig_property(_Box2D.b2PrismaticJointDef_motorSpeed_get, _Box2D.b2PrismaticJointDef_motorSpeed_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchor','axis','bodyA','bodyB','collideConnected','enableLimit','enableMotor','localAnchorA','localAnchorB','localAxis1','lowerTranslation','maxMotorForce','motorSpeed','referenceAngle','type','upperTranslation','userData']) 

    def __set_anchor(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise Exception('Neither body was set; unable to get world point.')
    def __set_axis(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        self.localAxisA=self.bodyA.GetLocalVector(value)
    def __get_axis(self):
        if not self.bodyA:
            raise Exception('Body A unset; unable to get world vector.')
        return self.bodyA.GetWorldVector(self.localAxisA)

    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")
    axis = property(__get_axis, __set_axis, 
            doc="""The world translation axis on bodyA.
                Getting the property depends on bodyA and localAxisA.
                Setting the property requires that bodyA be set.""")

    __swig_destroy__ = _Box2D.delete_b2PrismaticJointDef
b2PrismaticJointDef.Initialize = new_instancemethod(_Box2D.b2PrismaticJointDef_Initialize,None,b2PrismaticJointDef)
b2PrismaticJointDef_swigregister = _Box2D.b2PrismaticJointDef_swigregister
b2PrismaticJointDef_swigregister(b2PrismaticJointDef)

class b2PrismaticJoint(b2Joint):
    """A prismatic joint. This joint provides one degree of freedom: translation along an axis fixed in body1. Relative rotation is prevented. You can use a joint limit to restrict the range of motion and a joint motor to drive the motion or to model joint friction."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __GetJointTranslation(self):
        """
        __GetJointTranslation(self) -> float32

        Get the current joint translation, usually in meters.
        """
        return _Box2D.b2PrismaticJoint___GetJointTranslation(self)

    def __GetJointSpeed(self):
        """
        __GetJointSpeed(self) -> float32

        Get the current joint translation speed, usually in meters per second.
        """
        return _Box2D.b2PrismaticJoint___GetJointSpeed(self)

    def __IsLimitEnabled(self):
        """
        __IsLimitEnabled(self) -> bool

        Is the joint limit enabled?
        """
        return _Box2D.b2PrismaticJoint___IsLimitEnabled(self)

    def __EnableLimit(self, *args, **kwargs):
        """
        __EnableLimit(self, bool flag)

        Enable/disable the joint limit.
        """
        return _Box2D.b2PrismaticJoint___EnableLimit(self, *args, **kwargs)

    def __GetLowerLimit(self):
        """
        __GetLowerLimit(self) -> float32

        Get the lower joint limit, usually in meters.
        """
        return _Box2D.b2PrismaticJoint___GetLowerLimit(self)

    def __GetUpperLimit(self):
        """
        __GetUpperLimit(self) -> float32

        Get the upper joint limit, usually in meters.
        """
        return _Box2D.b2PrismaticJoint___GetUpperLimit(self)

    def SetLimits(self, *args, **kwargs):
        """
        SetLimits(self, float32 lower, float32 upper)

        Set the joint limits, usually in meters.
        """
        return _Box2D.b2PrismaticJoint_SetLimits(self, *args, **kwargs)

    def __IsMotorEnabled(self):
        """
        __IsMotorEnabled(self) -> bool

        Is the joint motor enabled?
        """
        return _Box2D.b2PrismaticJoint___IsMotorEnabled(self)

    def __EnableMotor(self, *args, **kwargs):
        """
        __EnableMotor(self, bool flag)

        Enable/disable the joint motor.
        """
        return _Box2D.b2PrismaticJoint___EnableMotor(self, *args, **kwargs)

    def __SetMotorSpeed(self, *args, **kwargs):
        """
        __SetMotorSpeed(self, float32 speed)

        Set the motor speed, usually in meters per second.
        """
        return _Box2D.b2PrismaticJoint___SetMotorSpeed(self, *args, **kwargs)

    def __GetMotorSpeed(self):
        """
        __GetMotorSpeed(self) -> float32

        Get the motor speed, usually in meters per second.
        """
        return _Box2D.b2PrismaticJoint___GetMotorSpeed(self)

    def __SetMaxMotorForce(self, *args, **kwargs):
        """
        __SetMaxMotorForce(self, float32 force)

        Set the maximum motor force, usually in N.
        """
        return _Box2D.b2PrismaticJoint___SetMaxMotorForce(self, *args, **kwargs)

    def __GetMaxMotorForce(self):
        """__GetMaxMotorForce(self) -> float32"""
        return _Box2D.b2PrismaticJoint___GetMaxMotorForce(self)

    def GetMotorForce(self, *args, **kwargs):
        """
        GetMotorForce(self, float32 inv_dt) -> float32

        Get the current motor force given the inverse time step, usually in N.
        """
        return _Box2D.b2PrismaticJoint_GetMotorForce(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','limitEnabled','limits','lowerLimit','maxMotorForce','motorEnabled','motorSpeed','speed','translation','type','upperLimit','userData']) 

    # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    limitEnabled = property(__IsLimitEnabled, __EnableLimit)
    upperLimit = property(__GetUpperLimit, lambda self, v: self.SetLimits(self.lowerLimit, v))
    lowerLimit = property(__GetLowerLimit, lambda self, v: self.SetLimits(v, self.upperLimit))
    limits = property(lambda self: (self.lowerLimit, self.upperLimit), lambda self, v: self.SetLimits(*v) )
    maxMotorForce = property(__GetMaxMotorForce, __SetMaxMotorForce)

    # Read-only
    translation = property(__GetJointTranslation, None)
    speed = property(__GetJointSpeed, None)


    __swig_destroy__ = _Box2D.delete_b2PrismaticJoint
b2PrismaticJoint.__GetJointTranslation = new_instancemethod(_Box2D.b2PrismaticJoint___GetJointTranslation,None,b2PrismaticJoint)
b2PrismaticJoint.__GetJointSpeed = new_instancemethod(_Box2D.b2PrismaticJoint___GetJointSpeed,None,b2PrismaticJoint)
b2PrismaticJoint.__IsLimitEnabled = new_instancemethod(_Box2D.b2PrismaticJoint___IsLimitEnabled,None,b2PrismaticJoint)
b2PrismaticJoint.__EnableLimit = new_instancemethod(_Box2D.b2PrismaticJoint___EnableLimit,None,b2PrismaticJoint)
b2PrismaticJoint.__GetLowerLimit = new_instancemethod(_Box2D.b2PrismaticJoint___GetLowerLimit,None,b2PrismaticJoint)
b2PrismaticJoint.__GetUpperLimit = new_instancemethod(_Box2D.b2PrismaticJoint___GetUpperLimit,None,b2PrismaticJoint)
b2PrismaticJoint.SetLimits = new_instancemethod(_Box2D.b2PrismaticJoint_SetLimits,None,b2PrismaticJoint)
b2PrismaticJoint.__IsMotorEnabled = new_instancemethod(_Box2D.b2PrismaticJoint___IsMotorEnabled,None,b2PrismaticJoint)
b2PrismaticJoint.__EnableMotor = new_instancemethod(_Box2D.b2PrismaticJoint___EnableMotor,None,b2PrismaticJoint)
b2PrismaticJoint.__SetMotorSpeed = new_instancemethod(_Box2D.b2PrismaticJoint___SetMotorSpeed,None,b2PrismaticJoint)
b2PrismaticJoint.__GetMotorSpeed = new_instancemethod(_Box2D.b2PrismaticJoint___GetMotorSpeed,None,b2PrismaticJoint)
b2PrismaticJoint.__SetMaxMotorForce = new_instancemethod(_Box2D.b2PrismaticJoint___SetMaxMotorForce,None,b2PrismaticJoint)
b2PrismaticJoint.__GetMaxMotorForce = new_instancemethod(_Box2D.b2PrismaticJoint___GetMaxMotorForce,None,b2PrismaticJoint)
b2PrismaticJoint.GetMotorForce = new_instancemethod(_Box2D.b2PrismaticJoint_GetMotorForce,None,b2PrismaticJoint)
b2PrismaticJoint_swigregister = _Box2D.b2PrismaticJoint_swigregister
b2PrismaticJoint_swigregister(b2PrismaticJoint)

class b2PulleyJointDef(b2JointDef):
    """Pulley joint definition. This requires two ground anchors, two dynamic body anchor points, max lengths for each side, and a pulley ratio."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2PulleyJointDef_swiginit(self,_Box2D.new_b2PulleyJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        
        lengthA_set=False
        lengthB_set=False
        if 'anchorA' in kwargs or 'anchorB' in kwargs:
            
            
            if 'lengthA' in kwargs:
                self.lengthA = kwargs['lengthA']
                lengthA_set=True
            if 'lengthB' in kwargs:
                self.lengthB = kwargs['lengthB']
                lengthB_set=True

        if 'anchorA' in kwargs and 'groundAnchorA' in kwargs and 'lengthA' not in kwargs:
            d1 = self.anchorA - self.groundAnchorA
            self.lengthA = d1.length
            lengthA_set=True

        if 'anchorB' in kwargs and 'groundAnchorB' in kwargs and 'lengthB' not in kwargs:
            d2 = self.anchorB - self.groundAnchorB
            self.lengthB = d2.length
            lengthB_set=True

        if 'ratio' in kwargs:
            assert(self.ratio > globals()['b2_epsilon']) # Ratio too small
            if lengthA_set and lengthB_set and 'maxLengthA' not in kwargs and 'maxLengthB' not in kwargs:
                C = self.lengthA + self.ratio * self.lengthB
                self.maxLengthA = C - self.ratio * b2_minPulleyLength
                self.maxLengthB = (C - b2_minPulleyLength) / self.ratio


    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Body bodyA, b2Body bodyB, b2Vec2 groundAnchorA, b2Vec2 groundAnchorB, 
            b2Vec2 anchorA, b2Vec2 anchorB, 
            float32 ratio)

        Initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.
        """
        return _Box2D.b2PulleyJointDef_Initialize(self, *args, **kwargs)

    groundAnchorA = _swig_property(_Box2D.b2PulleyJointDef_groundAnchorA_get, _Box2D.b2PulleyJointDef_groundAnchorA_set)
    groundAnchorB = _swig_property(_Box2D.b2PulleyJointDef_groundAnchorB_get, _Box2D.b2PulleyJointDef_groundAnchorB_set)
    localAnchorA = _swig_property(_Box2D.b2PulleyJointDef_localAnchorA_get, _Box2D.b2PulleyJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2PulleyJointDef_localAnchorB_get, _Box2D.b2PulleyJointDef_localAnchorB_set)
    lengthA = _swig_property(_Box2D.b2PulleyJointDef_lengthA_get, _Box2D.b2PulleyJointDef_lengthA_set)
    lengthB = _swig_property(_Box2D.b2PulleyJointDef_lengthB_get, _Box2D.b2PulleyJointDef_lengthB_set)
    ratio = _swig_property(_Box2D.b2PulleyJointDef_ratio_get, _Box2D.b2PulleyJointDef_ratio_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchorA','anchorB','bodyA','bodyB','collideConnected','groundAnchorA','groundAnchorB','lengthA','lengthB','localAnchorA','localAnchorB','maxLengthA','maxLengthB','ratio','type','userData']) 

    def __update_length(self):
        if self.bodyA:
            d1 = self.anchorA - self.groundAnchorA
            self.lengthA = d1.length
        if self.bodyB:
            d1 = self.anchorB - self.groundAnchorB
            self.lengthB = d1.length
    def __set_anchorA(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.__update_length()
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
        self.__update_length()
    def __get_anchorA(self):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise Exception('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2PulleyJointDef
b2PulleyJointDef.Initialize = new_instancemethod(_Box2D.b2PulleyJointDef_Initialize,None,b2PulleyJointDef)
b2PulleyJointDef_swigregister = _Box2D.b2PulleyJointDef_swigregister
b2PulleyJointDef_swigregister(b2PulleyJointDef)
b2_minPulleyLength = b2Globals.b2_minPulleyLength

class b2PulleyJoint(b2Joint):
    """The pulley joint is connected to two bodies and two fixed ground points. The pulley supports a ratio such that: length1 + ratio * length2 <= constant Yes, the force transmitted is scaled by the ratio. The pulley also enforces a maximum length limit on both sides. This is useful to prevent one side of the pulley hitting the top."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __GetGroundAnchorA(self):
        """
        __GetGroundAnchorA(self) -> b2Vec2

        Get the first ground anchor.
        """
        return _Box2D.b2PulleyJoint___GetGroundAnchorA(self)

    def __GetGroundAnchorB(self):
        """
        __GetGroundAnchorB(self) -> b2Vec2

        Get the second ground anchor.
        """
        return _Box2D.b2PulleyJoint___GetGroundAnchorB(self)

    def __GetLength1(self):
        """
        __GetLength1(self) -> float32

        Get the current length of the segment attached to body1.
        """
        return _Box2D.b2PulleyJoint___GetLength1(self)

    def __GetLength2(self):
        """
        __GetLength2(self) -> float32

        Get the current length of the segment attached to body2.
        """
        return _Box2D.b2PulleyJoint___GetLength2(self)

    def __GetRatio(self):
        """
        __GetRatio(self) -> float32

        Get the pulley ratio.
        """
        return _Box2D.b2PulleyJoint___GetRatio(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','groundAnchorA','groundAnchorB','length1','length2','ratio','type','userData']) 

    # Read-only
    groundAnchorB = property(__GetGroundAnchorB, None)
    groundAnchorA = property(__GetGroundAnchorA, None)
    length2 = property(__GetLength2, None)
    length1 = property(__GetLength1, None)
    ratio = property(__GetRatio, None)


    __swig_destroy__ = _Box2D.delete_b2PulleyJoint
b2PulleyJoint.__GetGroundAnchorA = new_instancemethod(_Box2D.b2PulleyJoint___GetGroundAnchorA,None,b2PulleyJoint)
b2PulleyJoint.__GetGroundAnchorB = new_instancemethod(_Box2D.b2PulleyJoint___GetGroundAnchorB,None,b2PulleyJoint)
b2PulleyJoint.__GetLength1 = new_instancemethod(_Box2D.b2PulleyJoint___GetLength1,None,b2PulleyJoint)
b2PulleyJoint.__GetLength2 = new_instancemethod(_Box2D.b2PulleyJoint___GetLength2,None,b2PulleyJoint)
b2PulleyJoint.__GetRatio = new_instancemethod(_Box2D.b2PulleyJoint___GetRatio,None,b2PulleyJoint)
b2PulleyJoint_swigregister = _Box2D.b2PulleyJoint_swigregister
b2PulleyJoint_swigregister(b2PulleyJoint)

class b2RevoluteJointDef(b2JointDef):
    """Revolute joint definition. This requires defining an anchor point where the bodies are joined. The definition uses local anchor points so that the initial configuration can violate the constraint slightly. You also need to specify the initial relative angle for joint limits. This helps when saving and loading a game. The local anchor points are measured from the body's origin rather than the center of mass because: 1. you might not know where the center of mass will be. 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2RevoluteJointDef_swiginit(self,_Box2D.new_b2RevoluteJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle


    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Body bodyA, b2Body bodyB, b2Vec2 anchor)

        Initialize the bodies, anchors, and reference angle using a world anchor point.
        """
        return _Box2D.b2RevoluteJointDef_Initialize(self, *args, **kwargs)

    localAnchorA = _swig_property(_Box2D.b2RevoluteJointDef_localAnchorA_get, _Box2D.b2RevoluteJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2RevoluteJointDef_localAnchorB_get, _Box2D.b2RevoluteJointDef_localAnchorB_set)
    referenceAngle = _swig_property(_Box2D.b2RevoluteJointDef_referenceAngle_get, _Box2D.b2RevoluteJointDef_referenceAngle_set)
    enableLimit = _swig_property(_Box2D.b2RevoluteJointDef_enableLimit_get, _Box2D.b2RevoluteJointDef_enableLimit_set)
    lowerAngle = _swig_property(_Box2D.b2RevoluteJointDef_lowerAngle_get, _Box2D.b2RevoluteJointDef_lowerAngle_set)
    upperAngle = _swig_property(_Box2D.b2RevoluteJointDef_upperAngle_get, _Box2D.b2RevoluteJointDef_upperAngle_set)
    enableMotor = _swig_property(_Box2D.b2RevoluteJointDef_enableMotor_get, _Box2D.b2RevoluteJointDef_enableMotor_set)
    motorSpeed = _swig_property(_Box2D.b2RevoluteJointDef_motorSpeed_get, _Box2D.b2RevoluteJointDef_motorSpeed_set)
    maxMotorTorque = _swig_property(_Box2D.b2RevoluteJointDef_maxMotorTorque_get, _Box2D.b2RevoluteJointDef_maxMotorTorque_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchor','bodyA','bodyB','collideConnected','enableLimit','enableMotor','localAnchorA','localAnchorB','lowerAngle','maxMotorTorque','motorSpeed','referenceAngle','type','upperAngle','userData']) 

    def __set_anchor(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise Exception('Neither body was set; unable to get world point.')
    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2RevoluteJointDef
b2RevoluteJointDef.Initialize = new_instancemethod(_Box2D.b2RevoluteJointDef_Initialize,None,b2RevoluteJointDef)
b2RevoluteJointDef_swigregister = _Box2D.b2RevoluteJointDef_swigregister
b2RevoluteJointDef_swigregister(b2RevoluteJointDef)

class b2RevoluteJoint(b2Joint):
    """A revolute joint constrains two bodies to share a common point while they are free to rotate about the point. The relative rotation about the shared point is the joint angle. You can limit the relative rotation with a joint limit that specifies a lower and upper angle. You can use a motor to drive the relative rotation about the shared point. A maximum motor torque is provided so that infinite forces are not generated."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __GetJointAngle(self):
        """
        __GetJointAngle(self) -> float32

        Get the current joint angle in radians.
        """
        return _Box2D.b2RevoluteJoint___GetJointAngle(self)

    def __GetJointSpeed(self):
        """
        __GetJointSpeed(self) -> float32

        Get the current joint angle speed in radians per second.
        """
        return _Box2D.b2RevoluteJoint___GetJointSpeed(self)

    def __IsLimitEnabled(self):
        """
        __IsLimitEnabled(self) -> bool

        Is the joint limit enabled?
        """
        return _Box2D.b2RevoluteJoint___IsLimitEnabled(self)

    def __EnableLimit(self, *args, **kwargs):
        """
        __EnableLimit(self, bool flag)

        Enable/disable the joint limit.
        """
        return _Box2D.b2RevoluteJoint___EnableLimit(self, *args, **kwargs)

    def __GetLowerLimit(self):
        """
        __GetLowerLimit(self) -> float32

        Get the lower joint limit in radians.
        """
        return _Box2D.b2RevoluteJoint___GetLowerLimit(self)

    def __GetUpperLimit(self):
        """
        __GetUpperLimit(self) -> float32

        Get the upper joint limit in radians.
        """
        return _Box2D.b2RevoluteJoint___GetUpperLimit(self)

    def SetLimits(self, *args, **kwargs):
        """
        SetLimits(self, float32 lower, float32 upper)

        Set the joint limits in radians.
        """
        return _Box2D.b2RevoluteJoint_SetLimits(self, *args, **kwargs)

    def __IsMotorEnabled(self):
        """
        __IsMotorEnabled(self) -> bool

        Is the joint motor enabled?
        """
        return _Box2D.b2RevoluteJoint___IsMotorEnabled(self)

    def __EnableMotor(self, *args, **kwargs):
        """
        __EnableMotor(self, bool flag)

        Enable/disable the joint motor.
        """
        return _Box2D.b2RevoluteJoint___EnableMotor(self, *args, **kwargs)

    def __SetMotorSpeed(self, *args, **kwargs):
        """
        __SetMotorSpeed(self, float32 speed)

        Set the motor speed in radians per second.
        """
        return _Box2D.b2RevoluteJoint___SetMotorSpeed(self, *args, **kwargs)

    def __GetMotorSpeed(self):
        """
        __GetMotorSpeed(self) -> float32

        Get the motor speed in radians per second.
        """
        return _Box2D.b2RevoluteJoint___GetMotorSpeed(self)

    def __SetMaxMotorTorque(self, *args, **kwargs):
        """
        __SetMaxMotorTorque(self, float32 torque)

        Set the maximum motor torque, usually in N-m.
        """
        return _Box2D.b2RevoluteJoint___SetMaxMotorTorque(self, *args, **kwargs)

    def GetMotorTorque(self, *args, **kwargs):
        """
        GetMotorTorque(self, float32 inv_dt) -> float32

        Get the current motor torque given the inverse time step. Unit is N*m.
        """
        return _Box2D.b2RevoluteJoint_GetMotorTorque(self, *args, **kwargs)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','angle','bodyA','bodyB','limitEnabled','limits','lowerLimit','maxMotorTorque','motorEnabled','motorSpeed','speed','type','upperLimit','userData']) 

    # Read-write properties
    motorSpeed = property(__GetMotorSpeed, __SetMotorSpeed)
    upperLimit = property(__GetUpperLimit, lambda self, v: self.SetLimits(self.lowerLimit, v))
    lowerLimit = property(__GetLowerLimit, lambda self, v: self.SetLimits(v, self.upperLimit))
    limits = property(lambda self: (self.lowerLimit, self.upperLimit), lambda self, v: self.SetLimits(*v) )
    motorEnabled = property(__IsMotorEnabled, __EnableMotor)
    limitEnabled = property(__IsLimitEnabled, __EnableLimit)

    # Read-only
    angle = property(__GetJointAngle, None)
    speed = property(__GetJointSpeed, None)

    # Write-only
    maxMotorTorque = property(None, __SetMaxMotorTorque)


    __swig_destroy__ = _Box2D.delete_b2RevoluteJoint
b2RevoluteJoint.__GetJointAngle = new_instancemethod(_Box2D.b2RevoluteJoint___GetJointAngle,None,b2RevoluteJoint)
b2RevoluteJoint.__GetJointSpeed = new_instancemethod(_Box2D.b2RevoluteJoint___GetJointSpeed,None,b2RevoluteJoint)
b2RevoluteJoint.__IsLimitEnabled = new_instancemethod(_Box2D.b2RevoluteJoint___IsLimitEnabled,None,b2RevoluteJoint)
b2RevoluteJoint.__EnableLimit = new_instancemethod(_Box2D.b2RevoluteJoint___EnableLimit,None,b2RevoluteJoint)
b2RevoluteJoint.__GetLowerLimit = new_instancemethod(_Box2D.b2RevoluteJoint___GetLowerLimit,None,b2RevoluteJoint)
b2RevoluteJoint.__GetUpperLimit = new_instancemethod(_Box2D.b2RevoluteJoint___GetUpperLimit,None,b2RevoluteJoint)
b2RevoluteJoint.SetLimits = new_instancemethod(_Box2D.b2RevoluteJoint_SetLimits,None,b2RevoluteJoint)
b2RevoluteJoint.__IsMotorEnabled = new_instancemethod(_Box2D.b2RevoluteJoint___IsMotorEnabled,None,b2RevoluteJoint)
b2RevoluteJoint.__EnableMotor = new_instancemethod(_Box2D.b2RevoluteJoint___EnableMotor,None,b2RevoluteJoint)
b2RevoluteJoint.__SetMotorSpeed = new_instancemethod(_Box2D.b2RevoluteJoint___SetMotorSpeed,None,b2RevoluteJoint)
b2RevoluteJoint.__GetMotorSpeed = new_instancemethod(_Box2D.b2RevoluteJoint___GetMotorSpeed,None,b2RevoluteJoint)
b2RevoluteJoint.__SetMaxMotorTorque = new_instancemethod(_Box2D.b2RevoluteJoint___SetMaxMotorTorque,None,b2RevoluteJoint)
b2RevoluteJoint.GetMotorTorque = new_instancemethod(_Box2D.b2RevoluteJoint_GetMotorTorque,None,b2RevoluteJoint)
b2RevoluteJoint_swigregister = _Box2D.b2RevoluteJoint_swigregister
b2RevoluteJoint_swigregister(b2RevoluteJoint)

class b2RopeJointDef(b2JointDef):
    """Rope joint definition. This requires two body anchor points and a maximum lengths. Note: by default the connected objects will not collide. see collideConnected in  b2JointDef."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2RopeJointDef_swiginit(self,_Box2D.new_b2RopeJointDef())
        _init_jointdef_kwargs(self, **kwargs)


    localAnchorA = _swig_property(_Box2D.b2RopeJointDef_localAnchorA_get, _Box2D.b2RopeJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2RopeJointDef_localAnchorB_get, _Box2D.b2RopeJointDef_localAnchorB_set)
    maxLength = _swig_property(_Box2D.b2RopeJointDef_maxLength_get, _Box2D.b2RopeJointDef_maxLength_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchorA','anchorB','bodyA','bodyB','collideConnected','localAnchorA','localAnchorB','maxLength','type','userData']) 

    def __set_anchorA(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
    def __set_anchorB(self, value):
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchorA(self):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        return self.bodyA.GetWorldPoint(self.localAnchorA)
    def __get_anchorB(self):
        if not self.bodyB:
            raise Exception('bodyB not set.')
        return self.bodyB.GetWorldPoint(self.localAnchorB)

    anchorA = property(__get_anchorA, __set_anchorA, 
            doc="""Body A's anchor in world coordinates.
                Getting the property depends on both bodyA and localAnchorA.
                Setting the property requires that bodyA be set.""")
    anchorB = property(__get_anchorB, __set_anchorB, 
            doc="""Body B's anchor in world coordinates.
                Getting the property depends on both bodyB and localAnchorB.
                Setting the property requires that bodyB be set.""")

    __swig_destroy__ = _Box2D.delete_b2RopeJointDef
b2RopeJointDef_swigregister = _Box2D.b2RopeJointDef_swigregister
b2RopeJointDef_swigregister(b2RopeJointDef)

class b2RopeJoint(b2Joint):
    """A rope joint enforces a maximum distance between two points on two bodies. It has no other effect. Warning: if you attempt to change the maximum length during the simulation you will get some non-physical behavior. A model that would allow you to dynamically modify the length would have some sponginess, so I chose not to implement it that way. See  b2DistanceJointif you want to dynamically control length."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def __GetMaxLength(self):
        """
        __GetMaxLength(self) -> float32

        Get the maximum length of the rope.
        """
        return _Box2D.b2RopeJoint___GetMaxLength(self)

    def __GetLimitState(self):
        """__GetLimitState(self) -> b2LimitState"""
        return _Box2D.b2RopeJoint___GetLimitState(self)

    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','limitState','maxLength','type','userData']) 

    # Read-only properties
    maxLength = property(__GetMaxLength, None)
    limitState = property(__GetLimitState, None)

    # Read-write properties


    __swig_destroy__ = _Box2D.delete_b2RopeJoint
b2RopeJoint.__GetMaxLength = new_instancemethod(_Box2D.b2RopeJoint___GetMaxLength,None,b2RopeJoint)
b2RopeJoint.__GetLimitState = new_instancemethod(_Box2D.b2RopeJoint___GetLimitState,None,b2RopeJoint)
b2RopeJoint_swigregister = _Box2D.b2RopeJoint_swigregister
b2RopeJoint_swigregister(b2RopeJoint)

class b2WeldJointDef(b2JointDef):
    """Weld joint definition. You need to specify local anchor points where they are attached and the relative body angle. The position of the anchor points is important for computing the reaction torque."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, **kwargs):
        _Box2D.b2WeldJointDef_swiginit(self,_Box2D.new_b2WeldJointDef())
        _init_jointdef_kwargs(self, **kwargs)
        if self.bodyA and self.bodyB and 'referenceAngle' not in kwargs:
            self.referenceAngle = self.bodyB.angle - self.bodyA.angle


    def Initialize(self, *args, **kwargs):
        """
        Initialize(self, b2Body body1, b2Body body2, b2Vec2 anchor)

        Initialize the bodies, anchors, and reference angle using a world anchor point.
        """
        return _Box2D.b2WeldJointDef_Initialize(self, *args, **kwargs)

    localAnchorA = _swig_property(_Box2D.b2WeldJointDef_localAnchorA_get, _Box2D.b2WeldJointDef_localAnchorA_set)
    localAnchorB = _swig_property(_Box2D.b2WeldJointDef_localAnchorB_get, _Box2D.b2WeldJointDef_localAnchorB_set)
    referenceAngle = _swig_property(_Box2D.b2WeldJointDef_referenceAngle_get, _Box2D.b2WeldJointDef_referenceAngle_set)
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['anchor','bodyA','bodyB','collideConnected','localAnchorA','localAnchorB','referenceAngle','type','userData']) 

    def __set_anchor(self, value):
        if not self.bodyA:
            raise Exception('bodyA not set.')
        if not self.bodyB:
            raise Exception('bodyB not set.')
        self.localAnchorA=self.bodyA.GetLocalPoint(value)
        self.localAnchorB=self.bodyB.GetLocalPoint(value)
    def __get_anchor(self):
        if self.bodyA:
            return self.bodyA.GetWorldPoint(self.localAnchorA)
        if self.bodyB:
            return self.bodyB.GetWorldPoint(self.localAnchorB)
        raise Exception('Neither body was set; unable to get world point.')
    anchor = property(__get_anchor, __set_anchor, 
            doc="""The anchor in world coordinates.
                Getting the property depends on either bodyA and localAnchorA or 
                bodyB and localAnchorB.
                Setting the property requires that both bodies be set.""")

    __swig_destroy__ = _Box2D.delete_b2WeldJointDef
b2WeldJointDef.Initialize = new_instancemethod(_Box2D.b2WeldJointDef_Initialize,None,b2WeldJointDef)
b2WeldJointDef_swigregister = _Box2D.b2WeldJointDef_swigregister
b2WeldJointDef_swigregister(b2WeldJointDef)

class b2WeldJoint(b2Joint):
    """A weld joint essentially glues two bodies together. A weld joint may distort somewhat because the island constraint solver is approximate."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __dir__ = _dir_filter

    def __repr__(self):
        return _format_repr(self, ['active','anchorA','anchorB','bodyA','bodyB','type','userData']) 

    __swig_destroy__ = _Box2D.delete_b2WeldJoint
b2WeldJoint_swigregister = _Box2D.b2WeldJoint_swigregister
b2WeldJoint_swigregister(b2WeldJoint)

# Initialize the alternative namespace b2.*, and clean-up the
# dir listing of Box2D by removing *_swigregister.
#
# To see what this is, try import Box2D; print(dir(Box2D.b2))
from sys import version_info
if version_info >= (2, 5):
    from . import b2
else:
    import b2
del locals()['version_info']

s=None
to_remove=[]
for s in locals():
    if s.endswith('_swigregister'):
        to_remove.append(s)
    elif s!='b2' and s.startswith('b2'):
        if s[2]=='_': # Covers b2_*
            setattr(b2, s[3].lower() + s[4:], locals()[s])
        else: # The other b2*
            if s[3].isupper():
                setattr(b2, s[2:], locals()[s])
            else:
                setattr(b2, s[2].lower() + s[3:], locals()[s])
for s in to_remove:
    del locals()[s]

del locals()['s']
del locals()['to_remove']



